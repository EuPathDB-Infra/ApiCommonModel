#!/usr/bin/perl

use strict;

use lib $ENV{GUS_HOME} . "/lib/perl";

use JSON;
use DBI;
use DBD::Oracle;

use WDK::Model::ModelConfig;

use XML::Simple;

use Data::Dumper;

my $gbrowseXmlFile = $ENV{GUS_HOME} . "/lib/xml/gbrowse/gbrowseQueries.xml";

my ($gusHome, $projectId, $refseqName, $start, $end, $feature, @queryParams) = @ARGV;

my $modelConfig = new WDK::Model::ModelConfig($projectId);

my $xml = XMLin($gbrowseXmlFile);

my $dbh = DBI->connect( $modelConfig->getAppDbDbiDsn(),
                        $modelConfig->getAppDbLogin(),
                        $modelConfig->getAppDbPassword()
    )
    || die "unable to open db handle to ", $modelConfig->getAppDbDbiDsn();

# solve oracle clob problem; not that we're liable to need it...
$dbh->{LongTruncOk} = 0;
$dbh->{LongReadLen} = 10000000;
;

my ($seqId) = $dbh->selectrow_array("select na_sequence_id from apidbtuning.genomicseqattributes where source_id = '$refseqName'");

die "no seqId found for refseq $refseqName" unless($seqId);

my $result = {"features" => [] };

my $featureSql;

if($feature eq "ReferenceSequence") {
  $start = 1 if($start < 1);
  my $length = $end - $start + 1;

  $featureSql = "select substr(sequence, $start, $length) as seq, $start -1 as startm, $end -1 as end, '$refseqName' as feature_id from apidbtuning.genomicsequencesequence where source_id = '$refseqName'"
}
else {
  $featureSql = &makeSql($xml->{module}->{'Segment.pm'}->{sqlQuery}->{$feature}->{sql}, $start, $end, $seqId, \@queryParams);
}


my $sh = $dbh->prepare($featureSql);
$sh->execute();

my %lookup;

while(my $hash = $sh->fetchrow_hashref("NAME_lc")) {

  $hash->{start} = $hash->{startm} + 0;
  $hash->{end} = $hash->{end} + 0;
  if($hash->{atts}) {
    my @atts = split(';', $hash->{atts});
    foreach(@atts) {
      my ($key, $value) = split("=", $_);
      $hash->{$key} = $value;
    }
  }

  my $uniqueId = $hash->{feature_id};
  $hash->{uniqueID} = $uniqueId;

  $lookup{$uniqueId} = $hash;

  $hash->{subfeatures} = [];

  push @{$result->{features}}, $hash;
}

my $bulkSubfeature = "$feature:bulksubfeatures";
my $bulkSubfeatureSql =  $xml->{module}->{'Feature.pm'}->{sqlQuery}->{$bulkSubfeature}->{sql};
if($bulkSubfeatureSql) {
  $bulkSubfeatureSql = &makeSql($bulkSubfeatureSql, $start, $end, $seqId, \@queryParams);
  my $bsh = $dbh->prepare($bulkSubfeatureSql);
  $bsh->execute();

  while(my $hash = $bsh->fetchrow_hashref("NAME_lc")) {
    my $parent = $lookup{$hash->{parent_id}};
    $hash->{start} = $hash->{startm};

    if($hash->{tstarts}) {
      my @tstarts = map { s/\s+//g; $_+1 } split /,/, $hash->{tstarts};
      my @blocksizes = map { s/\s+//g; $_ } split /,/, $hash->{blocksizes};
      my $counter = 0;
      foreach my $start (@tstarts) {
        my $end = $start + $blocksizes[$counter] - 1;

        my %tmp = %$hash;
        $tmp{feature_id} = $tmp{feature_id} . "_$counter";
        $tmp{name} = $tmp{name} . "_$counter";
        $tmp{start} = $start;
        $tmp{end} = $end;
        push @{$parent->{subfeatures}}, \%tmp;
        $counter = $counter + 1;
      }
    }
    else {
      push @{$parent->{subfeatures}}, $hash;
    }
  }
}

print encode_json($result);

$dbh->disconnect();

sub makeSql {
  my ($sql, $start, $end, $seqId, $queryParams) = @_;

  my $dlm = '|';

  $sql =~ s/\$base_start/$start/g;
  $sql =~ s/\$rend/$end/g;
  $sql =~ s/\$dlm/;/g;
  $sql =~ s/\$srcfeature_id/$seqId/g;

  foreach my $p (@$queryParams) {
    next if($p =~ /select/i);
    my ($key, $value) = split(/=/, $p);
    $sql =~ s/\$\$${key}\$\$/${value}/g;
  }


  return $sql
}
