#!/usr/bin/perl

use strict;
use Switch;

usage() unless scalar(@ARGV) >= 1;

my $update = $ARGV[0] eq '-update';

shift @ARGV if $update;

my @files = @ARGV;

my @automaticRules = ('SRES.ONTOLOGYTERM', 'Study.OntologyEntry', 'sres.sequenceontology', 'rad.study');
my @manualRules = ('dots.gene', 'dots.RnaFeatureExon');
my @allowedStatus = ('unreviewed', 'broken', 'fixed', 'absent');

foreach my $file (@files) {
  die "File '$file' does not exist\n" unless -e $file;
}

foreach my $file (@files) {
  next if -d $file;
  open(F, $file) || die "Can't open file '$file' for reading\n";
  my @fileLines = <F>;
  close(F);
  my @reports;
  foreach my $rule (@automaticRules) {
    my $report = getAutomaticReport($rule, \@fileLines);
    push(@reports, $report);
  }
  @reports = (@reports, getManualReports(\@fileLines, $file));
  if ($update) {
    open(F, ">$file") || die "Can't open file '$file' for reading\n";
    my $allOk = 1;
    print F shift @fileLines;  # print first line of file before comment block
    print F "#vvvvvvvvvvvvvvvvvvvvvvvvv GUS4_STATUS vvvvvvvvvvvvvvvvvvvvvvvvv\n";
    map { print F "$_\n"; $allOk = 0 if /broken|unreviewed/} @reports;
    if (!$allOk) {
      print F "die 'This file has broken or unreviewed GUS4_STATUS rules.  Please remove this line when all are fixed or absent';\n";
    }
    print F "#^^^^^^^^^^^^^^^^^^^^^^^^^ End GUS4_STATUS ^^^^^^^^^^^^^^^^^^^^\n";
    map { print F $_ unless /GUS4_STATUS/; } @fileLines;
    close(F);
  }
  print "\n$file";
  print "\n" . join("\n", @reports) unless $update;
}
print "\n";

###############################################

sub getAutomaticReport {
  my ($rule, $fileLines) = @_;

  my @fields = ("  # GUS4_STATUS", sprintf("%-30s", $rule), "auto  ", "absent");

  foreach my $line (@$fileLines) {

    next if $line =~ /^\s*\#/;

    switch ($rule) {
      case "rad.study"
	{
	 if ($line =~ /rad.study/i || /rad::study/i) {
	   $fields[3] = 'broken';
	 }
	}
      case "sres.sequenceontology"
	{
	 if ($line =~ /sres.sequenceontology/i || $line =~ /sres::sequenceontology/i) {
	   $fields[3] = 'broken';
	 }
	}
      }
  }
  return join(' | ', @fields);

}

sub getManualReports {
  my ($fileLines, $file) = @_;
  my %manualStatus;
  map { $manualStatus{$_} = 'unreviewed' } @manualRules;
  my $lineCnt = 0;
  foreach my $line (@$fileLines) {
    $lineCnt++;
    next unless /^  # GUS4_STATUS\|\s+(.*)\s+\| MANUAL\s+\|\s+(\S+)/;
    my $rule = $1;
    my $status = $2;
    die "Invalid rule '$rule' mentioned in file '$file' on line $lineCnt" unless grep(/$rule/, @manualRules);
    die "Invalid status '$status' mentioned in file '$file' on line $lineCnt" unless grep(/$status/, @allowedStatus);
    $manualStatus{$rule} = $status;
  }
  my @reports;
  my @fields = ('  # GUS4_STATUS', '', 'manual', '');
  foreach my $rule (keys(%manualStatus)) {
    my $rulestr = sprintf("%-30s", $rule);
    $fields[1] = $rulestr;
    $fields[3] = $manualStatus{$rule};
    my $report = join(" | ", @fields);
    push(@reports, $report);
  }
  return @reports;
}

sub usage {

die "
Check a file for code that violates the GUS4/Alt Splice migration rules.  Print a report about each file.

Usage: gus4CheckFile [-update] files

Where:
  -update:  if provided, update the files with a new status section
  files:    the files to update

Comments in the target files look like this:

# GUS4_STATUS  | RAD.STUDY                 | auto   | broken
# GUS4_STATUS  | PROTEIN                   | manual | unreviewed

The status codes are:
  unreviewed
  absent
  broken
  fixed

";

}
