#!/usr/bin/perl

use strict;
use Switch;

usage() unless scalar(@ARGV) >= 1;

my $update = $ARGV[0] eq '-update';

shift @ARGV if $update;

my @files = @ARGV;

my @automaticRules = ('SRES.ONTOLOGYTERM', 'Study.OntologyEntry', 'sres.sequenceontology', 'rad.study');
my @manualRules = ('dots.gene', 'dots.RnaFeatureExon');
my @allowedStatus = ('unreviewed', 'broken', 'fixed', 'absent');

foreach my $file (@files) {
  die "File '$file' does not exist\n" unless -e $file;
}

foreach my $file (@files) {
  next if -d $file;
  open(F, $file) || die "Can't open file '$file' for reading\n";
  my @fileLines = <F>;
  close(F);
  my @reports;
  foreach my $rule (@automaticRules) {
    my $report = getAutomaticReport($rule, \@fileLines);
    push(@reports, $report);
  }
  @reports = (@reports, getManualReports(\@fileLines, $file));
  if ($update) {
    open(F, ">$file") || die "Can't open file '$file' for reading\n";
    my $allOk = 1;
    print F shift @fileLines;  # print first line of file before comment block
    print F "#vvvvvvvvvvvvvvvvvvvvvvvvv GUS4_STATUS vvvvvvvvvvvvvvvvvvvvvvvvv\n";
    map { print F "$_\n"; $allOk = 0 if /broken|unreviewed/} @reports;
    if (!$allOk) {
      print F "die 'This file has broken or unreviewed GUS4_STATUS rules.  Please remove this line when all are fixed or absent';\n";
    }
    print F "#^^^^^^^^^^^^^^^^^^^^^^^^^ End GUS4_STATUS ^^^^^^^^^^^^^^^^^^^^\n";
    map { print F $_ unless /GUS4_STATUS/; } @fileLines;
    close(F);
  }
  print "\n$file";
  print "\n" . join("\n", @reports) unless $update;
}
print "\n";

###############################################

sub getAutomaticReport {
  my ($rule, $fileLines) = @_;

  my @fields = ("  # GUS4_STATUS", sprintf("%-30s", $rule), "auto  ", "absent");

  foreach my $line (@$fileLines) {

    next if $line =~ /^\s*\#/;

    switch ($rule) {

      case "SRes.OntologyTerm"
	{
	 if ($line =~ /sres\.ontologyterm/i || $line =~ /sres::ontologyterm/i) {
	   $fields[3] = 'broken';
	 }
	}

      case "SRes.SequenceOntology"
	{
	 if ($line =~ /sres\.sequenceontology/i || $line =~ /sres::sequenceontology/i) {
	   $fields[3] = 'broken';
	 }
	}


      case "Study.OntologyEntry"
	{
	 if ($line =~ /study\.ontologyentry/i || $line =~ /study::ontologyentry/i) {
	   $fields[3] = 'broken';
	 }
	}


      case "SRes.GOTerm"
	{
	 if ($line =~ /sres\.goevidencecode/i || $line =~ /sres::goevidencecode/i ||
             $line =~ /sres\.gorelationship/i || $line =~ /sres::gorelationship/i ||
             $line =~ /sres\.gosynonym/i || $line =~ /sres::gosynonym/i ||
             $line =~ /sres\.goterm/i || $line =~ /sres::goterm/i ) {
	   $fields[3] = 'broken';
	 }
	}

      # Always Broken
      case "Dots.Gene"
	{
          $fields[3] = 'broken';
	}


      case "Dots.RNAFeatureExon"
	{
	 if ($line =~ /dots\.rnafeatureexon/i || $line =~ /dots::rnafeatureexon/i) {
	   $fields[3] = 'broken';
	 }
	}


      case "RAD.SageTag"
	{
	 if ($line =~ /rad\.acquisition/i || $line =~ /rad::acquisition/i ||
             $line =~ /rad\.assay/i || $line =~ /rad::assay/i ||
             $line =~ /rad\.quantification/i || $line =~ /rad::quantification/i ||
             $line =~ /rad\.studyassay/i || $line =~ /rad::studyassay/i ||
             $line =~ /rad\.arraydesign/i || $line =~ /rad::arraydesign/i ||
             $line =~ /rad\.sage/i || $line =~ /rad::sage/i ) {
	   $fields[3] = 'broken';
	 }
	}


      case "RAD.Analysis"
	{
	 if ($line =~ /rad\.analysis/i || $line =~ /rad::analysis/i ||
             $line =~ /rad\.datatransformation/i || $line =~ /rad::datatransformation/i ||
             $line =~ /rad\.differential/i || $line =~ /rad::differential/i ||
             $line =~ /rad\.logicalgroup/i || $line =~ /rad::logicalgroup/i ||
             $line =~ /rad\.protocol/i || $line =~ /rad::protocol/i ) {
	   $fields[3] = 'broken';
	 }
        }

      case "ApiDB.Profile"
	{
	 if ($line =~ /apidb\.profile/i || $line =~ /apidb::profile/i) {
	   $fields[3] = 'broken';
	 }
	}


      case "Study.Study"
	{
	 if ($line =~ /study\.study/i || $line =~ /study::study/i ||
             $line =~ /study\.bios/i || $line =~ /study::bios/i ||
             $line =~ /study\.biomaterial/i || $line =~ /study::biomaterial/i ||
             $line =~ /rad\.studybiomaterial/i || $line =~ /rad::studybiomaterial/i) {
	   $fields[3] = 'broken';
	 }
	}

      case "Dots.Isolate"
	{
	 if ($line =~ /dots\.isolate/i || $line =~ /dots::isolate/i) {
	   $fields[3] = 'broken';
	 }
	}


      case "DeprecatedTables"
	{
	 if ($line =~ /sres\.reference/i || $line =~ /sres::reference/i ||
             $line =~ /sres\.bibreftype/i || $line =~ /sres::bibreftype/i ||
             $line =~ /sres\.enzymeclassattribute/i || $line =~ /sres::enzymeclassattribute/i ||
             $line =~ /sres\.ontologyrelationship/i || $line =~ /sres::ontologyrelationship/i ||
             $line =~ /sres\.contact/i || $line =~ /sres::contact/i ) {
	   $fields[3] = 'broken';
	 }
	}

      else { 
        die "RULE $rule not handled";
      }

    }
  }
  return join(' | ', @fields);

}

sub getManualReports {
  my ($fileLines, $file) = @_;
  my %manualStatus;
  map { $manualStatus{$_} = 'unreviewed' } @manualRules;
  my $lineCnt = 0;
  foreach my $line (@$fileLines) {
    $lineCnt++;
    next unless /^  # GUS4_STATUS\|\s+(.*)\s+\| MANUAL\s+\|\s+(\S+)/;
    my $rule = $1;
    my $status = $2;
    die "Invalid rule '$rule' mentioned in file '$file' on line $lineCnt" unless grep(/$rule/, @manualRules);
    die "Invalid status '$status' mentioned in file '$file' on line $lineCnt" unless grep(/$status/, @allowedStatus);
    $manualStatus{$rule} = $status;
  }
  my @reports;
  my @fields = ('  # GUS4_STATUS', '', 'manual', '');
  foreach my $rule (keys(%manualStatus)) {
    my $rulestr = sprintf("%-30s", $rule);
    $fields[1] = $rulestr;
    $fields[3] = $manualStatus{$rule};
    my $report = join(" | ", @fields);
    push(@reports, $report);
  }
  return @reports;
}

sub usage {

die "
Check a file for code that violates the GUS4/Alt Splice migration rules.  Print a report about each file.

Usage: gus4CheckFile [-update] files

Where:
  -update:  if provided, update the files with a new status section
  files:    the files to update

Comments in the target files look like this:

# GUS4_STATUS  | RAD.STUDY                 | auto   | broken
# GUS4_STATUS  | PROTEIN                   | manual | unreviewed

The status codes are:
  unreviewed
  absent
  broken
  fixed

";

}
