#!/usr/bin/perl

usage() unless scalar(@ARGV) >= 1;

my $update = $ARGV[0] eq '-update';

shift @ARGV if $update;

my @files = @ARGV;

my @automaticRules = ('', '');
my @manualRules = ('', '');
my @allowedStatus = ('unreviewed', 'broken', 'fixed', 'absent');

foreach my $file (@files) {
  die "File '$file' does not exist\n" unless -e $file;
}

foreach my $file (@files) {
  open(F, $file) || die "Can't open file '$file' for reading\n";
  my @fileLines = <F>;
  close(F);
  my @reports;
  foreach my $rule (@automaticRules) {
    my $report = getAutomaticReport($rule, \@fileLines);
    push($report, @reports);
  }
  @reports = (@reports, getManualReports(\@fileLines));
  if ($update) {
    open(F, $file) || die "Can't open file '$file' for reading\n";
    my $allOk = 1;
    map { print F "$_\n"; $allOk = 0 if /broken|unreviewed/} @reports;
    if (!$allOk) {
      print F "die 'This file has broken or unreviewed GUS4 migration rules.  Please remove this line when all are fixed or absent'\n";
    }
    map { print F "$_\n"; } @fileLines;
    close(F);
  }
  print $report;
}

sub getAutomaticReport {
  my ($rule, $fileLines) = @_;

  my @fields = ("# GUS4 STATUS", $rule, "AUTOMATIC", "absent");

  switch ($rule) {
    case ""
      {
       foreach $line (@$fileLines) {
	 next if $line =~ /^\s*#/;
	 if ($line =~ /rad.study/i || /rad::study/i) {
	   $fields[3] = 'broken';
	   break;
	 }
       }
       break;
      }
    case ""
      {
       break;
      }
    case ""
      {
       break;
      }
    case ""
      {
       break;
      }
    case ""
      {
       break;
      }
    case ""
      {
       break;
      }
    case ""
      {
       break;
      }
    case ""
      {
       break;
      }
    case ""
      {
       break;
      }
    case ""
      {
       break;
      }
    case ""
      {
       break;
      }
    case ""
      {
       break;
      }
    }
  return join(' | ', @fields);
}

sub getManualReports {
  my ($fileLines) = @_;
  my %manualStatus;
  map { $manualStatus{$_} = 'unreviewed' } @manualRules;
  my $line = 0;
  foreach my $line (@$fileLines) {
    $line++;
    next unless /^# GUS4_STATUS\|\s+(.*)\s+\| MANUAL\s+\|\s+(\S+)/;
    my $rule = $1;
    my $status = $2;
    die "Invalid rule '$rule' mentioned in file '$file' on line $line" unless grep(/$rule/, @manualRules);
    die "Invalid status '$status' mentioned in file '$file' on line $line" unless grep(/$status/, @allowedStatus);
    $manualStatus{$rule} = $status;
  }
  my @reports;
  my @fields = ('# GUS4_STATUS', '', 'MANUAL   ', '');
  foreach my $rule (keys(@manualStatus)) {
    my $rulestr = sprintf("%-30s", $rule);
    $fields[1] = $rulestr;
    $fields[3] = $manualStatus{$rule};
    my $report = join(" | ", @fields);
    push($report, @reports);
  }
  return @reports;
}

sub usage {

die "
Check a file for code that violates the GUS4/Alt Splice migration rules.  Print a report about each file.

Usage: gus4CheckFile [-update] files

Where:
  -update:  if provided, update the files with a new status section
  files:    the files to update

Comments in the target files look like this:

# GUS4_STATUS  | RAD.STUDY                 | AUTOMATIC | broken
# GUS4_STATUS  | PROTEIN                   | MANUAL    | unreviewed

The status codes are:
  unreviewed
  absent
  broken
  fixed

";

}
