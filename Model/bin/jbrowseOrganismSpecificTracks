#!/usr/bin/perl

use strict;
use lib $ENV{GUS_HOME} . "/lib/perl";
use JSON;
use ApiCommonModel::Model::JBrowseUtil;
use Data::Dumper;
use URI::Escape;

use Storable 'dclone';
use Tie::IxHash;

my %datasets;
my $t = tie %datasets, 'Tie::IxHash';


my ($organismAbbrev, $projectName) = @ARGV;

my $jbrowseUtil = ApiCommonModel::Model::JBrowseUtil->new({projectName => $projectName});

my $dbh = $jbrowseUtil->getDbh();   

my $result = {"tracks" => [] };
#my $result = {"tracks" => []};

&addScaffolds($dbh, $result);
&addCentromere($dbh, $result);
&addUnifiedMassSpec($dbh, $result);
&addUnifiedSnp($dbh, $result);
&addSynteny($dbh, $result);

&addDatasets($dbh, \%datasets);

my $datasetProperties = &datasetProperties($dbh);

&addChipChipTracks($dbh, $result, $datasetProperties);
&addSmallNcRnaSeq($dbh, $result, $datasetProperties);
&addProteinExpressionMassSpec($dbh, $result, $datasetProperties);
&addVCF($dbh, $result, $datasetProperties);

# other organism specific tracks
if($organismAbbrev eq 'tcruCLBrenerEsmeraldo-like') {
  &addCnvArray($dbh, $result);
}


$result->{datasets} = \%datasets;

print encode_json($result);


sub addDatasets {
  my ($dbh) = @_;

  my $sql = "select public_abbrev, organism_name FROM APidbtuning.organismattributes order by organism_name";

  my $sh = $dbh->prepare($sql);
  $sh->execute();

  while(my ($abbrev, $name) = $sh->fetchrow_array()) {
    $datasets{$abbrev}->{name} = $name;
    $datasets{$abbrev}->{url} = "?data=/a/service/jbrowse/tracks/${abbrev}";
#    $result->{datasets}->{$abbrev}->{name} = $name;
#    $result->{datasets}->{$abbrev}->{url} = "?data=tracks/${abbrev}";
  }
  $sh->finish();
}

sub datasetProperties {
  my ($dbh) = @_;

  my $sql = "select dsp.name, prop.property, prop.value
from apidbtuning.datasetpresenter dsp
   , apidbtuning.datasetproperty prop
where dsp.name like '${organismAbbrev}%_chipChipExper%_RSRC'
and dsp.dataset_presenter_id = prop.dataset_presenter_id
UNION
select dsp.name, prop.property, prop.value
from apidbtuning.datasetpresenter dsp
   , apidbtuning.datasetproperty prop
where dsp.name like '${organismAbbrev}%_ebi_VCF_RSRC'
and dsp.dataset_presenter_id = prop.dataset_presenter_id
UNION
select dsp.name, prop.property, prop.value
from apidbtuning.datasetpresenter dsp
   , apidbtuning.datasetproperty prop
where dsp.name like '${organismAbbrev}%_smallNcRna_%_RSRC'
and dsp.dataset_presenter_id = prop.dataset_presenter_id
UNION
select distinct dsp.name, prop.property, prop.value
from apidbtuning.datasetnametaxon dnt,
     apidbtuning.datasetproperty prop,
     apidbtuning.datasetpresenter dsp,
     apidb.organism o
where dnt.taxon_id = o.taxon_id
and o.public_abbrev = '${organismAbbrev}'
and dnt.name like '%_massSpec%_RSRC'
and dnt.dataset_presenter_id = prop.dataset_presenter_id
and prop.dataset_presenter_id = dsp.dataset_presenter_id
";

  my $sh = $dbh->prepare($sql);
  $sh->execute();

  my %datasetProperties;
  while(my ($datasetName, $prop, $val) = $sh->fetchrow_array()) {
    $datasetProperties{$datasetName}->{$prop} = $val;
  }
  $sh->finish();

  return \%datasetProperties;
}

sub addVCF {
  my ($dbh, $result, $datasetProperties) = @_;

  foreach my $dataset (keys %$datasetProperties) {
    next unless($dataset =~ /VCF/);
    
    #my $experimentName = $datasetProperties->{$dataset}->{experimentName};
    my $experimentName = $datasetProperties->{$dataset}->{Name};
    my $datasetDisplayName = $datasetProperties->{$dataset}->{datasetDisplayName};
    my $summary = $datasetProperties->{$dataset}->{summary};
    $summary =~ s/\n/ /g;
    my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};

    my $sql = "select o.NAME_FOR_FILENAMES, ds.name from apidb.datasource ds, apidb.organism o where ds.taxon_id = o.taxon_id and ds.name like '${organismAbbrev}%_ebi_VCF_RSRC'";
    #my $sql = "select o.NAME_FOR_FILENAMES, ds.name from apidb.datasource ds, apidb.organism o where ds.taxon_id = o.taxon_id and ds.name like '${organismAbbrev}_${experimentName}_ebi_VCF_RSRC'";
    my $sh = $dbh->prepare($sql);
    $sh->execute();

    while(my ($nameForFileNames, $sampleDataset) = $sh->fetchrow_array()) {
      #my ($sampleName) = $sampleDataset =~ /${organismAbbrev}_${experimentName}_(.+)_ebi_VCF_RSRC/;
      my ($sampleName) = $sampleDataset;
      my ($vcfFileName) = $sampleName =~ m/${organismAbbrev}_(.+)_ebi_VCF_RSRC/;
      #my $vcfUrl = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFileNames}/vcf/${sampleName}/$VCFfileName");
      my $vcfUrl = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFileNames}/vcf/${sampleName}/${vcfFileName}.vcf.gz");
      my $alignment = {storeClass => "JBrowse/Store/SeqFeature/VCFTabix",
                       urlTemplate => $vcfUrl,
                           #key => "${vcfFileName} SNPs from VCF",
                           key => "${experimentName} SNOOPs from VCF",
                           label => "${sampleName} SNPs",
                           type => "JBrowse/View/Track/CanvasVariants",
                           glyph => "EbrcFeatureGlyphs/View/FeatureGlyph/Diamond",
                           category => "VCF",
                           metadata => {
                             subcategory => 'SNPs',
                             dataset => $datasetDisplayName,
                             trackType => 'SNPs',
                             attribution => $shortAttribution,
                             description => $summary,
                           },
                          fmtMetaValue_Dataset => "function() { return datasetLink('${dataset}', '${datasetDisplayName}'); }",
                          fmtMetaValue_Description => "function() { return datasetDescription('${summary}', ''); }",
      };

      push @{$result->{tracks}}, $alignment;
    }
  }
}


sub addProteinExpressionMassSpec {
  my ($dbh, $result, $datasetProperties) = @_;

  foreach my $dataset (keys %$datasetProperties) {
    next unless($dataset =~ /_massSpec_/);

    my $experimentName = $datasetProperties->{$dataset}->{name};
    my $datasetDisplayName = $datasetProperties->{$dataset}->{datasetDisplayName};
    my $category = $datasetProperties->{$dataset}->{datasetClassCategory};

    my $summary = $datasetProperties->{$dataset}->{summary};
    $summary =~ s/\n/ /g;
    my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};

    my $massSpec = {storeClass => "JBrowse/Store/SeqFeature/REST",
                    baseUrl => "/a/service/jbrowse",
                    type => "JBrowse/View/Track/CanvasFeatures",
                    glyph => "JBrowse/View/FeatureGlyph/Segments",
                    subParts => "Peptide",
                    displayMode => "compact",
                    query => {'feature' => "domain:MassSpecPeptide",
                              'edName' => "like '${dataset}'",
                    },
                    key => "${datasetDisplayName}  MS/MS Peptides  ${shortAttribution}",
                    label => "${dataset}",
                    category => "Proteomics",
                    style => {'color' => "{massSpecColor}",
                              'label' => "Sample,sample,name",
                    },
                    metadata => {
                      subcategory => 'Protein Expression',
                      dataset => $datasetDisplayName,
                      trackType => 'Segments',
                      attribution => $shortAttribution,
                      description => $summary,
                    },
                    fmtMetaValue_Dataset => "function() { return datasetLink('${dataset}', '${datasetDisplayName}'); }",
                    fmtMetaValue_Description => "function() { return datasetDescription('${summary}', ''); }",
                    onClick => {
                      content => "{massSpecDetails}",
                    },
                    menuTemplate => [
                      {label => "View Details", 
                       content => "{massSpecDetails}",
                      },
                        ],
    };

    push @{$result->{tracks}}, $massSpec;
  }
}

sub addSmallNcRnaSeq {
  my ($dbh, $result, $datasetProperties) = @_;

  foreach my $dataset (keys %$datasetProperties) {
    next unless($dataset =~ /smallNcRna/);

    my $experimentName = $datasetProperties->{$dataset}->{experimentName};
    my $datasetDisplayName = $datasetProperties->{$dataset}->{datasetDisplayName};
    my $summary = $datasetProperties->{$dataset}->{summary};
    $summary =~ s/\n/ /g;
    my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};

    my $sql = "select o.NAME_FOR_FILENAMES, ds.name from apidb.datasource ds, apidb.organism o where ds.taxon_id = o.taxon_id and ds.name like '${organismAbbrev}%_smallNcRnaSample_RSRC'";

    my $sh = $dbh->prepare($sql);
    $sh->execute();

    while(my ($nameForFileNames, $sampleDataset) = $sh->fetchrow_array()) {
      my ($sampleName) = $sampleDataset =~ /${organismAbbrev}_${experimentName}_(.+)_smallNcRnaSample_RSRC/;

      # Example: EhistolyticaHM1IMSS/bam/Singh_Small_RNA/Rahman/Rahman.bam
      my $bamUrl = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFileNames}/bam/$experimentName/${sampleName}/${sampleName}.bam");

      my $alignment = {storeClass => "JBrowse/Store/SeqFeature/BAM",
                       urlTemplate => $bamUrl,
                           key => "${sampleName} Small Non-coding RNAs",
                           label => "${sampleName} Small Non-coding RNAs",
                           type => "SmallRNAPlugin/View/Track/smAlignments",
                           category => "Transcriptomics",
                           yScalePosition => "left",
                           metadata => {
                             subcategory => 'small non-coding RNA',
                             dataset => $datasetDisplayName,
                             trackType => 'Small RNA',
                             attribution => $shortAttribution,
                             description => $summary,
                           },
                          fmtMetaValue_Dataset => "function() { return datasetLink('${dataset}', '${datasetDisplayName}'); }",
                          fmtMetaValue_Description => "function() { return datasetDescription('${summary}', ''); }",
      };

      push @{$result->{tracks}}, $alignment;
    }
  }
}

sub addCentromere {
  my ($dbh, $result) = @_;

  my $sql = "select count(*) from apidbtuning.organismattributes where hasCentromere = 1 and  public_abbrev = '${organismAbbrev}'";

  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $count = $sh->fetchrow_array();
  $sh->finish();
  if($count > 0) {

    my $track = {storeClass => "JBrowse/Store/SeqFeature/REST",
                 baseUrl => "/a/service/jbrowse",
                 type => "JBrowse/View/Track/CanvasFeatures",
                 glyph => "JBrowse/View/FeatureGlyph/Box",
                 key => "Centromere",
                 label => "Centromere",
                 category => "Sequence Analysis",
                 displayMode => "normal",
                 style => {
                   color => "blue",
                 },
                 metadata => {
                   subcategory => "Sequence sites, features and motifs",
                   trackType => 'Segments',
                 },
                 query => {'feature' => "Centromere:overview",
                 },
                 onClick => {
                   content => "{positionTitle}",
                 },
                 menuTemplate => [
                   {label => "View Details", 
                    content => "{positionTitle}",
                   },
                     ],
    };

    push @{$result->{tracks}}, $track;


  }

}

sub addScaffolds {
  my ($dbh, $result) = @_;

  my $sql = "select count(*) from dots.scaffoldgapfeature sgf, apidbtuning.genomicseqattributes sa, apidb.organism o where sa.na_sequence_id = sgf.na_sequence_id and o.taxon_id = sa.taxon_id and public_abbrev = '${organismAbbrev}'";


  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $count = $sh->fetchrow_array();
  $sh->finish();
  if($count > 0) {

    my $track = {storeClass => "JBrowse/Store/SeqFeature/REST",
                 baseUrl => "/a/service/jbrowse",
                 type => "JBrowse/View/Track/CanvasFeatures",
                 glyph => "JBrowse/View/FeatureGlyph/Segments",
#                 glyph => "function(feature){ return changeScaffoldType(feature)}",
                 key => "Scaffolds (Gaps in Red when known)",
                 label => "Scaffolds",
                 category => "Sequence Analysis",
                 displayMode => "normal",
                 subParts => "sgap",
                    style => {
                      connectorColor => 'white',
                      connectorThickness => '0',
                      color => "function( feature, variableName, glyphObject, track ){ var c = track.browser.config; return c.scaffoldColor(feature)}",
                      height => "function(feature, variableName, glyphObject, track){ var c = track.browser.config; return c.scaffoldHeight(feature)}",
                    },
                    metadata => {
                      subcategory => "Sequence assembly",
                      trackType => 'Segments',
                    },
                    query => {'feature' => "scaffold:genome",
                    },
                     onClick => {
                       content => "function(track, feature){ var c = track.browser.config; return c.scaffoldDetails(track, feature)}",
                     },
                     menuTemplate => [
                       {label => "View Details", 
                        content => "function(track, feature){ var c = track.browser.config; return c.scaffoldDetails(track, feature)}",
                       },
                         ],
    };

    push @{$result->{tracks}}, $track;


  }
}

sub addSynteny {
  my ($dbh, $result) = @_;

  my $sql = "select otr.organism, otr.public_abbrev, otr.phylum, otr.genus, otr.species, otr.kingdom, otr.class, gt.gtracks
            from APIDBTUNING.ORGANISMSELECTTAXONRANK otr
               , APIDBTUNING.ORGANISMATTRIBUTES oa
               , (select * from APIDBTUNING.GBROWSETRACKSORGANISM where type = 'synteny' ) gt
            where oa.ORGANISM_NAME = otr.organism 
            and oa.IS_ANNOTATED_GENOME = 1
            and oa.PROJECT_ID = '${projectName}'
            and oa.ORGANISM_NAME = gt.organism (+)";

  my $hasSyntenyTracks = 0;

  my $orgGTracks;
  my %subtracks;
  my %defaults;

  my $taxonNamesToNode = {};
  my $rootNode = _Tree->new({_name => 'root'});
  my $refOrganism;


  my $sh = $dbh->prepare($sql);
  $sh->execute();
  while(my ($organism, $publicAbbrev, $phylum, $genus, $species, $kingdom, $class, $gTracks) = $sh->fetchrow_array()) {
    if($publicAbbrev eq $organismAbbrev) {
      $hasSyntenyTracks = 1;
      $gTracks =~ s/^.+Synteny\///;
      %defaults = map { $_ => 1 } split(/\+/, $gTracks);
      $refOrganism = $organism;
    }
    my $kingdomNode = &makeTreeNode('k_' . $rootNode, $kingdom, $taxonNamesToNode, $rootNode);
    my $phylumNode = &makeTreeNode('p_' . $kingdom, $phylum, $taxonNamesToNode, $kingdomNode);
    my $classNode = &makeTreeNode('c_'. $phylum, $class, $taxonNamesToNode, $phylumNode);
    my $genusNode = &makeTreeNode('g_'. $class, $genus, $taxonNamesToNode, $classNode);
    my $speciesNode = &makeTreeNode('s_'. $genus, $species, $taxonNamesToNode, $genusNode);
    my $strainNode = &makeTreeNode('', $organism, $taxonNamesToNode, $speciesNode);

    # stuff these things in the leaf nodes
    $strainNode->setAbbrev($publicAbbrev);
    $strainNode->setFeatureFilters({ "taxon" => $organism});
    $strainNode->setMetadata({"Kingdom" => $kingdom,
                              "Phylum" => $phylum,
                              "Class" => $class,
                              "Genus" => $genus,
                              "Species" => $species 
                             });
  }
  $sh->finish();

  if($hasSyntenyTracks) {
    my $subtracksAr = [];

    my $refOrganismNode = $taxonNamesToNode->{$refOrganism};

    &addSubtracks($subtracksAr, $refOrganismNode, $taxonNamesToNode, \%defaults, $organismAbbrev);

    my $syntenyTrack = {storeClass => "EbrcTracks/Store/SeqFeature/REST",
                        baseUrl => "/a/service/jbrowse",
                        type => "EbrcTracks/View/Track/Synteny",
                        transcriptType => "processed_transcript",
                        noncodingType => ["nc_transcript"],
                        glyph => "function(f){return f.get('syntype') === 'span' ? 'JBrowse/View/FeatureGlyph/Box' : 'JBrowse/View/FeatureGlyph/Gene'; }",
                        subParts => "CDS,UTR,five_prime_UTR,three_prime_UTR,nc_exon",
                        key => "Syntenic Sequences and Genes (Shaded by Orthology)",
                        label => "Syntenic Sequences and Genes (Shaded by Orthology)",
                        region_feature_densities => "function(){return false}",
                        category => "Comparative Genomics",
                        geneGroupAttributeName => "orthomcl_name",
                        displayMode => "normal",

                        style => {
                          color => "{syntenyColorFxn}",
                          utrColor => "grey",
#                          borderColor => "{syntenyBorderColorFxn}",
#                          borderWidth => 4,
                          connectorThickness => "function(f){return f.get('syntype') === 'span' ? 3 : 1; }",
                          showLabels => "function(){return false}",
                          strandArrow => "function(f){return f.get('syntype') === 'span' ? false : true; }",
                          height => "function(f){return f.get('syntype') === 'span' ? 2 : 5; }",
#                          height => 5,
                          marginBottom => 0,
                       },
                        metadata => {
                          subcategory => "Orthology and Synteny",
                          trackType => 'Segments',
                        },
                        query => {'feature' => "gene:syntenyJBrowseScaled"
                        },
                        subtracks => $subtracksAr,
                        onClick => {
                          content => "{syntenyTitleFxn}",
                        },
                        menuTemplate => [
                          {label => "View Details", 
                           content => "{syntenyTitleFxn}",
                          },
                          {label => "View Gene or Sequence Page",
                           title => "function(track,f) { return f.get('syntype') == 'span' ? f.get('contig') : f.get('name'); }", 
                           iconClass => "dijitIconDatabase", 
                           action => "iframeDialog", 
                           url => "function(track,f) { return f.get('syntype') == 'span' ? '/a/app/record/genomic-sequence/' + f.get('contig') : '/a/app/record/gene/' + f.get('name') }"}
                            ],
    };
    
    push @{$result->{tracks}}, $syntenyTrack;


  }

}



sub addSubtracks {
  my ($subtracks, $node, $taxonNamesToNode, $defaults, $organismAbbrev) = @_;

  return if($node->getAlreadySeen());
  return if($node->isRoot());

  if($node->isLeaf()) {
    my $abbrev = $node->getAbbrev();

    foreach my $type ("gene", "span") {
      my $metadataClone = dclone $node->getMetadata();
      my $ffClone = dclone $node->getFeatureFilters();
      $ffClone->{syntype} = $type;

      my $label = "${abbrev}_${type}";

      my $visible = $abbrev eq $organismAbbrev || $defaults->{$label} ? 'true' : 'false';

      my $subtrack = {featureFilters => $ffClone,
                      metadata => $metadataClone,
                      label => "$abbrev $type",
                      visible => $visible
      };
      push @$subtracks, $subtrack;
    }
  }
  else {
    my $children = $node->getChildren();

    foreach my $child (@$children) {
      &addSubtracks($subtracks, $child, $taxonNamesToNode, $defaults, $organismAbbrev);
    }
  }

  $node->setAlreadySeen(1);

  my $parent = $node->getParent();
  
  &addSubtracks($subtracks, $parent, $taxonNamesToNode, $defaults, $organismAbbrev);
}

sub makeTreeNode {
  my ($prefix, $name, $taxonNamesToNode, $parentNode) = @_;

  my $key = $prefix . $name;

  my $node = $taxonNamesToNode->{$key};
  unless($node) {
    $node = _Tree->new({_parent => $parentNode, _name => $name});
    $parentNode->addChild($node);
  }
  
  $taxonNamesToNode->{$key} = $node;

  return $node;
}


sub addUnifiedSnp {
  my ($dbh, $result) = @_;

  my $sql = "select count(*) from apidbtuning.datasetpresenter where name like '${organismAbbrev}%HTS_SNP_%'";
  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $snpCount = $sh->fetchrow_array();
  $sh->finish();

  if($snpCount > 0) {
    my $snpTrack = {storeClass => "JBrowse/Store/SeqFeature/REST",
                    baseUrl => "/a/service/jbrowse",
                    type => "JBrowse/View/Track/CanvasFeatures",
                    glyph => "EbrcFeatureGlyphs/View/FeatureGlyph/Diamond",
                    key => "SNPs by coding potential",
                    label => "SNPs by coding potential",
                    maxFeatureScreenDensity => 0.01,
                    region_feature_densities => "function(){return true}",
                    category => "Genetic Variation",
                    displayMode => "normal",
                    style => {
                      color => "{snpColorFxn}",
                      strandArrow => "function(){return false}",
                      labelScale => 1000000000000000, #some really big number so labels are not shown; showLabels=false not working here or in hook TODO
                    },
                    metadata => {
                      subcategory => "DNA polymorphism",
                      trackType => 'Diamond',
                    },
                    query => {'feature' => "SNP:Population",
                              'edname' => 'InsertSnps.pm NGS SNPs INTERNAL'
                    },
                     onClick => {
                       content => "{snpTitleFxn}",
                     },
                     menuTemplate => [
                       {label => "View Details", 
                        content => "{snpTitleFxn}",
                       },
                         ],
    };

    push @{$result->{tracks}}, $snpTrack;

  }

}

sub addUnifiedMassSpec {
  my ($dbh, $result) = @_;

  my $sql = "select count(*) from apidbtuning.datasetpresenter where name like '${organismAbbrev}%massSpec%'";
  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $massSpecCount = $sh->fetchrow_array();
  $sh->finish();

  if($massSpecCount > 0) {
    my $unifiedMassSpecTrack = {storeClass => "JBrowse/Store/SeqFeature/REST",
                                baseUrl => "/a/service/jbrowse",
                                type => "JBrowse/View/Track/CanvasFeatures",
                                key => "All MS/MS Peptides",
                                label => "UnifiedMassSpecPeptides",
                                maxFeatureScreenDensity => 0.01,
                                region_feature_densities => "function(){return true}",
                                category => "Proteomics",
                                displayMode => "compact",
                                style => {
                                  color => "{massSpecColor}",
                                },
                                metadata => {
                                  subcategory => "Protein Expression",
                                  trackType => 'Segments',
                                },
                                query => {'feature' => "domain:UnifiedMassSpecPeptides",
                                },
                                onClick => {
                                  content => "{massSpecDetails}",
                                },
                                menuTemplate => [
                                  {label => "View Details", 
                                   content => "{massSpecDetails}",
                                  },
                                    ],
    };

    push @{$result->{tracks}}, $unifiedMassSpecTrack;

  }


}

sub addChipChipTracks {
  my ($dbh, $result, $datasetProperties) = @_;

  my $sql = "select d.name, s.name, pan.name, pan.protocol_app_node_id
from study.study s
   , SRES.EXTERNALDATABASERELEASE r
   , SRES.EXTERNALDATABASE d
   , study.protocolappnode pan
   , study.studylink sl
where d.name like '${organismAbbrev}%_chipChipExper_%'
and s.EXTERNAL_DATABASE_RELEASE_ID = r.EXTERNAL_DATABASE_RELEASE_ID
and r.EXTERNAL_DATABASE_ID = d.EXTERNAL_DATABASE_ID
and s.study_id = sl.study_id
and sl.protocol_app_node_id = pan.PROTOCOL_APP_NODE_ID";

  my $sh = $dbh->prepare($sql);
  $sh->execute();

  while(my ($dataset, $study, $panName, $panId) = $sh->fetchrow_array()) {
    if($panName =~ /_peaks \(ChIP-chip\)/) {
        my $peakTrack = &makeChipChipPeak($dataset, $study, $panName, $panId, $datasetProperties);
        push @{$result->{tracks}}, $peakTrack;
    }
    if($panName =~ /_smoothed \(ChIP-chip\)/) {
      my $track = &makeChipChipSmoothed($dataset, $study, $panName, $panId, $datasetProperties);
      push @{$result->{tracks}}, $track;
    }
  }
 
  $sh->finish();
}


sub makeChipChipPeak {
  my ($dataset, $study, $panName, $panId, $datasetProperties) = @_;

  my $datasetDisplayName = $datasetProperties->{$dataset}->{datasetDisplayName};
  my $summary = $datasetProperties->{$dataset}->{summary};
  $summary =~ s/\n/ /g;
  my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};

  my $key = $panName;
  my $subTrackAttr = $datasetProperties->{$dataset}->{subTrackAttr};

  my $cutoff = $datasetProperties->{$dataset}->{cutoff} || 0;
  
  my $colorFunction = $cutoff ? "colorSegmentByScore" : "chipColor";

  my $peaks = {storeClass => "JBrowse/Store/SeqFeature/REST",
                  baseUrl => "/a/service/jbrowse",
                  type => "JBrowse/View/Track/CanvasFeatures",
                  key => $key,
                  label => $key,
                  category => "Epigenomics",
                  style => {
                    color => "{$colorFunction}",
                  },
                  metadata => {
                    subcategory => "ChIP chip",
                    dataset => $datasetDisplayName,
                    trackType => 'Segments',
                    attribution => $shortAttribution,
                    description => $summary,
                   },
                   fmtMetaValue_Dataset => "function() { return datasetLink('${dataset}', '${datasetDisplayName}'); }",
                   fmtMetaValue_Description => "function() { return datasetDescription('${summary}', ''); }",
                  query => {'feature' => "ChIP:ChIPchip_peaksjbrowse",
                            'exp' => $dataset,
                            'sub' => $subTrackAttr,
                            'cutoff' => $cutoff,
                            'panId' => $panId,
                  },
               onClick => {
                 content => "{peakTitleChipSeqFxn}",
               },
               menuTemplate => [
                 {label => "View Details", 
                  content => "{peakTitleChipSeqFxn}",
                 },
                   ],
    };


  return $peaks;


}

sub addCnvArray {
  my ($dbh, $result) = @_;

  my $sql = "select distinct pan.name
from study.protocolappnode pan
   , study.study s
   , study.studylink sl
where pan.PROTOCOL_APP_NODE_ID = sl.PROTOCOL_APP_NODE_ID
and sl.study_id = s.study_id
and s.name like 'tcruCLBrenerEsmeraldo-like_cghArrayExper_Tarelton_GSE23576_CNV_RSRC%'
order by pan.name";
  my $sh = $dbh->prepare($sql);
  $sh->execute();

  my $desc = "Comparative Genomic Hybridization to determine regions of significant Copy Number Variation in <i>T. cruzi</i> strains with strain CL Brener as reference. Type I strains used include: Brazil, Chinata, Colombiana, M78, Montalvania, PalDa1 (clone 9), SylvioX10/4, TCC, TEDa2 (clone 4), TEP6 (clone 5). Type II-VI strains used include: Esmeraldo, M5631, Tu18 (clone 1), Tulahuen, wtCL, Y. Scores from Type I strain is shown in Green and from Type II-VI are show in Brown. Score value represents the number of strains showing CNV , with a postive score implying amplification and a negative score implying deletion with respect to CL Brener. CNV criteria: minimum log2 ratio of signal intensities (test strain/reference) +/- 0.6, minimum number of probes 5. For more details refer the following manuscript: <a href=\"http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3060142/\">Widespread, focal copy number variations (CNV) and whole chromosome aneuploidies in Trypanosoma cruzi strains revealed by array comparative genomic hybridization</a> ";

  while(my ($name) = $sh->fetchrow_array()) {


    my $cnv = {storeClass => "JBrowse/Store/SeqFeature/REST",
               baseUrl => "/a/service/jbrowse",
               type => "JBrowse/View/Track/Wiggle/XYPlot",
               key => $name,
               label => $name,
               category => "Genetic Variation",
               metadata => {
                 subcategory => "CGH Array",
                 dataset => "Comparative Genomic Hybridizations of 33 strains",
                 trackType => 'XYPlot',
                 description => $desc,
               },
               fmtMetaValue_Dataset => "function() { return datasetLink('tcruCLBrenerEsmeraldo-like_cghArrayPlatform_GPL10781_RSRC', 'Comparative Genomic Hybridizations of 33 strains'); }",
               fmtMetaValue_Description => "function() { return datasetDescription('${desc}', ''); }",
               query => {'feature' => "cnv:ArrayJBrowse",
                         'sample' => $name,
               },
               max_score => 3,
               min_score => -3,
               yScalePosition => "left"
    };
    push @{$result->{tracks}}, $cnv;

  }
  $sh->finish();
}

sub makeChipChipSmoothed {
  my ($dataset, $study, $panName, $panId, $datasetProperties) = @_;

  my $datasetDisplayName = $datasetProperties->{$dataset}->{datasetDisplayName};
  my $summary = $datasetProperties->{$dataset}->{summary};
  $summary =~ s/\n/ /g;
  my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};

#  my $datasetKey = $datasetProperties->{$dataset}->{key};
#  my $key = $datasetKey ? "${panName} ${datasetKey}" : $panName; # no longer valid??
  my $key = $panName;
  my $subTrackAttr = $datasetProperties->{$dataset}->{subTrackAttr};

  my $smoothed = {storeClass => "JBrowse/Store/SeqFeature/REST",
                  baseUrl => "/a/service/jbrowse",
                  type => "JBrowse/View/Track/Wiggle/XYPlot",
                  key => $key,
                  label => $key,
                  category => "Epigenomics",
                  style => {
                    pos_color => "{chipColor}",
                    neg_color => "{chipColor}",
                  },
                  metadata => {
                    subcategory => "ChIP chip",
                    dataset => $datasetDisplayName,
                    trackType => 'XYPlot',
                    attribution => $shortAttribution,
                    description => $summary,
                   },
                   fmtMetaValue_Dataset => "function() { return datasetLink('${dataset}', '${datasetDisplayName}'); }",
                   fmtMetaValue_Description => "function() { return datasetDescription('${summary}', ''); }",
                  query => {'feature' => "ChIP:ChIPchip_smoothedjbrowse",
                            'exp' => $dataset,
                            'sub' => $subTrackAttr,
                            'panId' => $panId
                  },
                  max_score => 3,
                  min_score => -3,
                  yScalePosition => "left"
    };


  return $smoothed;
}


1; 

package _Tree; 

use strict;

sub getName {$_[0]->{_name}}

sub setAlreadySeen {$_[0]->{_seen} = $_[1]}
sub getAlreadySeen {$_[0]->{_seen}}

sub setAbbrev {$_[0]->{_abbrev} = $_[1]}
sub getAbbrev {$_[0]->{_abbrev}}

sub setFeatureFilters {$_[0]->{_feature_filters} = $_[1]}
sub getFeatureFilters {$_[0]->{_feature_filters}}

sub setMetadata {$_[0]->{_metadata} = $_[1]}
sub getMetadata {$_[0]->{_metadata}}

sub getParent {$_[0]->{_parent}}

sub getChildren {$_[0]->{_children} || [] }

sub addChild {push @{$_[0]->{_children}}, $_[1]}

sub isLeaf {
  my ($self) = @_;
  my $children = $self->getChildren();
  return scalar @$children == 0;
}

sub isRoot {
  my ($self) = @_;
  return !defined($self->getParent());
}

sub new {
  my ($class, $args) = @_;

  return bless $args, $class;
}

1;
