#!/usr/bin/perl

use strict;
use lib $ENV{GUS_HOME} . "/lib/perl";
use JSON;
use ApiCommonModel::Model::JBrowseUtil;

use ApiCommonModel::Model::JBrowseTrackConfig::UnifiedMassSpecTrackConfig;
use ApiCommonModel::Model::JBrowseTrackConfig::UnifiedSnpTrackConfig;
use ApiCommonModel::Model::JBrowseTrackConfig::ScaffoldsTrackConfig;
use ApiCommonModel::Model::JBrowseTrackConfig::CentromereTrackConfig;
use ApiCommonModel::Model::JBrowseTrackConfig::TrnaTrackConfig;
use ApiCommonModel::Model::JBrowseTrackConfig::NrdbProteinTrackConfig;
use ApiCommonModel::Model::JBrowseTrackConfig::VCFStore;
use ApiCommonModel::Model::JBrowseTrackConfig::ChipChipSmoothedTrackConfig;
use ApiCommonModel::Model::JBrowseTrackConfig::BigWigStore;
use ApiCommonModel::Model::JBrowseTrackConfig::ChipChipPeakTrackConfig;
use ApiCommonModel::Model::JBrowseTrackConfig::CnvArrayTrackConfig;
use ApiCommonModel::Model::JBrowseTrackConfig::ProteinExpressionMassSpec;
use ApiCommonModel::Model::JBrowseTrackConfig::SmallNcRnaSeq;
use ApiCommonModel::Model::JBrowseTrackConfig::ApolloGffTrackConfig;
use ApiCommonModel::Model::JBrowseTrackConfig::VcfTrackConfig;

use Data::Dumper;

use URI::Escape;

use Storable 'dclone';
use Tie::IxHash;

my %datasets;
my $t = tie %datasets, 'Tie::IxHash';


my ($organismAbbrev, $projectName, $isApollo, $buildNumber, $applicationType) = @ARGV;

my $jbrowseUtil = ApiCommonModel::Model::JBrowseUtil->new({projectName => $projectName, organismAbbrev => $organismAbbrev, fileName => "_organismSpecificCache.json"});

my $buildProps = $jbrowseUtil->getBuildProperties();

#my $jbrowseUtil = ApiCommonModel::Model::JBrowseUtil->new({projectName => $projectName});

my $dbh = $jbrowseUtil->getDbh();   

my $result = {"tracks" => [] };

### Get organism properties
my $orgHash = ($buildProps->{'organism'});
my $nameForFileNames = ($orgHash->{organismNameForFiles});
my $projectName = ($orgHash->{projectName});
my $isAnnotated = ($orgHash->{isAnnotatedGenome});

#&addScaffolds($dbh, $result);
#&addCentromere($dbh, $result);
#&addUnifiedMassSpec($dbh, $result);
#&addUnifiedSnp($dbh, $result);

# TODO: Add back
# &addSynteny($dbh, $result);

&addDatasets($dbh, \%datasets) unless($isApollo);

# TODO: get these from buildProps
#my $datasetProperties = &datasetProperties($dbh);
my $datasetProperties = $buildProps;
#print Dumper ($datasetProperties);
#die;

#&addChipChipTracks($dbh, $result, $datasetProperties);
#&addSmallNcRnaSeq($dbh, $result, $datasetProperties);

# TODO: Add back
#&addProteinExpressionMassSpec($dbh, $result, $datasetProperties);
#&addVCF($dbh, $result, $datasetProperties);
#&addGFF($dbh, $result, $datasetProperties);

#&addTRNA($dbh, $result, $datasetProperties);
if ($projectName !~ m/HostDB/ && $organismAbbrev !~ m/cgloCBS148.51/ && $organismAbbrev !~ m/pgig/ && $organismAbbrev !~ m/amutUAMH3576/ && $organismAbbrev !~ m/anigUAMH3544/ && $organismAbbrev !~ m/bcerUAMH5669/){
#&addNrdbProteinAlignments($dbh, $result, $datasetProperties, $projectName);
}

if ($organismAbbrev !~ m/dmeliso-1/ ){
# TODO: Add back
#&addApolloGFF($dbh, $result);
}
#&addMergedRnaSeq($dbh, $result, $datasetProperties, $projectName);

# other organism specific tracks
if($organismAbbrev eq 'tcruCLBrenerEsmeraldo-like') {
# TODO: Add back
#&addCnvArray($dbh, $result);
}
# TODO: Add back
#if ($isAnnotated eq 'true'){
#    &addAnnotatedGenome($dbh, $result, $datasetProperties);
#}
#&addFastaAssemblyTrack($dbh, $result, $datasetProperties);

unless($isApollo) {
  $result->{datasets} = \%datasets;
  $result->{dataset_id} = $organismAbbrev;
}

print encode_json($result);
# TODO: make new method to add GFF
#sub addAnnotatedGenome {
#    my annotatedGffTrack;
#    my $gffUrl = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFileNames}/gff/annotated_transcripts.gff.gz");
#    my $annotatedGenomeTrack = ApiCommonModel::Model::JBrowseTrackConfig::AnnotatedGenomeTrackConfig->new({dataset_name => $dsName,
#                                                                                                url_template => $gffUrl,
#                                                                                                application_type => $applicationType,
#                                                                                                label => $label,
                                                                                                #strand =>  $strand,
#                                                                                                category => $category,
#                                                                                                subcategory => $subCategory,
#                                                                                                attribution => $shortAttribution,
#                                                                                                summary => $summary,
                                                                                                #alignment => $alignment,
#                                                                                                organism_abbrev => $organismAbbrev
#                                                                                              })->getConfigurationObject();
#}
# TODO: make new method to add FASTA
#sub addFastaAssemblyTrack{
#    my fastaAssembly;
#    my $fastaFile = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFileNames}/fasta/genome.fasta");
#}

sub addDatasets {
  my ($dbh) = @_;
  #Public facing track requires public_abbrev here!
  my $sql = "select public_abbrev, organism_name FROM APidbtuning.organismattributes order by organism_name";

  my $sh = $dbh->prepare($sql);
  $sh->execute();

  while(my ($abbrev, $name) = $sh->fetchrow_array()) {
    $datasets{$abbrev}->{name} = $name;
    $datasets{$abbrev}->{url} = "?data=/a/service/jbrowse/tracks/${abbrev}";
  }
  $sh->finish();
}

sub datasetProperties {
  my ($dbh) = @_;

#  my $sql = "select dsp.name, dsp.dataset_presenter_id, prop.property, prop.value, '' as extdbName
#from apidbtuning.datasetpresenter dsp
#   , apidbtuning.datasetproperty prop
#where dsp.name like '${organismAbbrev}%_chipChipExper%_RSRC'
#and dsp.dataset_presenter_id = prop.dataset_presenter_id
#UNION
#select dnt.name, dsp.dataset_presenter_id, prop.property, prop.value, dnt.name as extdbName
#from apidbtuning.datasetpresenter dsp
#   , apidbtuning.datasetproperty prop
#   , apidbtuning.datasetnametaxon dnt
#where dnt.name like '${organismAbbrev}%_ebi_VCF_RSRC'
#and dsp.dataset_presenter_id = prop.dataset_presenter_id
#and dsp.dataset_presenter_id = dnt.dataset_presenter_id
#UNION
#select dsp.name, dsp.dataset_presenter_id, prop.property, prop.value, '' as extdbName
#from apidbtuning.datasetpresenter dsp
#   , apidbtuning.datasetproperty prop
#where dsp.name like '${organismAbbrev}%_ebi_GFF3_RSRC'
#and dsp.dataset_presenter_id = prop.dataset_presenter_id
#UNION
#select dsp.name, dsp.dataset_presenter_id, prop.property, prop.value, '' as extdbName
#from apidbtuning.datasetpresenter dsp
#   , apidbtuning.datasetproperty prop
#where dsp.name like '${organismAbbrev}%_ebi_rnaSeq_RSRC'
#and dsp.dataset_presenter_id = prop.dataset_presenter_id
#UNION
#select dsp.name, dsp.dataset_presenter_id, prop.property, prop.value, '' as extdbName
#from apidbtuning.datasetpresenter dsp
#   , apidbtuning.datasetproperty prop
#where dsp.name like '${organismAbbrev}_smallNcRna_%_RSRC'
#and dsp.dataset_presenter_id = prop.dataset_presenter_id
#UNION
#select distinct dsp.name, dsp.dataset_presenter_id, prop.property, prop.value, dnt.name as extdbName
#from apidbtuning.datasetnametaxon dnt,
#     apidbtuning.datasetproperty prop,
#     apidbtuning.datasetpresenter dsp,
#     apidb.organism o
#where dnt.taxon_id = o.taxon_id
#and o.abbrev = '${organismAbbrev}'
#and dnt.name like '%_massSpec%_RSRC'
#and dnt.dataset_presenter_id = prop.dataset_presenter_id
#and prop.dataset_presenter_id = dsp.dataset_presenter_id
#";

#  my $sh = $dbh->prepare($sql);
#  $sh->execute();

#  my %datasetProperties;
#  while(my ($datasetName, $datasetPresenterId, $prop, $val, $extdbName) = $sh->fetchrow_array()) {
#    $datasetProperties{$datasetName}->{$prop} = $val;
#    $datasetProperties{$datasetName}->{datasetPresenterId} = $datasetPresenterId;
#    $datasetProperties{$datasetName}->{datasetExtdbName} = $extdbName;
#  }
#  $sh->finish();

#  return \%datasetProperties;
}

sub addVCF {
  my ($dbh, $result, $datasetProperties) = @_;

  my $vcfDatasets = $buildProps->{vcffile} ? $buildProps->{vcffile} : {};

  foreach my $dataset (keys %$vcfDatasets) {
    next unless($dataset =~ /VCF/);
    my $experimentName = $dataset =~ m/${organismAbbrev}_(.+)_ebi_VCF_RSRC/;
    my $datasetDisplayName = $vcfDatasets->{$dataset}->{datasetDisplayName};
    my $summary = $vcfDatasets->{$dataset}->{summary};
    
    $summary =~ s/\n/ /g;
    my $shortAttribution = $datasetProperties->{$dataset}->{shortAttribution};

    #my $sql = "select o.NAME_FOR_FILENAMES, ds.name from apidb.datasource ds, apidb.organism o where ds.taxon_id = o.taxon_id and ds.name like '$dataset'";
    #my $sh = $dbh->prepare($sql);
    #$sh->execute();
    


    #while(my ($nameForFileNames, $sampleDataset) = $sh->fetchrow_array()) {
      my $sampleName = $vcfDatasets->{$dataset}->{datasetName};
      my ($vcfFileName) = $sampleName =~ m/${organismAbbrev}_(.+)_ebi_VCF_RSRC/;
      my $keyName = $vcfFileName;
 	  $keyName =~ s/_/ /g;
	  $keyName =~ s/\./ /g;
      my $vcfUrl = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFileNames}/vcf/${sampleName}/${vcfFileName}.vcf.gz");
      my $alignment = ApiCommonModel::Model::JBrowseTrackConfig::VcfTrackConfig->new({
												dataset_name  => $dataset,
												study_display_name => $datasetDisplayName,
												description => $summary,
                                                                                                key => "$keyName SNPs from VCF",
                                                                                                label => "${sampleName} SNPs",
                                                                                                url_template => $vcfUrl,
                                                                                                application_type => $applicationType,
                                                                                                attribution => $shortAttribution,
                                                                                                summary => $summary,
                                                                                              })->getConfigurationObject();

      push @{$result->{tracks}}, $alignment;
  }
}

sub addApolloGFF {
    my ($dbh, $result) = @_;

  my $sql = "select count(*) from apidbtuning.ApolloId aid, apidbtuning.organismattributes oa where oa.public_abbrev='".$organismAbbrev."' and aid.organism = oa.organism_name";

  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $count = $sh->fetchrow_array();
  $sh->finish();
  if($count > 0) {

    my $apolloDescription = "Community annotation represents user provided effort to improve the current gene models and offer alternatives based on -omic level evidence. Users can utilise our Apollo instance for creating and editing functional annotation to be displayed in this track. Only when the status of the gene model is changed to 'Finished' will the model be displayed, normally within 24 hours of the status change.";

    my $track = ApiCommonModel::Model::JBrowseTrackConfig::ApolloGffTrackConfig->new({
                                                                                                application_type => $applicationType,
												summary => $apolloDescription,
                                                                                              })->getConfigurationObject();
    push @{$result->{tracks}}, $track;
  }
}

sub addMergedRnaSeq {
  my ($dbh, $result, $datasetProperties, $projectName) = @_;
  my @urlArray;
  my $genomeName;

  my $ebiRnaSeqDatasets = $buildProps->{ebirnaseq} ? $buildProps->{ebirnaseq} : {};
  foreach my $dataset (keys %$ebiRnaSeqDatasets) {
    next unless($dataset =~ /rnaSeq/);

my @urlArrayProject;
    my $experimentName = $dataset =~ m/${organismAbbrev}_(.+)_ebi_rnaSeq_RSRC/;
    my $datasetDisplayName = $ebiRnaSeqDatasets->{$dataset}->{datasetDisplayName};
    my $summary = $ebiRnaSeqDatasets->{$dataset}->{summary};
    $summary =~ s/\n/ /g;
    my $shortAttribution = $ebiRnaSeqDatasets->{$dataset}->{shortAttribution};
    my $keyName = $datasetDisplayName;
    my $sql = "select o.NAME_FOR_FILENAMES, ds.name from apidb.datasource ds, apidb.organism o where ds.taxon_id = o.taxon_id and ds.name like '$dataset'";
    my $sh = $dbh->prepare($sql);
    $sh->execute();

    while(my ($nameForFileNames, $sampleDataset) = $sh->fetchrow_array()) {
    $genomeName = ${nameForFileNames};
      my ($sampleName) = $sampleDataset;
      my ($bigwigFileName) = $sampleName =~ m/${organismAbbrev}_(.+)_ebi_rnaSeq_RSRC/;
      my $keyName = $bigwigFileName;
         $keyName =~ s/_/ /g;

        my $bigWigRelativePath = "/var/www/Common/apiSiteFilesMirror/webServices/${projectName}/build-${buildNumber}/${nameForFileNames}/bigwig/${sampleName}/mergedBigwigs/*";
        my @bigwigFiles = glob($bigWigRelativePath);
        my $shortAttribution = $ebiRnaSeqDatasets->{$dataset}->{shortAttribution};
        foreach(@bigwigFiles){
                my $bigwigPath = $_;
                my $bigwigName = (split '/', $bigwigPath)[-1];
                my $shortBigwigName = $bigwigName;
                my $shortBigwigName = substr($shortBigwigName,0, -3);
                my $bigwigUrl = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFileNames}/bigwig/${sampleName}/mergedBigwigs/${bigwigName}");
                my $template = { url=>${bigwigUrl}, name=> ${shortBigwigName}, color=> 'black' };
                push (@urlArray, $template);
                push (@urlArrayProject, $template);
                }
        ### Print out combinedRNAseq track for experiment
#        my $arrayLength = @urlArrayProject;
#
#    if ($arrayLength > 0){
#
#        my $alignment = {storeClass => "MultiBigWig/Store/SeqFeature/MultiBigWig",
#        urlTemplates =>
#        \@urlArrayProject
#        ,
#        showTooltips => "true",
#        key => "${datasetDisplayName} combined RNAseq plot",
#        label => "${datasetDisplayName} combined RNAseq plot",
#        type  => "MultiBigWig/View/Track/MultiWiggle/MultiXYPlot",
#        category => "Transcriptomics",
#        autoscale => "global",
#        style => {'height' => "100",
#        },
#                  metadata => {
#                    subcategory => "RNA-Seq",
#                    dataset => $datasetDisplayName,
#                    trackType => "Multi XY plot",
#                    attribution => $shortAttribution,
#                   },
#        fmtMetaValue_Dataset => "function() { return datasetLinkByDatasetName('${dataset}', '${datasetDisplayName}'); }",
#      };
#      push @{$result->{tracks}}, $alignment;
#   }
  }
 }
        ### Print out combinedRNAseq track for organism
        my $arrayLength = @urlArray;

    if ($arrayLength > 0){
        my $alignment = {storeClass => "MultiBigWig/Store/SeqFeature/MultiBigWig",
        urlTemplates =>
        \@urlArray
        ,
        showTooltips => "true",
        key => "${genomeName} combined RNAseq plot",
        label => "${genomeName} combined RNAseq plot",
        type  => "MultiBigWig/View/Track/MultiWiggle/MultiXYPlot",
        category => "Transcriptomics",
        autoscale => "local",
        yScalePosition => "left",
        style => {'height' => "40",
        },
                  metadata => {
                    subcategory => "RNA-Seq",
                    dataset => "Combined all RNA-Seq data for ${genomeName}",
                    trackType => "Multi XY plot",
                    alignment => "Unique", 
                   },
      };
      push @{$result->{tracks}}, $alignment;
  }
}


sub addProteinExpressionMassSpec {
  my ($dbh, $result, $datasetProperties) = @_;

  my $proteinExpressionMassSpecDatasets = $buildProps->{protexpmassspec} ? $buildProps->{protexpmassspec} : {};

  foreach my $dataset (keys %$proteinExpressionMassSpecDatasets) {
    next unless($dataset =~ /_massSpec_/);

    my $experimentName = $proteinExpressionMassSpecDatasets->{$dataset}->{name};
    my $datasetDisplayName = $proteinExpressionMassSpecDatasets->{$dataset}->{datasetDisplayName};
    my $datasetPresenterId = $proteinExpressionMassSpecDatasets->{$dataset}->{presenterId};
    my $category = $proteinExpressionMassSpecDatasets->{$dataset}->{datasetClassCategory};

    my $datasetExtdbName = $proteinExpressionMassSpecDatasets->{$dataset}->{datasetExtdbName};

    my $summary = $proteinExpressionMassSpecDatasets->{$dataset}->{summary};
    $summary =~ s/\n/ /g;
    my $shortAttribution = $proteinExpressionMassSpecDatasets->{$dataset}->{shortAttribution};

my $queryParams = {
                            'edName' => "like '${datasetExtdbName}'",
                            'feature' => "domain:MassSpecPeptide",
                                           };
    
    my $massSpec = ApiCommonModel::Model::JBrowseTrackConfig::ProteinExpressionMassSpec->new({
                                                                                                key => "${datasetDisplayName}  MS/MS Peptides  ${shortAttribution}",
                                                                                                label => "${dataset}",
                                                                                                dataset_name => $dataset,
                                                                                                attribution => $shortAttribution,
                                                                                                study_display_name => $datasetDisplayName,
                                                                                                summary => $summary,
                                                                                                application_type => $applicationType,
                                                                                                query_params => $queryParams,
                                                                                                dataset_presenter_id => $datasetPresenterId,
                                                                                              })->getConfigurationObject();

    push @{$result->{tracks}}, $massSpec;
  }
}

sub addSmallNcRnaSeq {
  #my ($dbh, $result, $datasetProperties) = @_;


my $smallNcRnaSeqDatasets = $buildProps->{smallncrnaseq} ? $buildProps->{smallncrnaseq} : {};

   my $smallNcRnaSeqDatasets = $buildProps->{smallncrnaseq} ? $buildProps->{smallncrnaseq} : {};
   foreach my $dataset (keys %$smallNcRnaSeqDatasets){

    next unless($dataset =~ /smallNcRna/);

    my $experimentName = $smallNcRnaSeqDatasets->{$dataset}->{experimentName};
    my $datasetDisplayName = $smallNcRnaSeqDatasets->{$dataset}->{datasetDisplayName};
    my $summary = $smallNcRnaSeqDatasets->{$dataset}->{summary};
    $summary =~ s/\n/ /g;
    my $shortAttribution = $smallNcRnaSeqDatasets->{$dataset}->{shortAttribution};

    my ($sampleName) = $dataset =~ /${organismAbbrev}_${experimentName}_(.+)_smallNcRnaSample_RSRC/;

    # Example: EhistolyticaHM1IMSS/bam/Singh_Small_RNA/Rahman/Rahman.bam
    my $bamUrl = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFileNames}/bam/$experimentName/${sampleName}/${sampleName}.bam");

    my $alignment = ApiCommonModel::Model::JBrowseTrackConfig::SmallNcRnaSeq->new({
                                                                                                dataset_name => $dataset,
                                                                                                attribution => $shortAttribution,
                                                                                                study_display_name => $datasetDisplayName,
                                                                                                description => $summary,
                                                                                                application_type => $applicationType,
                                                                                                summary => $summary,
                                                                                                url_template => $bamUrl,
                                                                                                label => "$sampleName Small Non-coding RNAs",
                                                                                                key => "$sampleName Small Non-coding RNAs",
                                                                                              })->getConfigurationObject();
      push @{$result->{tracks}}, $alignment;
  }
}


sub addCentromere {
  my ($dbh, $result) = @_;
  my $sql = "select count(*) from apidbtuning.organismattributes where hasCentromere = 1 and  internal_abbrev = '${organismAbbrev}'";

  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $count = $sh->fetchrow_array();
  $sh->finish();
  if($count > 0) {
     my $track = ApiCommonModel::Model::JBrowseTrackConfig::CentromereTrackConfig->new({application_type => $applicationType})->getConfigurationObject();
     push @{$result->{tracks}}, $track;
    };
}


sub addScaffolds {
  my ($dbh, $result) = @_;

  # TODO:  get rid of this sql
  my $sql = "select count(*) from dots.scaffoldgapfeature sgf, apidbtuning.genomicseqattributes sa, apidb.organism o where sa.na_sequence_id = sgf.na_sequence_id and o.taxon_id = sa.taxon_id and o.abbrev = '${organismAbbrev}'";


  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $count = $sh->fetchrow_array();
  $sh->finish();
  if($count > 0) {
      my $track = ApiCommonModel::Model::JBrowseTrackConfig::ScaffoldsTrackConfig->new({application_type => $applicationType})->getConfigurationObject();
      push @{$result->{tracks}}, $track;
  }
}


sub addSynteny {
  my ($dbh, $result) = @_;
  # Requires public_abbrev here!
  my $sql = "select otr.organism, oa.internal_abbrev as public_abbrev, otr.phylum, otr.genus, otr.species, otr.kingdom, otr.class, gt.gtracks
            from APIDBTUNING.ORGANISMSELECTTAXONRANK otr
               , APIDBTUNING.ORGANISMATTRIBUTES oa
               , (select * from APIDBTUNING.GBROWSETRACKSORGANISM where type = 'synteny' ) gt
            where oa.ORGANISM_NAME = otr.organism 
            and oa.IS_ANNOTATED_GENOME = 1
            and oa.PROJECT_ID in (select distinct name from core.projectinfo)
            and oa.ORGANISM_NAME = gt.organism (+)";

  my $hasSyntenyTracks = 0;

  my $orgGTracks;
  my %subtracks;
  my %defaults;

  my $taxonNamesToNode = {};
  my $rootNode = _Tree->new({_name => 'root'});
  my $refOrganism;


  my $sh = $dbh->prepare($sql);
  $sh->execute();
  while(my ($organism, $publicAbbrev, $phylum, $genus, $species, $kingdom, $class, $gTracks) = $sh->fetchrow_array()) {
    if($publicAbbrev eq $organismAbbrev) {
      $hasSyntenyTracks = 1;
      $gTracks =~ s/^.+Synteny\///;
      %defaults = map { $_ => 1 } split(/\+/, $gTracks);
      $refOrganism = $organism;
    }
    my $kingdomNode = &makeTreeNode('k_' . $rootNode, $kingdom, $taxonNamesToNode, $rootNode);
    my $phylumNode = &makeTreeNode('p_' . $kingdom, $phylum, $taxonNamesToNode, $kingdomNode);
    my $classNode = &makeTreeNode('c_'. $phylum, $class, $taxonNamesToNode, $phylumNode);
    my $genusNode = &makeTreeNode('g_'. $class, $genus, $taxonNamesToNode, $classNode);
    my $speciesNode = &makeTreeNode('s_'. $genus, $species, $taxonNamesToNode, $genusNode);
    my $strainNode = &makeTreeNode('', $organism, $taxonNamesToNode, $speciesNode);

    # stuff these things in the leaf nodes
    $strainNode->setAbbrev($publicAbbrev);
    $strainNode->setFeatureFilters({ "taxon" => $organism});
    $strainNode->setMetadata({"Kingdom" => $kingdom,
                              "Phylum" => $phylum,
                              "Class" => $class,
                              "Genus" => $genus,
                              "Species" => $species 
                             });
  }
  $sh->finish();

  if($hasSyntenyTracks) {
    my $subtracksAr = [];

    my $refOrganismNode = $taxonNamesToNode->{$refOrganism};

    &addSubtracks($subtracksAr, $refOrganismNode, $taxonNamesToNode, \%defaults, $organismAbbrev);

    my $syntenyTrack = {storeClass => "EbrcTracks/Store/SeqFeature/REST",
                        baseUrl => "/a/service/jbrowse",
                        type => "EbrcTracks/View/Track/Synteny",
                        transcriptType => "processed_transcript",
                        noncodingType => ["nc_transcript"],
                        glyph => "function(f){return f.get('syntype') === 'span' ? 'JBrowse/View/FeatureGlyph/Box' : 'JBrowse/View/FeatureGlyph/Gene'; }",
                        subParts => "CDS,UTR,five_prime_UTR,three_prime_UTR,nc_exon,pseudogenic_exon",
                        key => "Syntenic Sequences and Genes (Shaded by Orthology)",
                        label => "Syntenic Sequences and Genes (Shaded by Orthology)",
                        region_feature_densities => "function(){return false}",
                        category => "Comparative Genomics",
			unsafePopup => JSON::true,
                        geneGroupAttributeName => "orthomcl_name",
                        displayMode => "normal",

                        style => {
                          color => "{syntenyColorFxn}",
                          unprocessedTranscriptColor => "lightgrey",
                          utrColor => "grey",
#                          borderWidth => 4,
                          connectorThickness => "function(f){return f.get('syntype') === 'span' ? 3 : 1; }",
                          showLabels => "function(){return false}",
                          strandArrow => "function(f){return f.get('syntype') === 'span' ? false : true; }",
                          height => "function(f){return f.get('syntype') === 'span' ? 2 : 5; }",
#                          height => 5,
                          marginBottom => 0,
                       },
                        metadata => {
                          subcategory => "Orthology and Synteny",
                          trackType => 'Segments',
                        },
                        query => {'feature' => "gene:syntenyJBrowseScaled"
                        },
                        subtracks => $subtracksAr,
                        onClick => {
                          content => "{syntenyTitleFxn}",
                        },
                        menuTemplate => [
                          {label => "View Details", 
                           content => "{syntenyTitleFxn}",
                          },
                          {label => "View Gene or Sequence Page",
                           title => "function(track,f) { return f.get('syntype') == 'span' ? f.get('contig') : f.get('name'); }", 
                           iconClass => "dijitIconDatabase", 
                           action => "iframeDialog", 
                           url => "function(track,f) { return f.get('syntype') == 'span' ? '/a/app/record/genomic-sequence/' + f.get('contig') : '/a/app/record/gene/' + f.get('name') }"}
                            ],
    };
    
    push @{$result->{tracks}}, $syntenyTrack;


  }

}



sub addSubtracks {
  my ($subtracks, $node, $taxonNamesToNode, $defaults, $organismAbbrev) = @_;

  return if($node->getAlreadySeen());
  return if($node->isRoot());

  if($node->isLeaf()) {
    my $abbrev = $node->getAbbrev();

    foreach my $type ("gene", "span") {
      my $metadataClone = dclone $node->getMetadata();
      my $ffClone = dclone $node->getFeatureFilters();
      $ffClone->{syntype} = $type;

      my $label = "${abbrev}_${type}";

      my $visible = $abbrev eq $organismAbbrev || $defaults->{$label} ? 'true' : 'false';

      my $subtrack = {featureFilters => $ffClone,
                      metadata => $metadataClone,
                      label => "$abbrev $type",
                      visible => $visible
      };
      push @$subtracks, $subtrack;
    }
  }
  else {
    my $children = $node->getChildren();

    foreach my $child (@$children) {
      &addSubtracks($subtracks, $child, $taxonNamesToNode, $defaults, $organismAbbrev);
    }
  }

  $node->setAlreadySeen(1);

  my $parent = $node->getParent();
  
  &addSubtracks($subtracks, $parent, $taxonNamesToNode, $defaults, $organismAbbrev);
}

sub makeTreeNode {
  my ($prefix, $name, $taxonNamesToNode, $parentNode) = @_;

  my $key = $prefix . $name;

  my $node = $taxonNamesToNode->{$key};
  unless($node) {
    $node = _Tree->new({_parent => $parentNode, _name => $name});
    $parentNode->addChild($node);
  }
  
  $taxonNamesToNode->{$key} = $node;

  return $node;
}


sub addUnifiedSnp {
  my ($dbh, $result) = @_;

  my $sql = "select count(*) from apidbtuning.datasetpresenter where name like '${organismAbbrev}%HTS_SNP_%'";
  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $snpCount = $sh->fetchrow_array();
  $sh->finish();

  if($snpCount > 0) {

    my $desc ="The SNPs in this track are gathered from the high-throughput sequencing data of multiple strains and isolates. For more details on the methods used, go to the Data menu, choose Analysis Methods, and then scroll down to the Genetic Variation and SNP calling section. SNPs in this track are represented as colored diamonds, where dark blue = non-synonymous, light blue = synonymous, red = nonsense, and yellow = non-coding.";

    my $snpTrack = ApiCommonModel::Model::JBrowseTrackConfig::UnifiedSnpTrackConfig->new({application_type => $applicationType})->getConfigurationObject();

    push @{$result->{tracks}}, $snpTrack;

  };

}


sub addUnifiedMassSpec {
  my ($dbh, $result) = @_;

  my $sql = "select count(*) from apidbtuning.datasetpresenter where name like '${organismAbbrev}%massSpec%'";
  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $massSpecCount = $sh->fetchrow_array();
  $sh->finish();

  if($massSpecCount > 0) {

    my $unifiedMassSpecTrack = ApiCommonModel::Model::JBrowseTrackConfig::UnifiedMassSpecTrackConfig->new({application_type => $applicationType })->getConfigurationObject();

    push @{$result->{tracks}}, $unifiedMassSpecTrack;
   };
}


sub addChipChipTracks {
  my ($dbh, $result, $datasetProperties) = @_;

  my $chipChipSeqDatasets = $datasetProperties->{chipchipseq} ? $datasetProperties->{chipchipseq} : {};

 my $sql = "select d.name, s.name, pan.name, pan.protocol_app_node_id
from study.study s
   , SRES.EXTERNALDATABASERELEASE r
   , SRES.EXTERNALDATABASE d
   , study.protocolappnode pan
   , study.studylink sl
where d.name like '${organismAbbrev}%_chipChipExper_%'
and s.EXTERNAL_DATABASE_RELEASE_ID = r.EXTERNAL_DATABASE_RELEASE_ID
and r.EXTERNAL_DATABASE_ID = d.EXTERNAL_DATABASE_ID
and s.study_id = sl.study_id
and sl.protocol_app_node_id = pan.PROTOCOL_APP_NODE_ID
and s.investigation_id is null";


  my $sh = $dbh->prepare($sql);
  $sh->execute();

  while(my ($dataset, $study, $panName, $panId) = $sh->fetchrow_array()) {

    if($panName =~ /_peaks \(ChIP-chip\)/) {
        my $peakTrack = &makeChipChipPeak($dataset, $study, $panName, $panId, $datasetProperties, $chipChipSeqDatasets);
        push @{$result->{tracks}}, $peakTrack;
    }
    if($panName =~ /_smoothed \(ChIP-chip\)/) {
      my $track = &makeChipChipSmoothed($dataset, $study, $panName, $panId, $datasetProperties, $chipChipSeqDatasets);
      push @{$result->{tracks}}, $track;
    }
  }
 
  $sh->finish();
}


sub makeChipChipPeak {
  my ($dataset, $study, $panName, $panId, $datasetProperties, $chipChipSeqDatasets) = @_;
    
    my $datasetDisplayName = $chipChipSeqDatasets->{$dataset}->{datasetDisplayName};
    my $summary = $chipChipSeqDatasets->{$dataset}->{summary};
    $summary =~ s/\n/ /g;
    my $shortAttribution = $chipChipSeqDatasets->{$dataset}->{shortAttribution};
    my $datasetPresenterId = $chipChipSeqDatasets->{$dataset}->{presenterId};

  my $key = $panName;
  my $subTrackAttr = $chipChipSeqDatasets->{$dataset}->{subTrackAttr};
  my $cutoff = $datasetProperties->{$dataset}->{cutoff} || 0;
  my $colorFunction = $cutoff ? "colorSegmentByScore" : "chipColor";

  my $queryParams = {
                            'exp' => $dataset,
                            'sub' => $subTrackAttr,
                            'cutoff' => $cutoff,
                            'panId' => $panId,
                                           };

  my $peaks = ApiCommonModel::Model::JBrowseTrackConfig::ChipChipPeakTrackConfig->new({
                                                                                                dataset_name => $dataset,
                                                                                                attribution => $shortAttribution,
                                                                                                study_display_name => $datasetDisplayName,
                                                                                                description => $summary,
                                                                                                query_params => $queryParams,
                                                                                                application_type => $applicationType,
                                                                                                label => $key,
                                                                                                key => $key,
												pan_name => $panName,
												dataset_presenter_id => $datasetPresenterId,
												summary => $summary,
                                                                                              })->getConfigurationObject();
  return $peaks;
}


sub addCnvArray {
  my ($dbh, $result) = @_;

  my $sql = "select distinct pan.name
from study.protocolappnode pan
   , study.study s
   , study.studylink sl
where pan.PROTOCOL_APP_NODE_ID = sl.PROTOCOL_APP_NODE_ID
and sl.study_id = s.study_id
and s.name like 'tcruCLBrenerEsmeraldo-like_cghArrayExper_Tarelton_GSE23576_CNV_RSRC%'
order by pan.name";
  my $sh = $dbh->prepare($sql);
  $sh->execute();

  my $summary = "Comparative Genomic Hybridization to determine regions of significant Copy Number Variation in <i>T. cruzi</i> strains with strain CL Brener as reference. Type I strains used include: Brazil, Chinata, Colombiana, M78, Montalvania, PalDa1 (clone 9), SylvioX10/4, TCC, TEDa2 (clone 4), TEP6 (clone 5). Type II-VI strains used include: Esmeraldo, M5631, Tu18 (clone 1), Tulahuen, wtCL, Y. Scores from Type I strain is shown in Green and from Type II-VI are show in Brown. Score value represents the number of strains showing CNV , with a postive score implying amplification and a negative score implying deletion with respect to CL Brener. CNV criteria: minimum log2 ratio of signal intensities (test strain/reference) +/- 0.6, minimum number of probes 5. For more details refer the following manuscript: <a href=\"http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3060142/\">Widespread, focal copy number variations (CNV) and whole chromosome aneuploidies in Trypanosoma cruzi strains revealed by array comparative genomic hybridization</a> ";

  while(my ($dataset) = $sh->fetchrow_array()) {

    my $cnv = ApiCommonModel::Model::JBrowseTrackConfig::CnvArrayTrackConfig->new({
                                                                                                dataset_name => $dataset,
                                                                                                study_display_name => "Comparative Genomic Hybridizations of 33 strains",
                                                                                                description => $summary,
                                                                                                application_type => $applicationType,
                                                                                                name => $dataset,
                                                                                              })->getConfigurationObject();
    push @{$result->{tracks}}, $cnv;

  }
  $sh->finish();
}


sub makeChipChipSmoothed {
  my ($dataset, $study, $panName, $panId, $datasetProperties, $chipChipSeqDatasets) = @_;

    my $datasetDisplayName = $chipChipSeqDatasets->{$dataset}->{datasetDisplayName};
    my $summary = $chipChipSeqDatasets->{$dataset}->{summary};
    $summary =~ s/\n/ /g;
    my $shortAttribution = $chipChipSeqDatasets->{$dataset}->{shortAttribution};

    my $datasetKey = $datasetProperties->{$dataset}->{key};
    my $key = $panName;
    my $subTrackAttr = $chipChipSeqDatasets->{$dataset}->{subTrackAttr};

    my $queryParams = {
                            'exp' => $dataset,
                            'sub' => $subTrackAttr,
                            'panId' => $panId,
                                           };

    my $smoothed = ApiCommonModel::Model::JBrowseTrackConfig::ChipChipSmoothedTrackConfig->new({
                                                                                                dataset_name  => $dataset,
                                                                                                attribution => $shortAttribution,
                                                                                                study_display_name => $datasetDisplayName,
                                                                                                description => $summary,
                                                                                                query_params => $queryParams,
                                                                                                application_type => $applicationType,
                                                                                                pan_name => $panName,
                                                                                                cov_max_score_default => 3,
                                                                                                cov_min_score_default => 3,
                                                                                                label => $key,
                                                                                                key => $key,
												summary => $summary,
                                                                                              })->getConfigurationObject();
  
  return $smoothed;
}


sub addNrdbProteinAlignments {
  my ($dbh, $result, $datasetProperties, $projectName) = @_;

  my $proteinAlignTrack;
  my $gffUrl = "/a/service/jbrowse/store?data=" . uri_escape_utf8("${nameForFileNames}/nrProteinsToGenomeAlign/result.sorted.gff.gz");

    my $methodDescription = "<p>NCBI's non redundant collection of proteins (nr) was filtered for deflines matching the Genus of this sequence.  These proteins were aligned using <a href='https://www.ebi.ac.uk/about/vertebrate-genomics/software/exonerate'>exonerate</a>. (protein to genomic sequence)</p>";

    $proteinAlignTrack = ApiCommonModel::Model::JBrowseTrackConfig::NrdbProteinTrackConfig->new({url_template => $gffUrl,
                                                                                                 application_type => $applicationType,
                                                                                                 summary => $methodDescription,
                                                                                                })->getConfigurationObject();

    push @{$result->{tracks}}, $proteinAlignTrack;

}

sub addTRNA {
  my ($dbh, $result) = @_;

  my $sql = "select count(*) from dots.rnafeature rnaf, sres.ontologyterm ot
where ot.ontology_term_id = rnaf.sequence_ontology_id
and ot.name ='tRNA'";

  my $sh = $dbh->prepare($sql);
  $sh->execute();
  my $count = $sh->fetchrow_array();
  $sh->finish();
  if($count > 0) {

     my $track = ApiCommonModel::Model::JBrowseTrackConfig::TrnaTrackConfig->new({application_type => $applicationType })->getConfigurationObject();

     push @{$result->{tracks}}, $track;
  }
}



1;


package _Tree; 

use strict;

sub getName {$_[0]->{_name}}

sub setAlreadySeen {$_[0]->{_seen} = $_[1]}
sub getAlreadySeen {$_[0]->{_seen}}

sub setAbbrev {$_[0]->{_abbrev} = $_[1]}
sub getAbbrev {$_[0]->{_abbrev}}

sub setFeatureFilters {$_[0]->{_feature_filters} = $_[1]}
sub getFeatureFilters {$_[0]->{_feature_filters}}

sub setMetadata {$_[0]->{_metadata} = $_[1]}
sub getMetadata {$_[0]->{_metadata}}

sub getParent {$_[0]->{_parent}}

sub getChildren {$_[0]->{_children} || [] }

sub addChild {push @{$_[0]->{_children}}, $_[1]}

sub isLeaf {
  my ($self) = @_;
  my $children = $self->getChildren();
  return scalar @$children == 0;
}

sub isRoot {
  my ($self) = @_;
  return !defined($self->getParent());
}

sub new {
  my ($class, $args) = @_;

  return bless $args, $class;
}

1;
