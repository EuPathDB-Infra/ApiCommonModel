<wdkModel>

    <!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
    <!-- Legacy SNP / SNP Chip (PlasmoDB) table query -->
    <!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->

    <querySet name="SnpChipTables" queryType="table" isCacheable="false" includeProjects="PlasmoDB,EuPathDB,UniDB">

      <defaultTestParamValues includeProjects="PlasmoDB,UniDB">
         <paramValue name="source_id">Pf_01_000539044_barcode</paramValue>
         <paramValue name="project_id">PlasmoDB</paramValue>
      </defaultTestParamValues>

       <!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
       <!-- Strains for sequencing SNPs -->  
       <!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->

        <sqlQuery name="Strains" includeProjects="PlasmoDB,UniDB" 
              isCacheable="false">
            <column name="source_id" />
            <column name="project_id" />
            <column name="strain"/>
            <column name="allele"/>
            <column name="allele_gene_strand"/>
            <column name="phenotype"/>
            <column name="product"/>
            <sql>
            <![CDATA[
SELECT snp.source_id, 
       snp.project_id AS project_id,
       var.strain,
       CASE WHEN snp.gene_strand = 'reverse' THEN apidb.reverse_complement(var.allele) 
            WHEN snp.gene_source_id is null THEN ''
       ELSE var.allele 
       END as allele_gene_strand,
       var.allele, 
       var.product,
       'todo' as phenotype
FROM  
       results.SeqVariation var, ApidbTuning.SnpChipAttributes snp
WHERE var.snp_na_feature_id = snp.na_feature_id
             ]]>
           </sql>
        </sqlQuery>

        <sqlQuery name="StrainsWithMetaData" includeProjects="PlasmoDB,UniDB" 
              isCacheable="false">
            <column name="source_id" />
            <column name="project_id" />
            <column name="strain"/>
            <column name="allele"/>
            <column name="country"/>
            <column name="allele_gene_strand"/>
            <column name="product"/>
            <sql>
            <![CDATA[
 SELECT sa.source_id, 
       sa.project_id,
       var.strain,
       nvl(loc.value,'unknown') as country,
       CASE WHEN sa.gene_strand = 'reverse' THEN apidb.reverse_complement(var.allele) 
            WHEN sa.gene_source_id is null THEN ''
       ELSE var.allele 
       END as allele_gene_strand,
       var.allele,
       var.product, 
       so.name as sampleId
FROM  results.seqvariation var,
      ApidbTuning.SnpChipAttributes sa,
      (select PAN_Id,value from apidbtuning.InferredChars where property = 'geographic location') loc,
      (select name, output_pan_id from apidbtuning.SampleProcess sd ) so 
WHERE var.snp_na_feature_id = sa.na_feature_id
  AND var.allele in ('A','C','G','T')
  AND loc.PAN_Id(+) = var.Protocol_App_Node_Id
  and so.output_pan_id = var.protocol_app_node_id
             ]]>
        </sql>
      </sqlQuery>

       <!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
       <!-- Other SNPs at the same location - All NGS SNPs               -->  
       <!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->

        <sqlQuery name="OtherSNPs" includeProjects="PlasmoDB,UniDB" 
               isCacheable="false">
            <column name="source_id" />
            <column name="project_id" />
            <column name="other_snp_id"/>
            <column name="geographic_location"/>
            <column name="type"/>
            <column name="platform"/>
            <column name="major_allele"/>
            <column name="minor_allele"/>
            <column name="other_allele"/>
            <column name="num_strains"/>

            <sql>
            <![CDATA[
select source_id,snp_source_id as other_snp_id,'PlasmoDB' AS project_id,geographic_location, platform,type,total_strains as num_strains,
major_allele || ' ('||maj_freq||')' as major_allele,
CASE WHEN minor_allele is not null THEN 
   CASE WHEN other_allele is not null THEN minor_allele || ' ('||other_freq||')' ELSE minor_allele || ' ('||min_freq||')' END 
ELSE null END as minor_allele,
CASE WHEN other_allele is not null THEN other_allele || ' ('||min_freq||')' ELSE null END as other_allele
from (
select source_id,snp_source_id,geographic_location,platform,type,
substr(listagg(allele, ', ') within group (order by count_strains desc),1,1) as major_allele,
substr(listagg(allele, ', ') within group (order by count_strains desc),4,1) as minor_allele,
substr(listagg(allele, ', ') within group (order by count_strains desc),7,1) as other_allele,
sum(count_strains) as total_strains,
round((max(count_strains) / sum(count_strains)),2) as maj_freq,
round((min(count_strains) / sum(count_strains)),2) as min_freq,
round((median(count_strains) / sum(count_strains)),2) as other_freq
from (
select source_id,snp_source_id,platform,'snp-chip' as type,geographic_location,allele,product,count(*) as count_strains
from (
SELECT sa.source_id, sb.source_id as snp_source_id, sb.platform,'PlasmoDB' AS project_id,
       var.strain,
       var.allele, var.product, var.coverage,
        nvl(loc.value,'unknown') as geographic_location
FROM   results.SeqVariation var, apidbtuning.snpChipAttributes sa, apidbtuning.snpChipAttributes sb,
       (select PAN_Id,value from apidbtuning.InferredChars where property = 'geographic location') loc
WHERE sa.na_sequence_id = sb.na_sequence_id
  and sa.start_min = sb.start_min
  and sb.source_id != sa.source_id
and sb.na_feature_id = var.snp_na_feature_id
and var.allele in ('A','C','G','T')
and var.protocol_app_node_id = loc.pan_id(+) )
group by source_id,snp_source_id,geographic_location,platform,allele,product 
UNION
select source_id,snp_source_id,platform,'snp' as type,geographic_location,allele,product,count(*) as count_strains
from (
SELECT sa.source_id, sb.source_id as snp_source_id, 'HTS_SNP' as platform, 'PlasmoDB' AS project_id,
       var.strain,
       var.allele, var.product, var.coverage,
        nvl(loc.value,'unknown') as geographic_location
FROM   apidb.SequenceVariation var, apidbtuning.snpChipAttributes sa, apidbtuning.snpAttributes sb,
       (select PAN_Id,value from apidbtuning.InferredChars where property = 'geographic location') loc
WHERE sa.na_sequence_id = sb.na_sequence_id
  and sa.start_min = sb.location
  and sb.source_id != sa.source_id
and sb.na_sequence_id = var.ref_na_sequence_id
and var.location = sb.location
and var.protocol_app_node_id = loc.pan_id(+) )
group by source_id,snp_source_id,geographic_location,platform,allele,product )
group by source_id,snp_source_id,type,geographic_location,platform)
             ]]>
           </sql>

        </sqlQuery> 

               <!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
       <!-- country summary -->  
       <!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->

        <sqlQuery name="CountrySummary" includeProjects="PlasmoDB,UniDB" isCacheable="false">
            <column name="source_id"/>
            <column name="project_id"/>
            <column name="geographic_location"/>
            <column name="total_strains"/>
            <column name="major_allele"/>
            <column name="minor_allele"/>
            <column name="other_allele"/>
            <sql>
                <![CDATA[
select source_id,'PlasmoDB' AS project_id,geographic_location, total_strains,
major_allele || ' ('||maj_freq||')' as major_allele,
CASE WHEN minor_allele is not null THEN 
   CASE WHEN other_allele is not null THEN minor_allele || ' ('||other_freq||')' ELSE minor_allele || ' ('||min_freq||')' END 
ELSE null END as minor_allele,
CASE WHEN other_allele is not null THEN other_allele || ' ('||min_freq||')' ELSE null END as other_allele
from (
select source_id,geographic_location,
substr(listagg(allele, ', ') within group (order by count_strains desc),1,1) as major_allele,
substr(listagg(allele, ', ') within group (order by count_strains desc),4,1) as minor_allele,
substr(listagg(allele, ', ') within group (order by count_strains desc),7,1) as other_allele,
sum(count_strains) as total_strains,
round((max(count_strains) / sum(count_strains)),2) as maj_freq,
round((min(count_strains) / sum(count_strains)),2) as min_freq,
round((median(count_strains) / sum(count_strains)),2) as other_freq
from (
select source_id,geographic_location,allele,product,count(*) as count_strains
from (
SELECT sa.source_id, 'PlasmoDB' AS project_id,
       CASE WHEN var.strain = sa.reference_strain THEN var.strain||' (reference)' ELSE var.strain END as strain,
       var.allele, var.product, var.coverage,
        nvl(loc.value,'unknown') as geographic_location
FROM   results.SeqVariation var, apidbtuning.snpChipAttributes sa,
       (select PAN_Id,value from apidbtuning.InferredChars where property = 'geographic location') loc
WHERE sa.na_feature_id = var.snp_na_feature_id
and var.allele in ('A','C','G','T')
and var.protocol_app_node_id = loc.pan_id(+) )
group by source_id,geographic_location,allele,product )
group by source_id,geographic_location)
                ]]>
            </sql>
       </sqlQuery>       

    </querySet>
</wdkModel>
