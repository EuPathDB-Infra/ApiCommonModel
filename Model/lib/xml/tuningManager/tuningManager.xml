<?xml version="1.0" encoding="UTF-8"?>
<tuningConfig>

<!--


  <tuningTable name="GenePathway">
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="apidb.Pathway"/>
    <externalDependency name="apidb.PathwayNode"/>
    <externalDependency name="dots.AaSequenceEnzymeClass"/>
    <externalDependency name="sres.EnzymeClass"/>
    <sql>
      <![CDATA[
        create table GenePathway&1 nologging as
        with WildcardedPathwayNode
             as (select parent_id, replace(display_label, '-', '%') as display_label
                 from apidb.PathwayNode
                 where pathway_node_type_id = 1),
             WildcardedEnzymeClass
             as (select enzyme_class_id, replace(ec_number, '-', '%') as ec_number
                 from sres.EnzymeClass)
        select ga.source_id as gene_source_id, p.source_id as pathway_source_id, max(p.name) as pathway_name,
               cast (max(case
                           when ec.ec_number = pn.display_label
                                and ec.ec_number not like '%\%%' escape '\'  /* no (literal) percent sign in ec_number */
                             then 1
                           else 0
                         end) as number(1)) as exact_match
        from apidb.Pathway p, WildcardedPathwaynode pn, WildcardedEnzymeClass ec,
             dots.AaSequenceEnzymeClass asec, GeneAttributes ga
        where p.pathway_id = pn.parent_id
          and (ec.ec_number like pn.display_label
               or pn.display_label like ec.ec_number)
          and asec.enzyme_class_id = ec.enzyme_class_id
          and ga.aa_sequence_id  = asec.aa_sequence_id
        group by ga.source_id, p.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index GenePath_ix&1 on GenePathway&1(gene_source_id, exact_match, pathway_source_id, pathway_name)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>
-->

  <tuningTable name="ProjectTaxon" prefixEnabled="true">
    <comment>map taxon names to project_ids. to be used by the apidb.project_id function</comment>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="apidb.Organism"/>
    <sql>
      <![CDATA[
        create table &prefixProjectTaxon&1 nologging as
        with
          local_taxon /* a taxon found in this instance, either in dots.ExternalNaSequence or in apidb.Organism */
          as (  select distinct tn.name as taxon,
                       substr((tn.name), 1, instr(tn.name||' ', ' ') - 1) as first_word,
                       pi.name as project_id
                from dots.ExternalNaSequence ens, sres.TaxonName tn, core.ProjectInfo pi
                where ens.taxon_id = tn.taxon_id
                  and tn.name_class = 'scientific name' 
                  and ens.row_project_id = pi.project_id
              /* get names from apidb.Organism.family_name_for_files
                 (may not be necessary) */
              union
                select family_name_for_files as taxon,
                       substr((family_name_for_files), 1, instr(family_name_for_files||' ', ' ') - 1) as first_word,
                       project_name as project_id
                from apidb.Organism
                where family_name_for_files in (select name from sres.TaxonName)
                ),
          mononym /* a taxon name that's the first word of a local taxon */
          as (select distinct lower(lt.first_word) as taxon, lt.project_id
              from local_taxon lt, sres.TaxonName tn
              where lt.first_word = tn.name
                and tn.name_class = 'scientific name'),
          full_name /* the full name of a local taxon whose first name is not a taxon */
          as (select distinct lower(lt.taxon) as taxon, lt.project_id
              from local_taxon lt, sres.TaxonName tn
              where lt.taxon = tn.name
                and tn.name_class = 'scientific name'
                and lower(lt.first_word) not in (select taxon from mononym))
          select * from mononym
        union
          select * from full_name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index data_load_prjct_error&1 on &prefixProjectTaxon&1 (taxon)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index projtax_ix&1 on &prefixProjectTaxon&1 (taxon, project_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="OntologyLevels" prefixEnabled="true">
    <comment>the max and min depth of each ontology term in OntologyRelationship. Used by the GoTermSummary tuning table</comment>
    <externalDependency name="sres.OntologyRelationship"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        create table &prefixOntologyLevels&1 nologging as
        with is_a_links -- not closure, just real links
             as (select subject_term_id, object_term_id
                 from sres.OntologyRelationship rel, sres.OntologyTerm pred
                 where rel.predicate_term_id = pred.ontology_term_id
                   and pred.name = 'is_a'),
             roots -- terms with no parents
             as ( select object_term_id from is_a_links
                 minus
                  select subject_term_id from is_a_links),
             levels -- terms and all their depths, unaggregated
             as ( select object_term_id as ontology_term_id, 0 as depth from roots
                 union
                  select subject_term_id as ontology_term_id, level + 1 as depth
                  from is_a_links
                  start with object_term_id in (select object_term_id from roots)
                  connect by object_term_id = prior subject_term_id)
        select ontology_term_id, min(depth) as min_depth, max(depth) as max_depth
        from levels
        group by ontology_term_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index olev_termix&1 on OntologyLevels&1 (ontology_term_id, min_depth, max_depth)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="GoTermSummary" prefixEnabled="true">
    <comment>GoTermSummary: each row represents one GO term assignment to one gene.
         (Typically, a gene has multiple such assignments.) This is used for
          finding gene-GO mappings, such as for the gene-page GO table.
     </comment>
    <internalDependency name="OntologyLevels"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.GoAssociation"/>
    <externalDependency name="dots.GoAssociationInstance"/>
    <externalDependency name="dots.GoAssociationInstanceLoe"/>
    <externalDependency name="dots.GoAssocInstEvidCode"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="sres.OntologyRelationship"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        create table &prefixGoTermSummary&1 nologging as
        with root_term
             as (select ontology_term_id,
                        substr(decode(name, 'biological_process', 'Biological Process',
                                            'molecular_function', 'Molecular Function',
                                            'cellular_component', 'Cellular Component',
                                            name), 1, 20)
                          as ontology
                 from sres.OntologyTerm
                 where source_id in ('GO:0008150','GO:0003674','GO:0005575')),
             explicit_mapping
             as (select gf.source_id as gene_source_id, t.source_id as transcript_source_id, taf.aa_sequence_id,
                        decode(ga.is_not, 0, '', 1, 'not', ga.is_not) as is_not, substr(gt.source_id, 1, 25) as go_id,
                        gt.ontology_term_id as go_term_id, rt.ontology, substr(gt.name, 1, 250) AS go_term_name,
                        substr(gail.name, 1, 24) AS source, substr(gec.name, 1, 12) as evidence_code,
                        decode(gail.name, 'Interpro', 'InterPro predictions', 'Annotation Center')
                           as displayable_source
                 from dots.GeneFeature gf, dots.Transcript t, dots.TranslatedAaFeature taf, dots.GoAssociation ga,
                      sres.OntologyTerm gt, dots.GoAssociationInstance gai, dots.GoAssociationInstanceLoe gail,
                      dots.GoAssocInstEvidCode gaiec, sres.OntologyTerm gec, root_term rt
                 where t.parent_id = gf.na_feature_id
                   and t.na_feature_id = taf.na_feature_id
                   and taf.aa_sequence_id = ga.row_id
                   and ga.table_id = (select table_id
                                      from core.TableInfo
                                      where name = 'TranslatedAASequence')
                   and ga.go_term_id = gt.ontology_term_id
                   and ga.go_association_id = gai.go_association_id
                   and gai.go_assoc_inst_loe_id = gail.go_assoc_inst_loe_id
                   and gai.go_association_instance_id = gaiec.go_association_instance_id
                   and gaiec.go_evidence_code_id = gec.ontology_term_id
                   and gt.ancestor_term_id = rt.ontology_term_id(+))
        select em.gene_source_id, em.transcript_source_id, em.aa_sequence_id, em.is_not, em.go_id,
               em.go_term_id, em.ontology, em.go_term_name, em.source, em.evidence_code, em.displayable_source,
               cast (1 as number(1)) as is_leaf, ol.min_depth as depth
        from explicit_mapping em, OntologyLevels ol
             where em.go_term_id = ol.ontology_term_id(+)
        union
        select em.gene_source_id, em.transcript_source_id, em.aa_sequence_id, em.is_not,
               substr(ot.source_id, 1, 25) as go_id, ot.ontology_term_id as go_term_id, em.ontology,
               substr(ot.name, 1,250) as go_term_name, em.source, em.evidence_code, em.displayable_source,
               cast (1 as number(1)) as is_leaf, ol.min_depth as depth
        from explicit_mapping em, sres.OntologyRelationship orel, sres.OntologyTerm ot, OntologyLevels ol
        where em.go_term_id = orel.subject_term_id
          and orel.object_term_id = ot.ontology_term_id
          and ot.ontology_term_id = ol.ontology_term_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixGoTermSummary&1
        set is_leaf = 0
        where (aa_sequence_id, source, go_term_id)
              in (select gts.aa_sequence_id, gts.source, orel.object_term_id
                  from &prefixGoTermSummary&1 gts, sres.OntologyRelationship orel
                  where gts.go_term_id = orel.subject_term_id
                    and orel.subject_term_id != orel.object_term_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index GoTermSum_aaSeqId_idx&1 ON &prefixGoTermSummary&1 (aa_sequence_id, go_id, source, displayable_source)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

<!--
  <tuningTable name="DatasetExampleSourceId">
    <comment> Each row maps a dataset onto an ID for which the dataset contains data;
         each dataset gets one such row.
         Used in dataset record queries.
      </comment>
    <externalDependency name="apidb.Profile"/>
    <externalDependency name="apidb.ProfileSet"/>
    <externalDependency name="apidb.ProfileElement"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE DatasetExampleSourceId&1 NOLOGGING AS
with profiles as (
select p.source_id,
       d.name,
       row_number() over(partition by d.name
                         order by ga.chromosome_order_num, pe.value desc) as rn
from apidb.ProfileSet ps, apidb.Profile p, apidb.ProfileElement pe,
     sres.ExternalDatabase d, sres.ExternalDatabaseRelease r, GeneAttributes ga
where ps.profile_set_id = p.profile_set_id
and ps.external_database_release_id = r.external_database_release_id
and r.external_database_id = d.external_database_id
and p.profile_id = pe.profile_id
and pe.value is not null
and p.source_id = ga.source_id (+)
)
select p.source_id as example_source_id,
       p.name as dataset
from profiles p
where p.rn = 1
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="GeneWord">
    <comment> Each row maps a gene source_id to all words found in the gene's product field
         Used in the word enrichment analysis plugin
         The trick sql was cribbed and modified from: nuijten.blogspot.com/2011/08/splitting-comma-delimited-string-regexp.html
      </comment>
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
        create table GeneWord&1 nologging as
        select source_id, taxon_id,
               /* for each rn (1 - max_words_in_any_product), */
               /*    print the rn-th word. */
               /*    replace leading and trailing parens with empty string, eg (RIFN) becomes RIFN */
               substr(regexp_replace(regexp_substr (product, '[^ ,]+', 1, rn), '[\)\(]', ''), 1, 200) word
        from GeneAttributes
        cross
               /* create a table of integers 1 - n where n is the max number of words in any product */
        join (select rownum rn
              from (select max (regexp_count (product, '[ ,]')) + 1 mx
                    from GeneAttributes)
              connect by level <= mx
             )
        where regexp_substr (product, '[^, ]+', 1, rn) is not null
        order by source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index GeneWord_idx&1 ON GeneWord&1 (source_id)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="OrganismAttributes">
    <comment> Stores per-organism information. Used by the organism record, as well
         as by project_id(), the function that maps an organism to a project.
      </comment>
    <internalDependency name="TaxonSpecies"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="GeneId"/>
    <internalDependency name="IsolateAttributes"/>
    <internalDependency name="GoTermSummary"/>
    <internalDependency name="ChIPchipGene"/>
    <internalDependency name="TFBSGene"/>
    <internalDependency name="EstAlignmentGeneSummary"/>
    <internalDependency name="EstAttributes"/>
    <internalDependency name="GenomicSequenceAttributes"/>
    <externalDependency name="apidb.dataSource"/>
    <externalDependency name="sres.externalDatabase"/>
    <externalDependency name="sres.externalDatabaseRelease"/>
    <externalDependency name="apidb.Profile"/>
    <externalDependency name="apidb.ProfileSet"/>
    <externalDependency name="dots.similarity"/>
    <externalDependency name="dots.nasequence"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.nalocation"/>
    <externalDependency name="apidb.phylogeneticprofile"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="apidb.massspecsummary"/>
    <externalDependency name="dots.snpfeature"/>
    <intermediateTable name="DataSourceCount"/>
    <intermediateTable name="CommunityCount"/>
    <intermediateTable name="ProfileCount"/>
    <intermediateTable name="IsolateCount"/>
    <intermediateTable name="GeneCount"/>

    <sql>
      <![CDATA[
CREATE TABLE DataSourceCount nologging as ( 
        SELECT ds.taxon_id,
               max(case when ds.type = 'organellar_genome' 
                     then 1 
                     else 0 end) as isOrganellar,
               max(case when ds.type = 'isolates'
                         AND ds.subtype = 'HTS_SNP' 
                     then 1 
                     else 0 end) as hasHTSIsolate,
               max(case when ds.type = 'isolates'
                         AND ds.subtype = 'sequenceing_types' 
                     then 1 
                     else 0 end) as hasIsolate,      
               max(case when ds.type = 'epitope'
                     then 1 
                     else 0 end) as hasEpitope,     
               max(case when ds.type = 'transcript_expression'
                         AND ds.subtype = 'array'                       
                     then 1 
                     else 0 end) as hasArray                      
        FROM   apidb.DataSource ds
          group by ds.taxon_id
         )
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create table CommunityCount nologging as
       select taxon_id, count(*) as communityCount
       from GeneAttributes
       where (source_id, project_id)
              in (select distinct stable_id, project_name
                  from userlogins5.mappedComment@prodn.login_comment
                  where is_visible = 1
                    and comment_target_id = 'gene')
       group by taxon_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE ProfileCount nologging as (
        select ga.taxon_id,         
              count(distinct(case when lower(ps.name) like '%rt_pcr%' 
                                   and ga.is_deprecated = 0 
                                  then p.source_id
                                  else ''
                                   end)) as rtPCRCount,     
              count(distinct(case when lower(ds.name) like '%rna%' 
                                   and ga.is_deprecated = 0 
                                  then p.source_id
                                  else ''
                                   end)) as rnaSeqCount,
              count(distinct(case when ds.type = 'transcript_expression'
                                   and ds.subtype = 'array'
                                   and ga.is_deprecated = 0 
                                  then p.source_id
                                  else ''
                                   end)) as geneArrayCount
         from Apidb.DataSource ds
              inner join sres.externalDatabase ed on ds.name = ed.name
              inner join sres.externalDatabaseRelease edr on ed.external_database_id = edr.external_database_id
              inner join apidb.ProfileSet ps on ps.external_database_release_id =edr.external_database_release_id
              inner join apidb.Profile p on  ps.profile_set_id = p.profile_set_id       
              right outer join geneAttributes ga on ga.source_id = p.source_id
         group by ga.taxon_id
)
       
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE IsolateCount nologging as (    
        SELECT count(distinct gene.source_id) as isolateCount, sim.taxon_id
        FROM (
          (SELECT i.source_id, tn.taxon_id, nas.source_id as sequence_source_id
           FROM dots.similarity s,
                IsolateAttributes i,
                core.tableinfo t, dots.nasequence nas, sres.taxonname tn
           WHERE s.query_id = i.na_sequence_id
             AND nas.na_sequence_id = s.subject_id
             AND t.table_id = s.subject_table_id
             AND t.table_id = s.query_table_id
             AND t.name = 'ExternalNASequence'
             AND tn.taxon_id = nas.taxon_id
             AND tn.name_class = 'scientific name'
             AND s.pvalue_exp <= -10
           ) sim left join
           (SELECT i.source_id, seq.source_id as sequence_id
            FROM  dots.similarity s, IsolateAttributes i,
                  GeneAttributes g, 
                  core.tableinfo t, dots.nalocation l, dots.nasequence seq
            WHERE s.query_id = i.na_sequence_id
              AND s.subject_id = g.na_sequence_id
              AND t.table_id = s.subject_table_id
              AND t.table_id = s.query_table_id
              AND s.min_subject_start <=  l.end_max
              AND s.max_subject_end >= l.start_min
              AND l.na_feature_id = g.na_feature_id
              AND g.na_sequence_id = seq.na_sequence_id
              AND t.name = 'ExternalNASequence'
            ) gene
           on gene.source_id = sim.source_id and gene.sequence_id = sim.sequence_source_id)
         GROUP BY sim.taxon_id
)
       
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE GeneCount nologging as (    
select genomestat.taxon_id,
       genomestat.project_id,
       genomestat.database_version,
       genomestat.ncbi_tax_id,
       genomestat.Megabps,
       nvl(snpCount.ct,0) as snpCount,
       nvl(count(distinct ga.source_id),0) as geneCount,
       nvl(count(distinct case when ga.is_pseudo =1  then ga.source_id else '' end),0) as pseudoGeneCount,    
       nvl(count(distinct case when ga.gene_type ='protein coding' then ga.source_id else '' end),0) as codingGeneCount,
       nvl(count(distinct case when ga.gene_type ='protein coding' then '' else ga.source_id end),0) as otherGeneCount, 
       nvl(count (distinct (case when ga.is_deprecated = 0
                  then ccg.gene_source_id
                  else NULL 
                  end)),0) ChipChipGeneCount ,
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then pp.source_id
                  else NULL 
                  end)),0) orthologCount, 
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then gts.source_id
                  else NULL 
                  end)),0) goCount, 
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then tfbs.gene_source_id
                  else NULL 
                  end)),0) tfbsCount, 
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then mss.aa_sequence_id
                  else NULL 
                  end)),0) proteomicsCount, 
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then est.source_id
                  else NULL 
                  end)),0) estCount,
      nvl(count (distinct (case when (ga.is_deprecated = 0 and ec_numbers is not null)
                  then ga.source_id 
                  else NULL 
                  end)),0) ecNumberCount
        FROM   GeneAttributes ga
               left outer join apidb.phylogeneticprofile pp on ga.source_id = pp.source_id
               left outer join gotermsummary gts on ga.source_id = gts.source_id
               left outer join TFBSGene tfbs on ga.source_id = tfbs.gene_source_id
               left outer join apidb.MassSpecSummary mss on ga.aa_sequence_id = mss.aa_sequence_id
               left outer join chipchipgene ccg on ga.source_id = ccg.gene_source_id
               left outer join (SELECT distinct s.gene as source_id 
                                  FROM EstAlignmentGeneSummary s, EstAttributes e 
                                  WHERE s.est_gene_overlap_length >= 100 
                                    AND s.is_best_alignment in (1) 
                                    AND s.percent_est_bases_aligned >= 20  
                                    AND s.percent_identity >= 90  
                                    AND e.best_alignment_count <= 1 
                                    AND e.source_id = s.accession   
                                    GROUP by s.gene HAVING count(*) >= 1) est on ga.source_id = est.source_id
          right outer join
         ( SELECT  project_id, taxon_id,
                 max(database_version) as database_version,
                CASE WHEN ncbi_tax_id > 9000000000 THEN NULL
                     ELSE ncbi_tax_id
                END ncbi_tax_id, 
                to_char(sum(length)/1000000,'9999.99') as megabps 
         FROM   GenomicSequenceAttributes 
         WHERE  is_top_level = 1
         GROUP BY project_ID, taxon_id, ncbi_tax_id
       ) genomestat on genomestat.taxon_id = ga.taxon_id
        left outer join       
      (
       SELECT count(distinct ga.source_id) as ct, ga.taxon_id 
       FROM GeneAttributes ga, dots.snpfeature sf  
       WHERE sf.parent_id = ga.na_feature_id 
         AND ga.is_deprecated = 0 
       GROUP BY ga.taxon_id 
      ) snpCount on ga.taxon_id = snpCount.taxon_id
        group by genomestat.taxon_id,
                 genomestat.project_id,
                 genomestat.database_version,
                 genomestat.ncbi_tax_id,
                 genomestat.Megabps,
                 snpCount.ct
)
       
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE OrganismAttributes&1 NOLOGGING AS
SELECT oa.*, tn2.name as species, replace(oa.organism_name, tn2.name) as strain
FROM
(
SELECT o.project_name as project_id,
       o.public_abbrev as source_id,
       o.family_name_for_files,
       tn.name as organism_name,
       o.genome_source,
       /*o.strain_abbrev, */
       o.is_annotated_genome,
       o.is_reference_strain,
       o.is_family_representative,
       o.name_for_filenames,
       o.taxon_id as component_taxon_id,
       gc.database_version,
       gc.megabps as megabps,
       gc.ncbi_tax_id as ncbi_tax_id,
       gc.snpCount as snpCount,
       gc.geneCount as geneCount,
       gc.pseudoGeneCount as pseudoGeneCount,
       gc.codingGeneCount as codingGeneCount,
       gc.otherGeneCount as otherGeneCount,
       gc.ChipChipGeneCount as ChipChipGeneCount,
       gc.orthologCount as orthologCount,
       gc.goCount as goCount,    
       gc.tfbsCount as tfbsCount,
       gc.proteomicsCount as proteomicsCount,
       gc.estCount as estCount,
       gc.ecNumberCount as ecNumberCount,
       nvl(dsc.isOrganellar, 0) as isOrganellar,
       nvl(dsc.hasHTSIsolate, 0) as hasHTSIsolate, 
       nvl(dsc.hasIsolate, 0) as hasIsolate,
       nvl(dsc.hasEpitope, 0) as hasEpitope,
       nvl(dsc.hasArray, 0) as hasArray,
       nvl(cc.communityCount, 0) as communityCount,
       nvl(ic.isolateCount, 0) as isolateCount,
       nvl(pc.geneArrayCount, 0) as arrayGeneCount,
       nvl(pc.rnaSeqCount, 0) as rnaSeqCount,
       nvl(pc.rtPCRCount, 0) as rtPCRCount
FROM   apidb.Organism o,
       sres.TaxonName tn,
       DataSourceCount dsc,
       CommunityCount cc,
       GeneCount gc,
       isolateCount ic,
       profileCount pc
WHERE tn.taxon_id = o.taxon_id
  AND tn.name_class = 'scientific name' 
  AND o.taxon_id = dsc.taxon_id (+)
  AND o.taxon_id = cc.taxon_id (+)
  AND o.taxon_id = gc.taxon_id (+)
  AND o.taxon_id = ic.taxon_id (+)
  AND o.taxon_id = pc.taxon_id (+)
) oa,
  TaxonSpecies ts,
  sres.taxon t,
  sres.taxonname tn2
where oa.component_taxon_id = ts.taxon_id
and ts.species_taxon_id = t.taxon_id
and ts.species_taxon_id = tn2.taxon_id
and tn2.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Organism_sourceId_idx&1 ON OrganismAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>
-->

  <tuningTable name="PdbSimilarity">
    <comment> Each record maps a gene to a PDB structure. Used by the model to find
         genes that have a PDB structure and to find the PDB structures for a
         given gene.
      </comment>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.ExternalAaSequence"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE PdbSimilarity&1 NOLOGGING AS
SELECT gf.source_id, eas.source_id AS pdb_chain,
       substr(eas.description, 1, 100) AS pdb_title,
       substr(eas.source_id, 1,
              instr(eas.source_id, '_', -1) - 1)
         AS pdb_id,
       s.pvalue_mant, s.pvalue_exp, 
       SUBSTR(tn.name, 1, 100) AS taxon,
       ROUND( (s.number_identical / s.total_match_length) * 100)
         AS percent_identity,
       ROUND( (s.total_match_length / tas.length) * 100)
         AS percent_plasmo_coverage,
       s.score, eas.taxon_id as pdb_taxon_id, tas.taxon_id as gene_taxon_id
FROM dots.TranslatedAaFeature taf,
     dots.TranslatedAaSequence tas, core.TableInfo tas_ti,
     dots.Similarity s, core.TableInfo eas_ti,
     dots.ExternalAaSequence eas,
     sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
     sres.TaxonName tn, dots.Transcript t, dots.GeneFeature gf
WHERE taf.aa_sequence_id = tas.aa_sequence_id
  AND tas_ti.name = 'TranslatedAASequence'
  AND tas_ti.table_id = s.query_table_id
  AND s.query_id = tas.aa_sequence_id
  AND eas_ti.name = 'ExternalAASequence'
  AND eas_ti.table_id = s.subject_table_id
  AND s.subject_id = eas.aa_sequence_id
  AND tn.name_class = 'scientific name'
  AND eas.external_database_release_id
      = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ed.name in ('PDBProteinSequences_RSRC','PDB protein sequences')
  AND eas.taxon_id = tn.taxon_id
  AND t.na_feature_id = taf.na_feature_id
  AND gf.na_feature_id = t.parent_id
ORDER BY taf.source_id, eas.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index PdbSim_sourceId_ix&1
ON PdbSimilarity&1 (source_id, score DESC)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SequencePieceClosure" prefixEnabled="true">
    <comment>Extends dots.SequencePiece to handle multiple levels. Used in
         sequence-record queries and in other tuning tables, including
         GenomicSequenceAttributes, FeatureLocation, BlatAlignmentLocation,
         and SimilaritySpanLocation
     </comment>
    <externalDependency name="dots.SequencePiece"/>
    <sql>
      <![CDATA[
        create table &prefixSequencePieceClosure&1 nologging as
        select sp.sequence_piece_id,
               sp.virtual_na_sequence_id,
               sp.piece_na_sequence_id, 
               sp.sequence_order, 
               sp.distance_from_left,
               sp.uncertainty,
               sp.strand_orientation,
               sp.start_position,
               sp.end_position, 
               sp.modification_date,
               1 as edge_level
        from dots.SequencePiece sp, dots.NaSequence ns
        where sp.piece_na_sequence_id = ns.na_sequence_id
          and (ns.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        /* known issue: this should be run not just once, but iteratively
           until it doesn't create new records.  Currently (7/2008),
           SequencePieces aren't nested even once. */
        insert into &prefixSequencePieceClosure&1
                    (edge_level, virtual_na_sequence_id, piece_na_sequence_id,
                     distance_from_left, strand_orientation, modification_date, 
                     start_position, end_position, sequence_order, sequence_piece_id)
        select 2, higher.virtual_na_sequence_id, lower.piece_na_sequence_id,
               higher.distance_from_left,
               case
                 when nvl(higher.strand_orientation, '+') = nvl(lower.strand_orientation, '+')
                 then '+'
                 else '-'
               end as strand_orientation,
               sysdate,
               higher.start_position - lower.distance_from_left, 
               higher.end_position - lower.distance_from_left, 
               higher.sequence_order,
               dots.sequencepiece_sq.nextval
        from &prefixSequencePieceClosure&1 higher, &prefixSequencePieceClosure&1 lower
        where higher.piece_na_sequence_id = lower.virtual_na_sequence_id
         and higher.start_position >= lower.start_position + lower.distance_from_left
         and higher.end_position <= lower.end_position + lower.distance_from_left
      ]]>
    </sql>
  </tuningTable>



  <tuningTable name="FeatureLocation" prefixEnabled="true">
    <comment>Addresses a performance problem with feature location queries, namely
         that the sequence and the location on that sequence are in different
         tables, so it's impossible to create an index on the whole shebang.
         Used by both model and GBrowse queries, as well as inputs to a
         dozen-odd other tuning tables.
     </comment>
    <internalDependency name="SequencePieceClosure"/>
    <internalDependency name="GenomicSequenceAttributes"/>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="dots.ExonFeature"/>
    <externalDependency name="dots.NaFeature"/>
    <externalDependency name="dots.NaLocation"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
create table &prefixFeatureLocation&1 NOLOGGING as
    with project_mapping AS
       (select distinct tn.name AS organism,  pi.name as project
        from sres.TaxonName tn, dots.NaSequence na, 
        core.ProjectInfo pi
        where tn.name_class = 'scientific name'
          and tn.taxon_id = na.taxon_id
          and na.row_project_id = pi.project_id
          )
select case
         when nf.subclass_view = 'GeneFeature'
              and nf.is_predicted = 1
           then 'GenePrediction'
         when nf.subclass_view = 'Miscellaneous' 
              and nf.is_predicted = 1
           then 'Prediction'
         else nf.subclass_view
       end as feature_type,
       nf.source_id as feature_source_id, ns.source_id as sequence_source_id,
       nf.na_sequence_id, nf.na_feature_id,
       least(nl.start_min, nl.end_max) as start_min,
       greatest(nl.start_min, nl.end_max) as end_max,
       nl.is_reversed, nf.parent_id, nf.sequence_ontology_id,
       cast (null as number) as is_top_level, ef.coding_start, ef.coding_end,
       nf.external_database_release_id,
       (select project from project_mapping where organism = tn.name) as project_id
from dots.NaFeature nf, dots.NaLocation nl, &prefixGenomicSequenceAttributes ns,
     dots.ExonFeature ef, sres.TaxonName tn
where nf.na_feature_id = nl.na_feature_id
  and nf.na_sequence_id = ns.na_sequence_id
  and nl.na_feature_id = ef.na_feature_id(+)
  and ns.taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
  and (ns.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
union
select /* virtual feature locations mapped through SequencePiece */
       case
         when nf.subclass_view = 'GeneFeature'
              and nf.is_predicted = 1
           then 'GenePrediction'
         else nf.subclass_view
       end as feature_type,
       nf.source_id as feature_source_id, scaffold.source_id as sequence_source_id,
       sp.virtual_na_sequence_id, nf.na_feature_id,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - greatest(nl.start_min, nl.start_max, nl.end_min, nl.end_max)  + 1
           else sp.distance_from_left + least(nl.start_min, nl.start_max, nl.end_min, nl.end_max) - sp.start_position  + 1
       end as start_min,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - least(nl.start_min, nl.start_max, nl.end_min, nl.end_max) + 1
         else sp.distance_from_left + greatest(nl.start_min, nl.start_max, nl.end_min, nl.end_max) - sp.start_position + 1
       end as end_max,
       case
         when sp.strand_orientation in ('-', '-1')
         then decode(nvl(nl.is_reversed, 0),
                     0, 1,  1, 0,  1)
         else nl.is_reversed
       end as is_reversed,
       nf.parent_id, nf.sequence_ontology_id,
       cast (null as number) as is_top_level,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - coding_start + 1
           else sp.distance_from_left + ef.coding_start - sp.start_position + 1
       end as coding_start,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - coding_end + 1
         else sp.distance_from_left + coding_end - sp.start_position + 1
       end as coding_end, nf.external_database_release_id,
       (select project from project_mapping where organism = tn.name) as project_id
from dots.NaFeature nf, dots.NaLocation nl, &prefixGenomicSequenceAttributes contig,
     &prefixSequencePieceClosure sp, &prefixGenomicSequenceAttributes scaffold, dots.ExonFeature ef,
     sres.TaxonName tn
where nf.na_feature_id = nl.na_feature_id
  and nf.na_sequence_id = contig.na_sequence_id
  and nf.na_sequence_id = sp.piece_na_sequence_id
  and sp.start_position <= nl.start_min
  and sp.end_position >= nl.end_max
  and sp.virtual_na_sequence_id = scaffold.na_sequence_id
  and nl.na_feature_id = ef.na_feature_id(+)
  and contig.taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
  and (contig.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
      ]]>
    </sql>
    <sql>
      <![CDATA[
update &prefixFeatureLocation&1
set is_top_level = 1
      ]]>
    </sql>
    <sql>
      <![CDATA[
update &prefixFeatureLocation&1 fl
set is_top_level = 0 
where na_sequence_id in (select distinct piece_na_sequence_id 
                         from &prefixSequencePieceClosure spc
                         where fl.start_min >= spc.start_position
                         and fl.end_max <= spc.end_position)
      ]]>
    </sql>
    <sql>
      <![CDATA[
commit
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc_ix&1 on &prefixFeatureLocation&1
             (feature_type, na_sequence_id, start_min, end_max, is_reversed, feature_source_id, na_feature_id,external_database_release_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc2_ix&1 on &prefixFeatureLocation&1
             (na_sequence_id, start_min, end_max, is_reversed, sequence_ontology_id, na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc3_ix&1 on &prefixFeatureLocation&1
             (na_feature_id, na_sequence_id, is_top_level)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc4_ix&1 on &prefixFeatureLocation&1
             (feature_type, is_top_level, sequence_ontology_id, na_feature_id, feature_source_id, na_sequence_id, start_min , end_max)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc5_ix&1
on &prefixFeatureLocation&1 
(na_sequence_id, feature_type, start_min, end_max, parent_id, na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc6_ix&1 on &prefixFeatureLocation&1 (feature_source_id, is_top_level, na_sequence_id, is_reversed)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc7_ix&1 on &prefixFeatureLocation&1
             (feature_type, sequence_source_id, start_min, is_reversed, end_max, feature_source_id, na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc_parent_ix&1 on &prefixFeatureLocation&1
             (parent_id, na_feature_id, is_reversed, coding_start, coding_end, na_sequence_id, feature_type)
tablespace indx
      ]]>
    </sql>
  </tuningTable>
  <tuningTable name="GeneId" prefixEnabled="true">
  <comment>GeneId maps any valid ID for a gene onto its official ID. These two quantities
       are stored in the "id" and "gene" columns, respectively. The "unique_mapping"
       column is set to 1 for IDs which map to only one gene.

       Most of the CREATE TABLE statement is made up of the union of nine subqueries,
       each of which looks in a different place for gene IDs. Each subquery populates
       the "union_member" field with a different literal string, to make it easier to
       understand which part (or parts) of the SQL is responsible for each ID-to-gene
       mapping.
   </comment>
    <internalDependency name="FeatureLocation"/>
    <externalDependency name="apidb.GeneFeatureName"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.NaFeatureNaGene"/>
    <externalDependency name="dots.NaGene"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <intermediateTable name="CommentAssignment"/>
    <intermediateTable name="NewCsi"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixGeneId&1 NOLOGGING AS
SELECT substr(mapping.id, 1, 100) as id, mapping.gene, cast (null as NUMBER) as unique_mapping,
       SUBSTR(apidb.tab_to_string(set(CAST(COLLECT(union_member order by union_member) AS apidb.varchartab)),'; '), 1, 100) as union_member, 
       SUBSTR(apidb.tab_to_string(set(CAST(COLLECT(database_name order by database_name) AS apidb.varchartab)),'; '), 1, 200) as database_name
/*   we would use listagg() as follows, but it repeats duplicate values, and doesn't provide a way to aggregate DISTINCT values. (lame!)
         substr(listagg(union_member, '; ') within group (order by union_member), 1, 100) as union_member,
         substr(listagg(database_name, '; ') within group (order by database_name), 1, 200) as database_name */
FROM (SELECT substr(t.protein_id, 1, instr(t.protein_id, '.') - 1) AS id,
             gf.source_id AS gene,
             'Transcript.protein_id before dot' as union_member, ed.name as database_name /* dots.Transcript.protein_id, trimmed at period */
      FROM dots.Transcript t, dots.GeneFeature gf,
           sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      WHERE t.parent_id = gf.na_feature_id
        AND substr(t.protein_id, 1, instr(t.protein_id, '.') - 1) IS NOT NULL
        AND gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT t.protein_id AS id,
             gf.source_id AS gene,
             'Transcript.protein_id' as union_member, ed.name as database_name /* dots.Transcript.protein_id */
      FROM dots.Transcript t, dots.GeneFeature gf,
           sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      WHERE t.parent_id = gf.na_feature_id
        AND t.protein_id IS NOT NULL
        AND gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT dr.primary_identifier AS id, 
             gf.source_id AS gene,
             'DbRef.primary_identifier' as union_member, ed.name as database_name /* sres.DbRef.primary_identifier */
      FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
           sres.ExternalDatabase ed
      WHERE dr.primary_identifier IS NOT NULL
        AND gf.na_feature_id = drnf.na_feature_id
        AND drnf.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
              = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND  NOT (ed.name in ('NRDB_gb_dbXRefBySeqIdentity','NRDB_ref_dbXRefBySeqIdentity')  
                                  AND NOT  REGEXP_LIKE (dr.primary_identifier, '\D') )
        AND  NOT edr.id_type = 'synonym'
     UNION
     SELECT dr.primary_identifier AS id, 
             gf.source_id AS gene,
             'synonym' as union_member, ed.name as database_name
      FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
           sres.ExternalDatabase ed
      WHERE dr.primary_identifier IS NOT NULL
        AND gf.na_feature_id = drnf.na_feature_id
        AND drnf.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND edr.id_type  = 'synonym'
     UNION
      SELECT dr.secondary_identifier AS id, 
             gf.source_id AS gene,
             'DbRef.secondary_identifier' as union_member, ed.name as database_name /* sres.DbRef.secondary_identifier */
      FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
           sres.ExternalDatabase ed
      WHERE dr.secondary_identifier IS NOT NULL
        AND gf.na_feature_id = drnf.na_feature_id
        AND drnf.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
              = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND ed.name IN ('NRDB_gb_dbXRefBySeqIdentity',
                        'NRDB_pdb_dbXRefBySeqIdentity',
                        'NRDB_ref_dbXRefBySeqIdentity',
                        'NRDB_sp_dbXRefBySeqIdentity',
                        'Predicted protein structures','Pf_predictedProteinStructures_RSRC',
                        'GenBank')
     UNION
      SELECT dr.primary_identifier AS id, 
             gf.source_id AS gene,
             'genbank DbRef.primary_identifier' as union_member, ed.name as database_name /* sres.DbRef.primary_identifier for Genbank records */
      FROM dots.GeneFeature gf, dots.Transcript t, dots.DbRefNaSequence drns,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
            sres.ExternalDatabase ed
      WHERE gf.na_feature_id = t.parent_id
        AND t.na_sequence_id = drns.na_sequence_id
        AND drns.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND ed.name = 'GenBank'
     UNION
      SELECT pred_loc.feature_source_id AS id,
             gene_loc.feature_source_id AS gene,
             'overlapping predicted gene source_id' as union_member, ed.name as database_name /* dots.GeneFeature.source_id for predicted genes that overlap */
      FROM &prefixFeatureLocation gene_loc, &prefixFeatureLocation pred_loc,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      WHERE pred_loc.feature_type = 'GenePrediction'
        AND gene_loc.feature_type = 'GeneFeature'
        AND pred_loc.na_sequence_id = gene_loc.na_sequence_id
        AND gene_loc.start_min <= pred_loc.end_max
        AND gene_loc.end_max >= pred_loc.start_min
        AND pred_loc.is_reversed = gene_loc.is_reversed
        AND pred_loc.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT ng.name AS id, gf.source_id AS gene,
             'NaGene' as union_member, ed.name as database_name /* dots.NaGene.name */
      FROM dots.GeneFeature gf, dots.NaFeatureNaGene nfng, dots.NaGene ng,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      WHERE gf.na_feature_id = nfng.na_feature_id
        AND ng.na_gene_id = nfng.na_gene_id
        AND gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT source_id AS id, source_id AS gene,
             'same ID' as union_member, ed.name as database_name /* same ID (reflexive mapping) */
      FROM dots.GeneFeature gf,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      WHERE gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT n.name AS id, gf.source_id AS gene,
             'gene name' as union_member, d.name as database_name /* apidb.GeneFeatureName.name */
      from apidb.GeneFeatureName n, dots.genefeature gf, sres.ExternalDatabaseRelease r, sres.ExternalDatabase d
      where n.na_feature_id = gf.na_feature_id
        and gf.external_database_release_id =r.external_database_release_id
        and r.external_database_id = d.external_database_id
        and n.is_preferred = 1) mapping,
      dots.GeneFeature gf, dots.NaSequence ns
where mapping.gene = gf.source_id
  and gf.na_sequence_id = ns.na_sequence_id
  and (ns.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
  and (gf.is_predicted != 1 OR gf.is_predicted is null)
group by mapping.id, mapping.gene
      ]]>
    </sql>
    <sql>
      <![CDATA[
update &prefixGeneId&1
set unique_mapping = 1
where lower(id) in (select lower_id
                    from (select distinct lower(id) as lower_id, gene
                          from &prefixGeneId&1) case_independent_mapping
                    group by lower_id
                    having count(*) = 1)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_gene_idx&1 ON &prefixGeneId&1 (gene, id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_id_idx&1 ON &prefixGeneId&1 (id, gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_uniqid_idx&1 ON &prefixGeneId&1 (unique_mapping, id, gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_lowid_idx&1 ON &prefixGeneId&1 (lower(id), gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_uniqlowid_idx&1 ON &prefixGeneId&1 (unique_mapping, lower(id), gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE &prefixCommentAssignment NOLOGGING AS
WITH projects AS
       (SELECT DISTINCT project_id FROM &prefixFeatureLocation), 
     project_comments AS
       (SELECT stable_id, comment_id
        FROM userlogins5.comments@&dblink
        WHERE project_name in (select project_id FROM projects)
          AND comment_target_id = 'gene')
  SELECT stable_id, comment_id
  FROM project_comments
UNION
  SELECT csi.stable_id, csi.comment_id
  FROM project_comments pc, userlogins5.commentStableId@&dblink csi
  WHERE csi.comment_id = pc.comment_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE &prefixNewCsi nologging as
SELECT stable_id, comment_id, userlogins5.CommentStableId_pkseq.nextval@&dblink as comment_stable_id
FROM (  SELECT gi.gene AS stable_id, ca.comment_id
        FROM &prefixGeneId&1 gi, &prefixCommentAssignment ca
        WHERE gi.id = ca.stable_id
          AND gi.id != gi.gene
      MINUS
        SELECT stable_id, comment_id
        FROM &prefixCommentAssignment ca)
      ]]>
    </sql>
    <sql>
      <![CDATA[
INSERT INTO userlogins5.CommentStableId@&dblink
           (stable_id, comment_id, comment_stable_id)
SELECT stable_id, comment_id, comment_stable_id
FROM &prefixNewCsi
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GenomicSequenceId">
  <comment> This table maps IDs for a sequence onto the official ID of the sequence.
       It is analogous to GeneId, which does the same thing for genes. Used by
       genomic-sequence record queries, by the sequence retrieval tool, and by
       the BasketFixer, which updates users' baskets at release time to replace
       old IDs with updated ones.
    </comment>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
CREATE TABLE GenomicSequenceId&1 NOLOGGING AS
SELECT DISTINCT substr(id, 1, 60) as id, substr(sequence, 1, 60) AS sequence
FROM (
  SELECT ns.source_id as id, ns.source_id as sequence
  FROM dots.NaSequence ns, sres.OntologyTerm oterm
  WHERE ns.sequence_ontology_id = oterm.ontology_term_id
    AND oterm.name in ('random_sequence', 'contig', 'supercontig', 'chromosome','mitochondrial_chromosome','plastid_sequence','cloned_genomic','apicoplast_chromosome')
UNION
  SELECT dr.primary_identifier AS id, ns.source_id AS sequence
  FROM dots.NaSequence ns, dots.DbRefNaSequence drnf,
       sres.DbRef dr, sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase ed
  WHERE dr.primary_identifier IS NOT NULL
    AND ns.na_sequence_id = drnf.na_sequence_id
    AND drnf.db_ref_id = dr.db_ref_id
    AND dr.external_database_release_id
          = edr.external_database_release_id
    AND edr.external_database_id = ed.external_database_id
)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GenSeqId_sequence_idx&1 ON GenomicSequenceId&1 (sequence, id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GenSeqId_id_idx&1 ON GenomicSequenceId&1 (id, sequence)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GenSeqId_lowid_idx&1 ON GenomicSequenceId&1 (lower(id), sequence)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EpitopeSummary">
    <comment> Used by GeneTables.Epitopes to map a gene to its epitopes.
     </comment>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.EpitopeFeature"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.MotifAaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE EpitopeSummary&1 NOLOGGING AS
SELECT gf.source_id, 
              al.start_min||'-'||al.end_max AS location,
              ef.source_id as iedb_id,
       mas.sequence, 
       SUBSTR(tn.name, 1, 100) AS name,
       DECODE(ef.type, 'Not Full Set Not on Blast Hit', 'Low',
                       'Not Full Set On Blast Hit', 'Medium',
                       'Full Set Not on Blast Hit', 'Medium',
                       'Full Set On Blast Hit', 'High',
                       'unknown epitope type') AS confidence
FROM dots.GeneFeature gf, 
     dots.Transcript t,
     dots.TranslatedAaFeature taf, 
     dots.MotifAaSequence mas,
     dots.TranslatedAaSequence tas, 
     dots.EpitopeFeature ef,
     dots.AaLocation al, 
     sres.TaxonName tn
WHERE t.parent_id = gf.na_feature_id
  AND taf.na_feature_id = t.na_feature_id
  AND taf.aa_sequence_id = tas.aa_sequence_id
  AND tas.aa_sequence_id = ef.aa_sequence_id
  AND ef.aa_feature_id = al.aa_feature_id
  AND ef.motif_aa_sequence_id = mas.aa_sequence_id
  AND tas.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Epi_srcId_ix&1 ON EpitopeSummary&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TranscriptCenDistance">
    <comment> Stores (transcript, sequence, distance from centromere) 3-tuples for transcripts
         that lie on a sequence for which we have a centomere location.
     </comment>
    <internalDependency name="FeatureLocation"/>
    <internalDependency name="TranscriptLocation"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        CREATE TABLE TranscriptCenDistance&1 NOLOGGING AS
        SELECT tl.feature_source_id AS transcript,
               LEAST(ABS(mfl.start_min - tl.end_max),
                     ABS(mfl.end_max - tl.start_min)) AS centromere_distance,
               tl.sequence_source_id AS genomic_sequence
        FROM TranscriptLocation tl, FeatureLocation mfl,
             sres.OntologyTerm so
        WHERE tl.na_sequence_id = mfl.na_sequence_id
          AND mfl.feature_type = 'Miscellaneous'
          AND mfl.sequence_ontology_id = so.ontology_term_id
          AND so.name = 'centromere'
          AND tl.is_top_level = 1
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GCent_loc_ix&1
       on TranscriptCenDistance&1 (genomic_sequence, centromere_distance)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProteinAttributes" prefixEnabled="true">
    <comment>The BFMV for the gene record. Each gene gets a single record, which
         stores all its attributes. Used widely, in the model and elsewhere, for
         queries involving genes, as well as in the creation of more than a
         dozen other tuning tables.
    </comment>
    <internalDependency name="ProjectTaxon"/>
    <internalDependency name="TranscriptLocation"/>
    <internalDependency name="GoTermSummary"/>
    <externalDependency name="apidb.AaSequenceAttribute"/>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.AaSequence"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.RnaType"/>
    <externalDependency name="dots.SignalPeptideFeature"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="dots.TransmembraneAaFeature"/>
    <intermediateTable name="GoTermList"/>
    <intermediateTable name="ProteinGoAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixGoTermList NOLOGGING AS
SELECT aa_sequence_id, ontology, source,
             apidb.tab_to_string(set(cast(COLLECT(go_term_name order by go_term_name) as apidb.varchartab)), ', ') AS go_terms,
             apidb.tab_to_string(set(cast(COLLECT(go_id order by go_term_name) as apidb.varchartab)), ', ') AS go_ids
      FROM (SELECT aa_sequence_id, ontology, 
                        DECODE(source, 'Interpro', 'predicted', 'annotated') AS source, go_term_name, go_id
                 FROM  &prefixGoTermSummary
                 WHERE is_leaf = 1
                 )
      GROUP BY aa_sequence_id, ontology, source
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE &prefixProteinGoAttributes NOLOGGING AS
SELECT DISTINCT gts.aa_sequence_id,
       substr(annotated_go_component.go_terms, 1, 300) AS annotated_go_component,
       substr(annotated_go_function.go_terms, 1, 300) AS annotated_go_function,
       substr(annotated_go_process.go_terms, 1, 300) AS annotated_go_process,
       substr(predicted_go_component.go_terms, 1, 300) AS predicted_go_component,
       substr(predicted_go_function.go_terms, 1, 300) AS predicted_go_function,
       substr(predicted_go_process.go_terms, 1, 300) AS predicted_go_process,

       substr(annotated_go_component.go_ids, 1, 300) AS annotated_go_id_component,
       substr(annotated_go_function.go_ids, 1, 300) AS annotated_go_id_function,
       substr(annotated_go_process.go_ids, 1, 300) AS annotated_go_id_process,
       substr(predicted_go_component.go_ids, 1, 300) AS predicted_go_id_component,
       substr(predicted_go_function.go_ids, 1, 300) AS predicted_go_id_function,
       substr(predicted_go_process.go_ids, 1, 300) AS predicted_go_id_process
FROM (SELECT DISTINCT aa_sequence_id FROM &prefixGoTermSummary) gts,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'annotated' AND ontology = 'Cellular Component')
       annotated_go_component,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'annotated' AND ontology = 'Molecular Function')
       annotated_go_function,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'annotated' AND ontology = 'Biological Process')
       annotated_go_process,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'predicted' AND ontology = 'Cellular Component')
       predicted_go_component,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'predicted' AND ontology = 'Molecular Function')
       predicted_go_function,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'predicted' AND ontology = 'Biological Process')
       predicted_go_process
WHERE gts.aa_sequence_id = annotated_go_component.aa_sequence_id(+)
  AND 'annotated' = annotated_go_component.source(+)
  AND 'Cellular Component' = annotated_go_component.ontology(+)
  AND gts.aa_sequence_id = annotated_go_function.aa_sequence_id(+)
  AND 'annotated' = annotated_go_function.source(+)
  AND 'Molecular Function' = annotated_go_function.ontology(+)
  AND gts.aa_sequence_id = annotated_go_process.aa_sequence_id(+)
  AND 'annotated' = annotated_go_process.source(+)
  AND 'Biological Process' = annotated_go_process.ontology(+)
  AND gts.aa_sequence_id = predicted_go_component.aa_sequence_id(+)
  AND 'predicted' = predicted_go_component.source(+)
  AND 'Cellular Component' = predicted_go_component.ontology(+)
  AND gts.aa_sequence_id = predicted_go_function.aa_sequence_id(+)
  AND 'predicted' = predicted_go_function.source(+)
  AND 'Molecular Function' = predicted_go_function.ontology(+)
  AND gts.aa_sequence_id = predicted_go_process.aa_sequence_id(+)
  AND 'predicted' = predicted_go_process.source(+)
  AND 'Biological Process' = predicted_go_process.ontology(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index ProteinGoAttr_aaSequenceId&1 ON &prefixProteinGoAttributes (aa_sequence_id)
tablespace indx
      ]]>
    </sql>

    <sql>
      <![CDATA[
CREATE TABLE &prefixProteinAttributes&1 NOLOGGING AS
SELECT pi.name as project_id,
             tas.source_id, tas.aa_sequence_id,
             t.source_id as transcript_source_id,
             gf.source_id as gene_source_id,
             cdsl.na_sequence_id as na_sequence_id,
             cdsl.is_reversed, 
             cdsl.start_min as cds_start,
             cdsl.end_max as cds_end,
             ( cdsl.end_max - cdsl.start_min ) + 1 AS cds_length,
             tas.length AS protein_length, 
             NVL(transmembrane.tm_domains, 0) AS tm_count,
             tas.molecular_weight,
             asa.min_molecular_weight, asa.max_molecular_weight,
             asa.isoelectric_point, asa.hydropathicity_gravy_score,
             asa.aromaticity_score,             
             sigp.scores as signalp_scores,
             SUBSTR(sigp.pep, 1, 200) as signalp_peptide,
             ec_numbers,
             ec_numbers_derived,
       go.annotated_go_component,
       go.annotated_go_function,
       go.annotated_go_process,
       go.predicted_go_component,
       go.predicted_go_function,
       go.predicted_go_process,
       go.annotated_go_id_component,
       go.annotated_go_id_function,
       go.annotated_go_id_process,
       go.predicted_go_id_component,
       go.predicted_go_id_function,
       go.predicted_go_id_process,
             SUBSTR(NVL(rt1.anticodon, rt2.anticodon), 1, 3) AS anticodon
      FROM  dots.GeneFeature gf, dots.Transcript t, core.ProjectInfo pi,
            dots.TranslatedAaFeature taf,
            dots.TranslatedAaSequence tas,
            apidb.AaSequenceAttribute asa,
            (SELECT protein_source_id, na_sequence_id, is_reversed,
                 MIN(start_min) AS start_min, MAX(end_max) AS end_max  
             FROM &prefixCdsLocation WHERE is_top_level=1
             GROUP BY protein_source_id, na_sequence_id, is_reversed)  cdsl, 
            &prefixProteinGoAttributes go,
            dots.RnaType rt1, dots.RnaType rt2,
            (SELECT aa_sequence_id, max(tm_domains) AS tm_domains
             FROM (SELECT tmaf.aa_sequence_id, COUNT(*) AS tm_domains
                   FROM dots.TransmembraneAaFeature tmaf, dots.AaLocation al
                   WHERE tmaf.aa_feature_id = al.aa_feature_id
                   GROUP BY tmaf.aa_sequence_id) tms
             GROUP BY tms.aa_sequence_id) transmembrane,
             (SELECT spf.aa_sequence_id,'NN Sum: ' || ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) ||
              ', NN D: ' || round(((spf.means_score + spf.maxy_score) / 2),2) || ', HMM Prob: ' || round(spf.signal_probability,2) as scores,
               apidb.tab_to_string(set(cast(COLLECT(decode(spf.algorithm_name,'SignalPhmm','HMM: ','NN: ') || dbms_lob.substr(s.sequence,aal.end_max,1) order by spf.algorithm_name, dbms_lob.substr(s.sequence, aal.end_max, 1)) as apidb.varchartab)), ', ') as pep
              FROM dots.SignalPeptideFeature spf, dots.AaLocation aal, dots.AaSequence s
              WHERE spf.aa_sequence_id = s.aa_sequence_id 
              and  aal.aa_feature_id = spf.aa_feature_id
              and (spf.signal_probability >= .5
              or ((spf.means_score + spf.maxy_score) / 2) >= .5
              or ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) >= 3)
              group by spf.aa_sequence_id,'NN Sum: ' || ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) ||
              ', NN D: ' || round(((spf.means_score + spf.maxy_score) / 2),2) || ', HMM Prob: ' || round(spf.signal_probability,2)) sigp,
            (SELECT aa_sequence_id,
                    SUBSTR(apidb.tab_to_string(set(cast(COLLECT(ec_number order by ec_number)
                                               as apidb.varchartab)), '; '),
                           1, 300)
                      AS ec_numbers
             FROM (SELECT DISTINCT asec.aa_sequence_id,
                          ec.ec_number || ' (' || ec.description || ')' AS ec_number
                   FROM dots.AaSequenceEnzymeClass asec, sres.EnzymeClass ec
                   WHERE ec.enzyme_class_id = asec.enzyme_class_id
		   AND NOT asec.evidence_code = 'OrthoMCLDerived')
             GROUP BY aa_sequence_id) ec,

            (SELECT aa_sequence_id,
                    SUBSTR(apidb.tab_to_string(set(cast(COLLECT(ec_number order by ec_number)
                                               as apidb.varchartab)), '; '),
                           1, 300)
                      AS ec_numbers_derived
             FROM (SELECT DISTINCT asec.aa_sequence_id,
                          ec.ec_number || ' (' || ec.description || ')' AS ec_number
                   FROM dots.AaSequenceEnzymeClass asec, sres.EnzymeClass ec
                   WHERE ec.enzyme_class_id = asec.enzyme_class_id
		   AND asec.evidence_code = 'OrthoMCLDerived')
             GROUP BY aa_sequence_id) ecDerived
      WHERE gf.na_feature_id = t.parent_id
        AND t.row_project_id = pi.project_id
        AND t.na_feature_id = taf.na_feature_id
        AND taf.aa_sequence_id = tas.aa_sequence_id
        AND taf.aa_sequence_id = asa.aa_sequence_id
        AND tas.aa_sequence_id = sigp.aa_sequence_id(+)
        AND cdsl.protein_source_id =  tas.source_id
        AND t.na_feature_id = rt1.parent_id(+)
        AND gf.na_feature_id = rt2.parent_id(+)
        AND tas.aa_sequence_id = transmembrane.aa_sequence_id(+)
        AND tas.aa_sequence_id = ec.aa_sequence_id(+)
        AND tas.aa_sequence_id = ecDerived.aa_sequence_id(+)
        AND tas.aa_sequence_id = go.aa_sequence_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX PA_sourceId&1 ON &prefixProteinAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX PA_aaSequenceId&1 ON &prefixProteinAttributes&1 (aa_sequence_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TranscriptAttributes" prefixEnabled="true">
    <comment>The BFMV for the gene record. Each gene gets a single record, which
         stores all its attributes. Used widely, in the model and elsewhere, for
         queries involving genes, as well as in the creation of more than a
         dozen other tuning tables.
    </comment>
    <internalDependency name="GeneId"/>
    <internalDependency name="FeatureLocation"/>
    <internalDependency name="ProjectTaxon"/>
    <internalDependency name="ProteinAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <internalDependency name="TranscriptLocation"/>
    <internalDependency name="SnpAttributes"/>
    <externalDependency name="apidb.GeneFeatureName"/>
    <externalDependency name="apidb.TranscriptProduct"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.AaSequence"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="dots.ExonFeature"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.GeneInstance"/>
    <externalDependency name="dots.NaFeatureComment"/>
    <externalDependency name="dots.RnaFeatureExon"/>
    <externalDependency name="dots.RnaType"/>
    <externalDependency name="dots.SequenceGroup"/>
    <externalDependency name="dots.SequenceSequencegroup"/>
    <externalDependency name="dots.SnpFeature"/>
    <externalDependency name="dots.SplicedNaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TransmembraneAaFeature"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixTranscriptAttributes&1 NOLOGGING AS
SELECT cast(apidb.prefixed_project_id(tn.name, '&prefix') as varchar2(20)) as project_id,
       --source_id :
       CASE  WHEN (pa.source_id IS NOT NULL) THEN pa.source_id
       ELSE  t.source_id END AS source_id,

       --first the gene attributes:
       gf.source_id AS gene_source_id, 
       gf.na_feature_id AS gene_na_feature_id,
       LEAST(nl.start_min, nl.end_max) AS gene_start_min,
       GREATEST(nl.start_min, nl.end_max) AS gene_end_max,
       COALESCE(preferred_name.name, any_name.name) AS gene_name,
       cast(null as varchar2(900)) as gene_product,
       REPLACE(so.name, '_', ' ') AS gene_type,
       gi.gene_id,
       transcripts.gene_transcript_count,
       exons.gene_exon_count,
       cast(null as varchar2(80)) as representative_gene,
       olds.old_ids AS gene_previous_ids,
       nvl(deprecated.is_deprecated, 0) as is_deprecated, 
       0 as gene_paralog_number, 0 as gene_ortholog_number,

       GREATEST(1, least(nl.start_min, nl.end_max) - 15000) AS gene_context_start,
       LEAST(sequence.length, greatest(nl.start_min, nl.end_max) + 15000) AS gene_context_end,
       substr(orthologs.name, 1, 60) AS orthomcl_name,
       nvl(tothtssnps.total_hts_snps,0) AS gene_total_hts_snps, 
       nvl(tothtssnps.hts_nonsynonymous_snps,0) AS gene_hts_nonsynonymous_snps,
       nvl(tothtssnps.hts_stop_codon_snps,0) AS gene_hts_stop_codon_snps,
       nvl(tothtssnps.hts_noncoding_snps,0) AS gene_hts_noncoding_snps, 
       nvl(tothtssnps.hts_synonymous_snps,0) AS gene_hts_synonymous_snps,
       nvl(tothtssnps.hts_nonsyn_syn_ratio,0) AS gene_hts_nonsyn_syn_ratio, 
       SUBSTR(cmnt.comment_string, 1, 300) AS comment_string,
       uniprot.gene_uniprot_id, uniprot.gene_uniprot_id_internal,
       entrez_table.entrez_id AS gene_entrez_id, 

       --next the transcript attributes: 
       t.source_id AS transcript_source_id,
       t.na_feature_id,
       SUBSTR(COALESCE(preferred_product.product, any_product.product, 'unspecified product'), 1, 300) 
            AS transcript_product,
       tl.start_min as coding_start,
       tl.end_max as coding_end,
       tl.is_reversed,   --CHECK if needed
       DECODE(nvl(tl.is_reversed, 0), 0, 'forward', 1, 'reverse', tl.is_reversed) AS strand,
       DECODE(t.is_pseudo, null, 0, t.is_pseudo) as is_pseudo,
       transcript_exons.exon_count,
       sns.length AS length,

       SUBSTR(sequence.source_id, 1, 50) AS sequence_id,
       SUBSTR(tn.name, 1, 100) AS organism,
       SUBSTR(species_name.name, 1, 100) AS species,
       taxon.ncbi_tax_id,  tn.taxon_id, 
       so.source_id as so_id, SUBSTR(so.name, 1, 150) AS so_term_name,
       SUBSTR(so.definition, 1, 150) AS so_term_definition,
       SUBSTR(soRls.version, 1, 7) AS so_version,
       SUBSTR(NVL(rt1.anticodon, rt2.anticodon), 1, 3) AS anticodon,
       ed.name AS external_db_name,
       SUBSTR(edr.version, 1, 10) AS external_db_version,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.chromosome_order_num, sequence.na_sequence_id,

       --next the protein attributes: 
       pa.source_id AS protein_source_id,
       pa.aa_sequence_id,
       pa.cds_start, pa.cds_end, pa.cds_length, 
       pa.protein_length, pa.tm_count,
       pa.molecular_weight,
       pa.isoelectric_point, 
       pa.signalp_scores, pa.signalp_peptide,
       pa.ec_numbers, pa.ec_numbers_derived,
       pa.annotated_go_component,
       pa.annotated_go_function,
       pa.annotated_go_process,
       pa.predicted_go_component,
       pa.predicted_go_function,
       pa.predicted_go_process,
       pa.annotated_go_id_component,
       pa.annotated_go_id_function,
       pa.annotated_go_id_process,
       pa.predicted_go_id_component,
       pa.predicted_go_id_function,
       pa.predicted_go_id_process
FROM dots.GeneFeature gf, &prefixFeatureLocation nl, sres.OntologyTerm so,
     sres.externalDatabaseRelease soRls,
     sres.Taxon, sres.TaxonName tn, dots.RnaType rt1, dots.RnaType rt2,
     dots.Transcript t, sres.ExternalDatabase ed,
     sres.ExternalDatabaseRelease edr, dots.SplicedNaSequence sns,
     (SELECT rna_feature_id, count(*) as exon_count
      FROM dots.RnaFeatureExon 
      GROUP BY rna_feature_id) transcript_exons,
     ( select na_sequence_id, source_id, chromosome, chromosome_order_num, length, taxon_id
       from dots.ExternalNaSequence
      union
       select na_sequence_id, source_id, chromosome, chromosome_order_num, length, taxon_id
       from dots.VirtualSequence) sequence,
     &prefixTranscriptLocation tl, &prefixProteinAttributes pa,
     dots.geneinstance gi, &prefixTaxonSpecies ts, sres.TaxonName species_name,
     (SELECT DISTINCT gene AS source_id FROM &prefixGeneId) gene,
     (SELECT parent_id, count(*) AS gene_transcript_count
      FROM dots.Transcript
      GROUP BY parent_id) transcripts,
     (SELECT parent_id, count(*) AS gene_exon_count
      FROM dots.ExonFeature
      GROUP BY parent_id) exons,
     (SELECT nfc.na_feature_id,
             MAX(DBMS_LOB.SUBSTR(nfc.comment_string, 300, 1))
               AS comment_string
      FROM dots.NaFeatureComment nfc
      GROUP BY nfc.na_feature_id) cmnt,
     (select distinct gf.source_id, 1 as is_deprecated
      from dots.GeneFeature gf, dots.DbRefNaFeature drnf, sres.DbRef dr, sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      where gf.na_feature_id = drnf.na_feature_id
        and drnf.db_ref_id = dr.db_ref_id
        and dr.external_database_release_id = edr.external_database_release_id
        and edr.external_database_id = ed.external_database_id
        and ed.name = 'gassAWB_dbxref_gene2Deprecated_RSRC') deprecated,
     ( select gene_source_id, total_hts_snps, hts_nonsynonymous_snps, hts_stop_codon_snps,hts_noncoding_snps,hts_synonymous_snps,
        case when (hts_nonsynonymous_snps is null) then 0
              when (hts_synonymous_snps = 0) then 0
                  else round ((hts_nonsynonymous_snps/ hts_synonymous_snps), 2) end as hts_nonsyn_syn_ratio 
      from (
             select gene_source_id,
                    count(*) as total_hts_snps,
                    sum(has_nonsynonymous_allele) as hts_nonsynonymous_snps,
                    sum(has_stop_codon) as hts_stop_codon_snps,
                    sum(is_noncoding_snp) as hts_noncoding_snps,
                    count(*) - sum(has_nonsynonymous_allele) - sum(has_stop_codon) - sum(is_noncoding_snp)  as hts_synonymous_snps
             from &prefixSnpAttributes
             where  gene_source_id is not null
             group by gene_source_id 
      ) ) tothtssnps, 
     (  select gf.na_feature_id, sg.name
        from dots.genefeature gf, dots.SequenceSequenceGroup ssg, 
             dots.SequenceGroup sg, core.TableInfo ti
        where gf.na_feature_id = ssg.sequence_id
          and ssg.sequence_group_id = sg.sequence_group_id
          and ssg.source_table_id = ti.table_id
          and ti.name = 'GeneFeature'
       ) orthologs,
     (select na_feature_id, max(product) as product
      from apidb.TranscriptProduct
      where is_preferred = 1
      group by na_feature_id
     ) preferred_product,
     (select na_feature_id, max(product) as product
      from apidb.TranscriptProduct
      group by na_feature_id
     ) any_product,
     (select na_feature_id, max(name) as name
      from apidb.GeneFeatureName
      where is_preferred = 1
      group by na_feature_id
     ) preferred_name,
     (select na_feature_id, max(name) as name
      from apidb.GeneFeatureName
      group by na_feature_id
     ) any_name,
     (select gene as source_id,
             substr(listagg (id, ',') within group (order by id), 1, 240) as gene_uniprot_id,
             substr(listagg (id, '+or+') within group (order by id), 1, 240) as gene_uniprot_id_internal
      from &prefixGeneId
      where database_name like '%uniprot_dbxref_RSRC'
         or database_name like '%dbxref_gene2Uniprot_RSRC'
         or database_name = 'Links to Uniprot Genes'
      group by gene
     ) uniprot,
     (select dbna.na_feature_id,
             substr(listagg (db.primary_identifier, ',') within group (order by db.primary_identifier), 1, 300) as entrez_id
      from sres.ExternalDatabaseRelease edr, sres.DbRef db,
           dots.DbRefNaFeature dbna, sres.ExternalDatabase ed
      where edr.external_database_release_id = db.external_database_release_id
        and ed.external_database_id = edr.external_database_id
        and dbna.db_ref_id = db.db_ref_id
        and lower(ed.name) like '%entrez%'
        group by dbna.na_feature_id
     ) entrez_table,
     (select drnf.na_feature_id,
                 substr(listagg(dr.primary_identifier, ', ') within group (order by dr.primary_identifier), 1, 900) as old_ids
          from dots.DbRefNaFeature drnf, sres.DbRef dr, sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
          where dr.primary_identifier is not null
            and drnf.db_ref_id = dr.db_ref_id
            and dr.external_database_release_id = edr.external_database_release_id
            and edr.external_database_id = ed.external_database_id
            and edr.id_type = 'previous id'
          group by drnf.na_feature_id
     ) olds
WHERE gf.source_id = gene.source_id
  AND gf.na_feature_id = nl.na_feature_id
  AND nl.is_top_level = 1
  AND nl.na_sequence_id = sequence.na_sequence_id
  AND (sequence.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
  AND gf.sequence_ontology_id = so.ontology_term_id
  AND so.external_database_release_id = soRls.external_database_release_id
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
  AND tn.taxon_id NOT IN
	 (SELECT o.taxon_id FROM apidb.Organism o WHERE  o.is_annotated_genome=0)
  AND t.na_sequence_id = sns.na_sequence_id(+)
  AND gf.na_feature_id = t.parent_id(+)
  AND tl.feature_source_id =  t.source_id
  AND tl. is_top_level=1
  AND t.na_feature_id = transcript_exons.rna_feature_id
  AND t.na_feature_id = rt1.parent_id(+)
  AND gf.na_feature_id = rt2.parent_id(+)
  AND gf.external_database_release_id
       = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND gf.na_feature_id = transcripts.parent_id(+)
  AND gf.na_feature_id = exons.parent_id(+)
  AND gf.na_feature_id = orthologs.na_feature_id(+)
  AND gf.na_feature_id = cmnt.na_feature_id(+)
  AND gf.source_id = deprecated.source_id(+)
  AND gf.na_feature_id = gi.na_feature_id(+)
  AND gf.source_id = tothtssnps.gene_source_id(+)
  AND sequence.taxon_id = ts.taxon_id(+)
  AND ts.species_taxon_id = species_name.taxon_id
  AND species_name.name_class = 'scientific name'
  AND t.na_feature_id = preferred_product.na_feature_id(+)
  AND t.na_feature_id = any_product.na_feature_id(+)
  AND gf.na_feature_id = preferred_name.na_feature_id(+)
  AND gf.na_feature_id = any_name.na_feature_id(+)
  AND (gf.is_predicted != 1 OR gf.is_predicted is null)
  AND tn.name not in ('Plasmodium gallinaceum','Plasmodium reichenowi')
  AND gf.source_id = uniprot.source_id(+)
  AND gf.na_feature_id = entrez_table.na_feature_id(+)
  AND gf.na_feature_id = olds.na_feature_id(+)
  AND t.source_id = pa.transcript_source_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
update &prefixTranscriptAttributes&1 ga
set ga.gene_product = 
 (select apidb.tab_to_string(set(cast(COLLECT(transcript_product order by transcript_product) as apidb.varchartab)), ', ') 
 from &prefixTranscriptAttributes&1 gb
                     where gb.gene_source_id = ga.gene_source_id
                     group by ga.gene_source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create /* unique */
index TranscriptAttr_sourceId&1
       ON &prefixTranscriptAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create /* unique */
 index TranscriptAttr_srcPrj&1
       ON &prefixTranscriptAttributes&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index TranscriptAttr_exon_ix&1
       ON &prefixTranscriptAttributes&1 (gene_exon_count, source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index TranscriptAttr_loc_ix&1
       ON &prefixTranscriptAttributes&1 (na_sequence_id, gene_start_min, gene_end_max, is_reversed, na_feature_id, is_deprecated)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index TranscriptAttr_feat_ix&1
       ON &prefixTranscriptAttributes&1 (na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index TranscriptAttr_geneid_ix&1
       ON &prefixTranscriptAttributes&1 (gene_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index TransAttr_orthoname_ix&1
       ON &prefixTranscriptAttributes&1 (orthomcl_name, source_id, taxon_id, gene_type)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index TransAttr_ortholog_ix&1
       ON &prefixTranscriptAttributes&1 (source_id, na_sequence_id, gene_start_min, gene_end_max, orthomcl_name)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index TransAttr_orgsrc_ix&1
       ON &prefixTranscriptAttributes&1 (organism, source_id, sequence_id, gene_start_min, gene_end_max)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
  update &prefixTranscriptAttributes&1
  set gene_exon_count = 1
  where gene_exon_count > 1
   and project_id = 'TriTrypDB' 
   and source_id in (
                select source_id from &prefixTranscriptAttributes&1
              minus
                select source_id
                from (
                  select 'intron' as type, ga.source_id,
                          abs(rightLoc.start_min - leftLoc.end_max) as len
                  from dots.ExonFeature left, &prefixFeatureLocation leftLoc,
                       dots.ExonFeature right, &prefixFeatureLocation rightLoc,
                       &prefixTranscriptAttributes&1 ga
                  where left.parent_id = right.parent_id
                    and left.parent_id = ga.na_feature_id
                    and (left.order_number = right.order_number - 1
                         or left.order_number = right.order_number + 1)
                    and leftLoc.start_min < rightLoc.start_min
                    and left.na_feature_id = leftLoc.na_feature_id
                    and leftLoc.is_top_level = 1
                    and right.na_feature_id = rightLoc.na_feature_id
                    and rightLoc.is_top_level = 1
                   ) 
               group by source_id
               having min(len) > 10
           )
      ]]>
    </sql>
<!--
    <sql>
      <![CDATA[
update &prefixTranscriptAttributes&1 ga
set ga.orthomcl_name = (select distinct gb.orthomcl_name from &prefixTranscriptAttributes&1 gb
                     where gb.gene_id = ga.gene_id
                     and gb.orthomcl_name is not null
                     and gb.source_id != gb.orthomcl_name)
where ga.organism like 'Toxo%' 
and ga.orthomcl_name is null
      ]]>
    </sql>
-->
    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1
        set orthomcl_name = 'ORTH_' || gene_id || '.tmp'
        where orthomcl_name is null
        and gene_id is not null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1
        set orthomcl_name = source_id
        where orthomcl_name is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
       update &prefixTranscriptAttributes&1 gaup
       set gene_paralog_number = (select count(*)
                               from &prefixTranscriptAttributes&1 g1
                               where g1.orthomcl_name = gaup.orthomcl_name
                               and g1.organism = gaup.organism
                               and gaup.source_id != g1.source_id),
           gene_ortholog_number = (select count(*)
                               from &prefixTranscriptAttributes&1 g1
                               where g1.orthomcl_name = gaup.orthomcl_name
                               and g1.organism != gaup.organism)
        where gaup.gene_type = 'protein coding'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1
        set representative_gene = (select min(source_id)
                                   from &prefixTranscriptAttributes&1 ga
                                   where ga.gene_id = &prefixTranscriptAttributes&1.gene_id)
        where representative_gene is null
          and gene_id is not null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1
        set representative_gene = source_id
        where representative_gene is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1
        set gene_id = na_feature_id /* gene_id is NUMBER(10) and source_id is VARCHAR(80) */
        where gene_id is null
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GenomicSequenceAttributes" prefixEnabled="true">
    <comment>Each row represents one genomic sequence for which a WDK sequence
         record can be instantiated. Used widely in the workflow, the model,
         and GBrowse, as well as in the creation of a dozen or so other tuning
         tables.
    </comment>
    <internalDependency name="ProjectTaxon"/>
    <internalDependency name="SequencePieceClosure"/>
    <externalDependency name="apidb.Synteny"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixGenomicSequenceAttributes&1 NOLOGGING AS
SELECT cast(apidb.prefixed_project_id(tn.name, '&prefix') as varchar2(20)) as project_id,
       SUBSTR(sequence.source_id, 1, 60) AS source_id, sequence.a_count,
       sequence.c_count, sequence.g_count, sequence.t_count,
       (sequence.length
        - (sequence.a_count + sequence.c_count + sequence.g_count + sequence.t_count))
         AS other_count,
       sequence.length,
       to_char((sequence.a_count + sequence.t_count) / sequence.length * 100, '99.99')
         AS at_percent,
       SUBSTR(tn.name, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       taxon.taxon_id,                 
       CASE WHEN sequence.description IS NULL  THEN SUBSTR(tn.name, 1, 100)
            ELSE SUBSTR(sequence.description, 1, 400)
            END AS sequence_description,
       SUBSTR(genbank.genbank_accession, 1, 20) AS genbank_accession,
       SUBSTR(db.database_version, 1, 30) AS database_version, db.database_name,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.external_database_release_id, sequence.sequence_ontology_id,
       sequence.chromosome_order_num, so.source_id as so_id, so.name as sequence_type,
       nvl(virtualization.is_top_level, 1) as is_top_level,
       sequence.na_sequence_id, organism.genome_source,
       organism.name_for_filenames, nvl(msa.has_msa, 0) as has_msa
FROM sres.TaxonName tn, sres.Taxon, sres.OntologyTerm so, apidb.Organism,
     ( select na_sequence_id, source_id, length, chromosome, chromosome_order_num, taxon_id, description,
              a_count, c_count, g_count, t_count, external_database_release_id, sequence_ontology_id
       from dots.ExternalNaSequence
      union
       select na_sequence_id, source_id, length, chromosome, chromosome_order_num, taxon_id, description,
              a_count, c_count, g_count, t_count, external_database_release_id, sequence_ontology_id
       from dots.VirtualSequence) sequence,
     (SELECT drns.na_sequence_id, max(dr.primary_identifier) AS genbank_accession
      FROM dots.dbrefNaSequence drns, sres.DbRef dr,
           sres.ExternalDatabaseRelease gb_edr, sres.ExternalDatabase gb_ed
      WHERE drns.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
            = gb_edr.external_database_release_id
        AND gb_edr.external_database_id = gb_ed.external_database_id
        AND gb_ed.name = 'GenBank'
      GROUP BY drns.na_sequence_id) genbank,
     (SELECT edr.external_database_release_id,
             edr.version AS database_version, ed.name AS database_name
      FROM sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      WHERE edr.external_database_id = ed.external_database_id) db,
     (SELECT distinct piece_na_sequence_id, 0 as is_top_level
      FROM &prefixSequencePieceClosure) virtualization,
     (SELECT a_na_sequence_id as na_sequence_id, 1 as has_msa
      FROM apidb.Synteny syn
      GROUP BY a_na_sequence_id) msa
WHERE sequence.taxon_id = tn.taxon_id(+)
  AND (sequence.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
  AND tn.name_class = 'scientific name'
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.sequence_ontology_id = so.ontology_term_id
  AND so.name IN ('random_sequence', 'chromosome', 'contig', 'supercontig','mitochondrial_chromosome','plastid_sequence','cloned_genomic','apicoplast_chromosome')
  AND sequence.na_sequence_id = genbank.na_sequence_id(+)
  AND sequence.external_database_release_id = db.external_database_release_id(+)
  AND sequence.na_sequence_id = virtualization.piece_na_sequence_id(+)
  AND taxon.taxon_id = organism.taxon_id(+)
  AND sequence.na_sequence_id = msa.na_sequence_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index pk_SeqAttr_&1 ON &prefixGenomicSequenceAttributes&1 (lower(source_id), project_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index SeqAttr_source_id&1 ON &prefixGenomicSequenceAttributes&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index SeqAttr_naseqid&1 ON &prefixGenomicSequenceAttributes&1 (na_sequence_id)
      ]]>
    </sql>
  </tuningTable>


<!--
  <comment> NGS SNP only </comment>
-->
  <tuningTable name="SnpAttributes" prefixEnabled="true">
    <comment>Each record represents one SNP. Widely used in the model, as well as in
         the creation of several other tuning tables, including SnpSummary and
         IsolateSnps. This is for NGS SNPs only.
    </comment>
    <internalDependency name="FeatureLocation"/>
    <internalDependency name="ProjectTaxon"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="apidb.Snp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixSnpAttributes&1 NOLOGGING AS
SELECT cast(apidb.prefixed_project_id(tn.name, '&prefix') as varchar2(20)) as project_id,
       ed.name as dataset,
       sequence.na_sequence_id,
       sequence.source_id as seq_source_id,
       snp.location,
       snp.source_id,
       snp.reference_strain, 
       snp.reference_na, 
       snp.reference_aa, 
       decode(snp.position_in_cds, null, 0, 1) as is_coding,
       snp.position_in_CDS,
       snp.position_in_protein,
       /* has_nonsynonymous should be false if any products are stops */
       case when stopcodonsnps.total_stop_codon_snps is null then snp.has_nonsynonymous_allele else 0 end as has_nonsynonymous_allele,
       snp.major_allele, 
       snp.minor_allele,
       snp.major_allele_count, 
       snp.minor_allele_count,
       round(snp.major_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as major_allele_frequency,
       round(snp.minor_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as minor_allele_frequency,
       snp.major_product, 
       snp.minor_product,
       snp.distinct_strain_count,
       snp.distinct_allele_count,
       case when stopcodonsnps.total_stop_codon_snps is null then 0 else 1 end as has_stop_codon,
       case when snp.position_in_cds is null then 1 else 0 end as is_noncoding_snp,
       gene_info.source_id as gene_source_id,
       decode(gene_info.is_reversed, 0, 'forward', 1, 'reverse') as gene_strand,
       SUBSTR(DBMS_LOB.SUBSTR(sequence.sequence, 60, snp.location - 60), 1, 60) AS lflank,
       SUBSTR(DBMS_LOB.SUBSTR(sequence.sequence, 60, snp.location + 1), 1, 60) AS rflank,
       SUBSTR(tn.name, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       SUBSTR(chromosome_info.chromosome, 1, 20) AS chromosome,
       chromosome_info.chromosome_order_num
FROM apidb.Snp snp, 
     sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, sres.Taxon,
     sres.TaxonName tn, dots.NaSequence sequence,
     (SELECT gene.source_id, gene_loc.is_reversed, gene.na_feature_id,
             gene_loc.na_sequence_id
      FROM dots.GeneFeature gene, &prefixFeatureLocation gene_loc
      WHERE gene.na_feature_id = gene_loc.na_feature_id
            and gene_loc.is_top_level = 1) gene_info,
     (
     select snp.source_id, count(*) as total_stop_codon_snps
     from apidb.snp snp, apidb.sequencevariation var 
     where snp.na_sequence_id = var.ref_na_sequence_id
       and snp.location = var.location
         and var.product = '*' 
         group by snp.source_id 
     ) stopcodonsnps, 
     (SELECT na_sequence_id, chromosome, chromosome_order_num
      FROM dots.ExternalNaSequence
     UNION
      SELECT na_sequence_id, chromosome, chromosome_order_num
      FROM dots.VirtualSequence
     UNION
      SELECT na_sequence_id, null as chromosome, null as chromosome_order_num
      FROM dots.NaSequence
      WHERE subclass_view not in ('ExternalNASequence', 'VirtualSequence')
     ) chromosome_info
WHERE edr.external_database_release_id = snp.external_database_release_id
  AND ed.external_database_id = edr.external_database_id
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
  AND sequence.na_sequence_id = snp.na_sequence_id
  AND chromosome_info.na_sequence_id = snp.na_sequence_id
  AND gene_info.na_feature_id(+) = snp.gene_na_feature_id
  and snp.source_id = stopcodonsnps.source_id(+)
      ]]>
    </sql>

    <sql>
      <![CDATA[
create unique index SnpAttr_source_id&1 ON &prefixSnpAttributes&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Snp_nafeat_dataset_ix&1
       ON &prefixSnpAttributes&1 (dataset)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Snp_Seq_ix&1
       ON &prefixSnpAttributes&1 (na_sequence_id, dataset, location)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Snp_Freq_ix&1
       ON &prefixSnpAttributes&1 (dataset,major_allele_frequency,minor_allele_frequency)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpAttr_ds_org_ix&1 on &prefixSnpAttributes&1 (dataset,organism)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpVariantIx&1 on &prefixSnpAttributes&1 (dataset, source_id, gene_source_id, location, position_in_protein)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


<!--
  <comment> SNP Chip only, such as Plasmo barcode, 3k_chp and hd_array </comment>
  <tuningTable name="SnpChipAttributes">
    <comment> Each record represents one SNP. Widely used in the model, as well as in
         the creation of several other tuning tables, including SnpSummary and
         IsolateSnps.
     </comment>
    <internalDependency name="FeatureLocation"/>
    <internalDependency name="ProjectTaxon"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.SeqVariation"/>
    <externalDependency name="dots.SnpFeature"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE SnpChipAttributes&1 NOLOGGING AS
SELECT cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       snp.source_id,
       snp.na_feature_id,
       ed.name AS dataset,
       snp.name as type,
       sequence.na_sequence_id,
       sequence.source_id AS seq_source_id,
       snp_loc.start_min,
       SUBSTR(snp.reference_strain, 1, 200) AS reference_strain,
       SUBSTR(snp.reference_na, 1, 200) AS reference_na,
       snp.is_coding,
       snp.position_in_CDS,
       snp.position_in_protein,
       SUBSTR(snp.reference_aa, 1, 200) AS reference_aa,
       DECODE(snp.has_nonsynonymous_allele, 0, 'no', 1, 'yes')
         AS has_nonsynonymous_allele,
       SUBSTR(snp.major_allele, 1, 40) AS major_allele,
       SUBSTR(snp.major_product, 1, 40) AS major_product,
       snp.major_allele_count, 
       round(snp.major_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as major_allele_frequency,
       SUBSTR(snp.minor_allele, 1, 40) AS minor_allele,
       SUBSTR(snp.minor_product, 1, 40) AS minor_product,
       snp.minor_allele_count,
       round(snp.minor_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as minor_allele_frequency,
       gene_info.source_id AS gene_source_id,
       DECODE(gene_info.is_reversed, 0, 'forward', 1, 'reverse')
         AS gene_strand,
       SUBSTR(DBMS_LOB.SUBSTR(sequence.sequence, 60, snp_loc.start_min - 60), 1, 60)
         AS lflank,
       SUBSTR(DBMS_LOB.SUBSTR(sequence.sequence, 60, snp_loc.start_min + 1), 1, 60)
         AS rflank,
       SUBSTR(tn.name, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       SUBSTR(chromosome_info.chromosome, 1, 20) AS chromosome,
       chromosome_info.chromosome_order_num
FROM dots.SnpFeature snp, FeatureLocation snp_loc,
     sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, sres.Taxon,
     sres.TaxonName tn, dots.NaSequence sequence,
     (SELECT gene.source_id, gene_loc.is_reversed, gene.na_feature_id,
             gene_loc.na_sequence_id
      FROM dots.GeneFeature gene, &prefixFeatureLocation gene_loc
      WHERE gene.na_feature_id = gene_loc.na_feature_id
            and gene_loc.is_top_level = 1) gene_info,
     (SELECT na_sequence_id, chromosome, chromosome_order_num
      FROM dots.ExternalNaSequence
     UNION
      SELECT na_sequence_id, chromosome, chromosome_order_num
      FROM dots.VirtualSequence
     UNION
      SELECT na_sequence_id, null as chromosome, null as chromosome_order_num
      FROM dots.NaSequence
      WHERE subclass_view not in ('ExternalNASequence', 'VirtualSequence')
     ) chromosome_info
WHERE edr.external_database_release_id = snp.external_database_release_id
  AND ed.external_database_id = edr.external_database_id
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
  AND snp_loc.na_feature_id = snp.na_feature_id
  AND snp_loc.is_top_level = 1
  AND sequence.na_sequence_id = snp_loc.na_sequence_id
  AND chromosome_info.na_sequence_id = snp_loc.na_sequence_id
  AND gene_info.na_feature_id(+) = snp.parent_id
  AND snp.name in ('Broad_barcode', 'Broad_3k_chip', 'Broad_hd_array')
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index SnpChipAttr_source_id&1 ON SnpChipAttributes&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpChip_nafeat_dataset_ix&1
       ON SnpChipAttributes&1 (na_feature_id, dataset)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpChip_Seq_ix&1
       ON SnpChipAttributes&1 (na_sequence_id, dataset, start_min, na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpChip_Freq_ix&1
       ON SnpChipAttributes&1 (dataset,major_allele_frequency,minor_allele_frequency)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpChipAttr_ds_org_ix&1 on snpchipattributes&1 (dataset,organism,na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpChipVariantIx&1 on SnpChipAttributes&1 (type, dataset, na_feature_id, source_id, gene_source_id, start_min, position_in_protein)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="HtsVariant">
    <comment> This table is like SeqVariation, but only for HTS SNPs, and filtered
         for allele_percent > 80. Used in SNP queries, and to make the
         GoodHtsSnp tuning table.
     </comment>
    <internalDependency name="SnpChipAttributes"/>
    <externalDependency name="dots.SeqVariation"/>
    <sql>
      <![CDATA[
        create table HtsVariant&1 nologging as
        select snp.na_feature_id as snp_na_feature_id, min(var.na_feature_id) as var_na_feature_id,
               substr(var.allele, 1, 1) as allele,
               substr(max(var.product), 1, 30) as product, substr(var.strain, 1, 30) as strain,
               min(t.taxon_id) as species_taxon_id,
               substr(min(snp.source_id), 1, 50) as snp_source_id, min(snp.gene_source_id) as gene_source_id
        from dots.SeqVariation var, SnpChipAttributes snp, sres.Taxon t
        where var.parent_id = snp.na_feature_id
          and snp.ncbi_tax_id = t.ncbi_tax_id
          and snp.type = 'HTS'
          and var.name = 'SNP'
          and var.allele != 'undefined' /* this actually shows up in some crypto records */
              /* we can only use this allele_percent cutoff for haploid parasites, like plasmodium and toxoplasma */
          and (var.allele_percent > 80 or var.allele_percent is null)
        group by snp.na_feature_id, var.allele, var.strain
      ]]>
    </sql>
    <sql>
      <![CDATA[
        delete from HtsVariant&1
        where snp_na_feature_id
              in (select snp_na_feature_id
                  from (select snp_na_feature_id, count(distinct allele) as allele_count
                        from HtsVariant&1
                        group by snp_na_feature_id)
                  where allele_count = 1)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index htsvar_ix&1
        on HtsVariant&1 (strain, species_taxon_id,   /* access predicates for strain comparison */
                         snp_source_id, allele, product) /* others */
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GoodHtsSnp">
    <comment> One record per HTS SNP location, rolled up from HtsVariant. Used for
         SNP queries.
     </comment>
    <internalDependency name="HtsVariant"/>
    <sql>
      <![CDATA[
        create table GoodHtsSnp&1 nologging as
        with snp_alleles /* one row per (SNP, allele) pair */
             as (select snp_na_feature_id, max(snp_source_id) as snp_source_id, max(species_taxon_id) as taxon_id,
                        allele, max(product) as product, count(*) as strain_count
                 from HtsVariant
                 group by snp_na_feature_id, allele),
             ranked_alleles /* add ranking within SNP: 1 for major allele, 2 for silver medalist, et c. */
             as (select snp_na_feature_id, allele, snp_source_id, taxon_id, product, strain_count,
                        row_number() over (partition by snp_na_feature_id order by strain_count desc) as ranking
                 from snp_alleles),
             allele_majority /* break out attributes to major_X and minor_X */
             as (select snp_na_feature_id, snp_source_id, taxon_id, strain_count,
                        case when ranking = 1 then strain_count else 0 end as major_allele_count,
                        case when ranking = 1 then 0 else strain_count end as minor_allele_count,
                        case when ranking = 1 then allele else null end as major_allele,
                        case when ranking = 1 then null else allele end as minor_allele,
                        case when ranking = 1 then product else null end as major_product,
                        case when ranking = 1 then null else product end as minor_product
                 from ranked_alleles)
        select snp_na_feature_id as na_feature_id, max(snp_source_id) as source_id, max(taxon_id) as taxon_id,
               sum(strain_count) as strain_count,
               substr(listagg(minor_allele, ', ') within group (order by strain_count desc), 1, 12) as minor_allele,
               substr(listagg(major_allele, ', ') within group (order by major_allele), 1, 1) as major_allele,
               substr(listagg(minor_product, ', ') within group (order by strain_count desc), 1, 12) as minor_product,
               substr(listagg(major_product, ', ') within group (order by major_product), 1, 12) as major_product,
               sum(major_allele_count) / sum(strain_count) as major_allele_frequency,
               sum(minor_allele_count) / sum(strain_count) as minor_allele_frequency
        from allele_majority
        group by snp_na_feature_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index goodSnp_ix&1
        on GoodHtsSnp&1 (taxon_id, strain_count, /* access predicates */
                         minor_allele_frequency, /* filter predicates */
                         source_id, major_allele, minor_allele, major_product, minor_product) /* selectables */
        tablespace indx
      ]]>
    </sql>
  </tuningTable>
-->


  <tuningTable name="OrfAttributes">
    <comment> Each record represents an ORF. Used by the model and the sequence
         retrieval tool for ORF-related queries.
     </comment>
    <internalDependency name="FeatureLocation"/>
    <internalDependency name="ProjectTaxon"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE OrfAttributes&1 NOLOGGING AS
SELECT cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       SUBSTR(nl.feature_source_id, 1, 60) AS source_id,
       LOWER(SUBSTR(nl.feature_source_id, 1, 60)) AS lowercase_source_id,
       SUBSTR(tn.name, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       SUBSTR(sequence.source_id, 1, 30) AS nas_id,
       (nl.end_max - nl.start_min + 1)/3 as length,
       nl.start_min, nl.end_max, nl.is_reversed,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.chromosome_order_num,
       sequence.na_sequence_id,
       nl.na_feature_id
FROM sres.taxon, sres.TaxonName tn,
     sres.OntologyTerm oterm, FeatureLocation nl,
     ( select source_id, chromosome, chromosome_order_num, na_sequence_id, taxon_id
       from dots.ExternalNaSequence
      union
       select source_id, chromosome, chromosome_order_num, na_sequence_id, taxon_id
       from dots.VirtualSequence) sequence
WHERE sequence.na_sequence_id = nl.na_sequence_id
  AND sequence.taxon_id = tn.taxon_id
  AND sequence.taxon_id = taxon.taxon_id
  AND nl.sequence_ontology_id = oterm.ontology_term_id
  AND nl.is_top_level = 1
  AND oterm.name = 'ORF'
  AND tn.name_class='scientific name'
/*  AND nl.feature_type = 'Miscellaneous' */
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index OrfAttr_source_id&1 ON OrfAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index OrfAttr_location_idx&1 ON OrfAttributes&1 (na_sequence_id, start_min, end_max, is_reversed)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EstAttributes">
    <comment> Each row represents one EST. Used widely in the model, and to make the
         tuning tables BlastTypes, OrganismAbbreviationBlast, and OrganismAttributes.
     </comment>
    <internalDependency name="ProjectTaxon"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.Est"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="dots.Library"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE EstAttributes&1 NOLOGGING AS
SELECT cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ens.source_id,
       e.seq_primer AS primer,
       ens.a_count,
       ens.c_count,
       ens.g_count,
       ens.t_count,
       (ens.length - (ens.a_count + ens.c_count + ens.g_count + ens.t_count))
         AS other_count,
       ens.length,
       l.dbest_name,
       nvl(regexp_replace(l.vector, '^\s+$', null), 'unknown') AS vector,
       nvl(regexp_replace(l.stage, '^\s+$', null), 'unknown') AS stage,
       SUBSTR(CASE
                WHEN tn.name = 'Giardia lamblia' THEN 'Giardia Assemblage A isolate WB' 
                ELSE tn.name
              END, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       ed.name AS external_db_name,
       nvl(best.best_alignment_count, 0) AS best_alignment_count,
       l.library_id, l.dbest_name as library_dbest_name
FROM dots.Est e, dots.ExternalNaSequence ens, dots.Library l, sres.Taxon,
     sres.TaxonName tn, sres.ExternalDatabase ed,
     sres.ExternalDatabaseRelease edr, sres.OntologyTerm oterm,
     (select query_na_sequence_id,max(ct) as best_alignment_count
      from (
            SELECT query_na_sequence_id, COUNT(*) AS ct
             FROM dots.BlatAlignment ba
             WHERE is_best_alignment = 1
             GROUP BY target_external_db_release_id,query_na_sequence_id)
      group by query_na_sequence_id) best
WHERE e.na_sequence_id = ens.na_sequence_id
  AND e.library_id = l.library_id
  AND ens.taxon_id = tn.taxon_id
  AND ens.taxon_id = taxon.taxon_id
  AND tn.name_class='scientific name'
  AND ens.external_database_release_id = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ens.sequence_ontology_id = oterm.ontology_term_id
  AND oterm.name = 'EST'
  AND best.query_na_sequence_id(+) = ens.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index EstAttr_source_id&1 ON EstAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="BlatAlignmentLocation">
    <comment> Locations of BLAT alignments, both on the sequences they're annotated
         onto and also transitively through SequencePiece. Used in model and
         GBrowse queries, as well as in the creation of the tuning tables
         EstAlignmentGeneSummary.
     </comment>
    <internalDependency name="SequencePieceClosure"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[ 
      CREATE TABLE BlatAlignmentLocation&1 NOLOGGING AS
      SELECT blat_alignment_id, query_na_sequence_id, target_na_sequence_id,
             query_table_id, query_taxon_id, query_external_db_release_id,
             target_table_id, target_taxon_id, target_external_db_release_id,
             is_consistent, is_genomic_contaminant, unaligned_3p_bases,
             unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
             is_5p_complete, percent_identity, max_query_gap, max_target_gap,
             number_of_spans, query_start, query_end, target_start, target_end,
             is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
             is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
             tstarts, cast('direct' as varchar2(7)) as location_mapping
      FROM dots.BlatAlignment
      ]]> 
    </sql>
    <perl>
      <![CDATA[ 
      use strict;
      use lib "$ENV{GUS_HOME}/lib/perl";

      my $sql = <<SQL;
        select blat_alignment_id, query_na_sequence_id, target_na_sequence_id,
               query_table_id, query_taxon_id, query_external_db_release_id, 
               target_table_id, target_taxon_id, target_external_db_release_id,
               is_consistent, is_genomic_contaminant, unaligned_3p_bases,
               unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
               is_5p_complete, percent_identity, max_query_gap, max_target_gap,
               number_of_spans, query_start, query_end, target_start, target_end,
               is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
               is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
               tstarts, sp.virtual_na_sequence_id, sp.distance_from_left, sp.start_position, sp.end_position,
               sp.strand_orientation, piece.length, vti.table_id as virtual_target_table_id
        from dots.BlatAlignment ba, SequencePieceClosure sp, dots.NaSequence piece,
             dots.NaSequence virtualseq, core.TableInfo vti
        where ba.target_na_sequence_id = sp.piece_na_sequence_id(+)
          and sp.start_position <= target_start
          and sp.end_position >= target_end
          and ba.target_na_sequence_id = piece.na_sequence_id
          and sp.virtual_na_sequence_id = virtualseq.na_sequence_id
          and virtualseq.subclass_view = vti.name
SQL
      
      my $queryHandle = $dbh->prepare($sql) or die $dbh->errstr;
      $queryHandle->execute();

      $sql = <<SQL;
        insert into BlatAlignmentLocation&1(blat_alignment_id,
               query_na_sequence_id, target_na_sequence_id,
               query_table_id, query_taxon_id, query_external_db_release_id, 
               target_table_id, target_taxon_id, target_external_db_release_id,
               is_consistent, is_genomic_contaminant, unaligned_3p_bases,
               unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
               is_5p_complete, percent_identity, max_query_gap, max_target_gap,
               number_of_spans, query_start, query_end, target_start, target_end,
               is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
               is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
               tstarts, location_mapping)
         values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?)
SQL

      my $insertHandle = $dbh->prepare($sql) or die $dbh->errstr;
      my ($virtual_target_start, $virtual_target_end, $virtual_tstarts);

      while (my ($blat_alignment_id, $query_na_sequence_id, $target_na_sequence_id,
               $query_table_id, $query_taxon_id, $query_external_db_release_id,
               $target_table_id, $target_taxon_id, $target_external_db_release_id,
               $is_consistent, $is_genomic_contaminant, $unaligned_3p_bases,
               $unaligned_5p_bases, $has_3p_polya, $has_5p_polya, $is_3p_complete,
               $is_5p_complete, $percent_identity, $max_query_gap, $max_target_gap,
               $number_of_spans, $query_start, $query_end, $target_start, $target_end,
               $is_reversed, $query_bases_aligned, $repeat_bases_aligned, $num_ns, $score,
               $is_best_alignment, $blat_alignment_quality_id, $blocksizes, $qstarts,
               $tstarts, $virtual_na_sequence_id, $distance_from_left, $start_position, $end_position,
               $strand_orientation, $length, $virtual_target_table_id)
             = $queryHandle->fetchrow_array()) {

        if ($virtual_na_sequence_id) {
          if ($strand_orientation eq '-') {
            $virtual_target_start = $distance_from_left + $end_position - $target_end + 1;
            $virtual_target_end = $distance_from_left + $end_position - $target_start + 1;
            $virtual_tstarts = &getReversedTstarts($distance_from_left,$end_position,$tstarts,$blocksizes);
            $blocksizes = join(',', reverse split(',', $blocksizes));
            $is_reversed = $is_reversed == 1 ? 0 : 1;
          } else {
            $virtual_target_start = $target_start + $distance_from_left - $start_position + 1;
            $virtual_target_end = $target_end + $distance_from_left - $start_position + 1;
            $virtual_tstarts = join( ',', map{ $_ + $distance_from_left - $start_position + 1 } split( /,/, $tstarts));
          }

          # insert virtual locations
          $insertHandle->execute($blat_alignment_id,
                 $query_na_sequence_id, $virtual_na_sequence_id,
                 $query_table_id, $query_taxon_id, $query_external_db_release_id,
                 $virtual_target_table_id, $target_taxon_id, $target_external_db_release_id,
                 $is_consistent, $is_genomic_contaminant, $unaligned_3p_bases,
                 $unaligned_5p_bases, $has_3p_polya, $has_5p_polya, $is_3p_complete,
                 $is_5p_complete, $percent_identity, $max_query_gap, $max_target_gap,
                 $number_of_spans, $query_start, $query_end, $virtual_target_start,
                 $virtual_target_end,
                 $is_reversed, $query_bases_aligned, $repeat_bases_aligned, $num_ns, $score,
                 $is_best_alignment, $blat_alignment_quality_id, $blocksizes, $qstarts,
                 $virtual_tstarts, 'virtual');
        }
      }

      $insertHandle->finish();
      $queryHandle->finish();

sub getReversedTstarts {
  my($dfl,$len,$tstart,$blocksizes) = @_;
  my @ts = split(',',$tstart);
  my @bs = split(',',$blocksizes);
  my @new;
  
  for(my $a = scalar(@ts) - 1;$a >= 0;$a--){
    push(@new,($dfl + $len - $ts[$a] - $bs[$a] + 2));
  }
  return join(',',@new);
}
      ]]> 
    </perl>
  </tuningTable>


  <tuningTable name="BlatProtAlignLocation">
    <comment> BLAT protein alignments. Used by GBrowse for the track proteinAlignment:BLAT
     </comment>
    <internalDependency name="SequencePieceClosure"/>
    <externalDependency name="apidb.BlatProteinAlignment"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.NaSequence"/>
    <sql>
      <![CDATA[ 
      CREATE TABLE BlatProtAlignLocation&1 NOLOGGING AS
      SELECT blat_protein_alignment_id, query_aa_sequence_id, target_na_sequence_id,
             query_table_id, query_taxon_id, query_external_db_release_id,
             target_table_id, target_taxon_id, target_external_db_release_id,
             is_consistent, is_genomic_contaminant, unaligned_3p_bases,
             unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
             is_5p_complete, percent_identity, max_query_gap, max_target_gap,
             number_of_spans, query_start, query_end, target_start, target_end,
             is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
             is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
             tstarts, cast('direct' as varchar2(7)) as location_mapping
      FROM apidb.BlatProteinAlignment
      ]]> 
    </sql>
    <perl>
      <![CDATA[ 
      use strict;
      use lib "$ENV{GUS_HOME}/lib/perl";

      my $sql = <<SQL;
        select blat_protein_alignment_id, query_aa_sequence_id, target_na_sequence_id,
               query_table_id, query_taxon_id, query_external_db_release_id, 
               target_table_id, target_taxon_id, target_external_db_release_id,
               is_consistent, is_genomic_contaminant, unaligned_3p_bases,
               unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
               is_5p_complete, percent_identity, max_query_gap, max_target_gap,
               number_of_spans, query_start, query_end, target_start, target_end,
               is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
               is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
               tstarts, sp.virtual_na_sequence_id, sp.distance_from_left, sp.start_position, sp.end_position,
               sp.strand_orientation, piece.length, vti.table_id as virtual_target_table_id
        from apidb.blatproteinalignment ba, SequencePieceClosure sp, dots.NaSequence piece,
             dots.NaSequence virtualseq, core.TableInfo vti
        where ba.target_na_sequence_id = sp.piece_na_sequence_id(+)
          and sp.start_position <= target_start
          and sp.end_position >= target_end
          and ba.target_na_sequence_id = piece.na_sequence_id
          and sp.virtual_na_sequence_id = virtualseq.na_sequence_id
          and virtualseq.subclass_view = vti.name
SQL
      
      my $queryHandle = $dbh->prepare($sql) or die $dbh->errstr;
      $queryHandle->execute();

      $sql = <<SQL;
        insert into BlatProtAlignLocation&1(blat_protein_alignment_id,
               query_aa_sequence_id, target_na_sequence_id,
               query_table_id, query_taxon_id, query_external_db_release_id, 
               target_table_id, target_taxon_id, target_external_db_release_id,
               is_consistent, is_genomic_contaminant, unaligned_3p_bases,
               unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
               is_5p_complete, percent_identity, max_query_gap, max_target_gap,
               number_of_spans, query_start, query_end, target_start, target_end,
               is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
               is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
               tstarts, location_mapping)
         values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?)
SQL

      my $insertHandle = $dbh->prepare($sql) or die $dbh->errstr;
      my ($virtual_target_start, $virtual_target_end, $virtual_tstarts);

      while (my ($blat_protein_alignment_id, $query_aa_sequence_id, $target_na_sequence_id,
               $query_table_id, $query_taxon_id, $query_external_db_release_id,
               $target_table_id, $target_taxon_id, $target_external_db_release_id,
               $is_consistent, $is_genomic_contaminant, $unaligned_3p_bases,
               $unaligned_5p_bases, $has_3p_polya, $has_5p_polya, $is_3p_complete,
               $is_5p_complete, $percent_identity, $max_query_gap, $max_target_gap,
               $number_of_spans, $query_start, $query_end, $target_start, $target_end,
               $is_reversed, $query_bases_aligned, $repeat_bases_aligned, $num_ns, $score,
               $is_best_alignment, $blat_alignment_quality_id, $blocksizes, $qstarts,
               $tstarts, $virtual_na_sequence_id, $distance_from_left, $start_position, $end_position,
               $strand_orientation, $length, $virtual_target_table_id)
             = $queryHandle->fetchrow_array()) {

        if ($virtual_na_sequence_id) {
          if ($strand_orientation eq '-') {
            $virtual_target_start = $distance_from_left + $end_position - $target_end + 1;
            $virtual_target_end = $distance_from_left + $end_position - $target_start + 1;
            $virtual_tstarts = &getReversedTstarts($distance_from_left,$end_position,$tstarts,$blocksizes);
            $blocksizes = join(',', reverse split(',', $blocksizes));
            $is_reversed = $is_reversed == 1 ? 0 : 1;
          } else {
            $virtual_target_start = $target_start + $distance_from_left - $start_position + 1;
            $virtual_target_end = $target_end + $distance_from_left - $start_position + 1;
            $virtual_tstarts = join( ',', map{ $_ + $distance_from_left - $start_position + 1 } split( /,/, $tstarts));
          }

          # insert virtual locations
          $insertHandle->execute($blat_protein_alignment_id,
                 $query_aa_sequence_id, $virtual_na_sequence_id,
                 $query_table_id, $query_taxon_id, $query_external_db_release_id,
                 $virtual_target_table_id, $target_taxon_id, $target_external_db_release_id,
                 $is_consistent, $is_genomic_contaminant, $unaligned_3p_bases,
                 $unaligned_5p_bases, $has_3p_polya, $has_5p_polya, $is_3p_complete,
                 $is_5p_complete, $percent_identity, $max_query_gap, $max_target_gap,
                 $number_of_spans, $query_start, $query_end, $virtual_target_start,
                 $virtual_target_end,
                 $is_reversed, $query_bases_aligned, $repeat_bases_aligned, $num_ns, $score,
                 $is_best_alignment, $blat_alignment_quality_id, $blocksizes, $qstarts,
                 $virtual_tstarts, 'virtual');
        }
      }

      $insertHandle->finish();
      $queryHandle->finish();

      # create index
      $dbh->do(<<SQL) or die $dbh->errstr;
        create index bpal&1
          on BlatProtAlignLocation&1
          (target_na_sequence_id, target_start, target_end, blat_protein_alignment_id,
           score, is_reversed, query_aa_sequence_id, percent_identity)
SQL

sub getReversedTstarts {
  my($dfl,$len,$tstart,$blocksizes) = @_;
  my @ts = split(',',$tstart);
  my @bs = split(',',$blocksizes);
  my @new;

  for(my $a = scalar(@ts) - 1;$a >= 0;$a--){
    push(@new,($dfl + $len - $ts[$a] - $bs[$a] + 2));
  }
  return join(',',@new);
}
      ]]> 
    </perl>
  </tuningTable>


  <tuningTable name="EstAlignmentGeneSummary">
    <comment> Each row represents a colocated EST alignment - gene pair. Used by the
         model, by generateGeneMetrics, and in the creation of the
         OrganismAttributes tuning table
     </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="BlatAlignmentLocation"/>
    <externalDependency name="dots.AssemblySequence"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.Est"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.OntologyTerm"/>
    <intermediateTable name="EstAlignmentGene"/>
    <intermediateTable name="EstAlignmentNoGene"/>
    <sql>
      <![CDATA[
CREATE TABLE EstAlignmentGene NOLOGGING AS
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, e.accession,
         e.library_id, ba.query_taxon_id, ba.target_na_sequence_id,
         ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
         ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
         sequence.source_id AS target_sequence_source_id,
         least(ba.target_end, ga.gene_end_max)
         - greatest(ba.target_start, ga.gene_start_min) + 1
           AS est_gene_overlap_length,
         ba.query_bases_aligned / (query_sequence.length)
         * 100 AS percent_est_bases_aligned,
         ga.gene_source_id AS gene
  FROM BlatAlignmentLocation ba, dots.Est e, dots.AssemblySequence aseq,
       TranscriptAttributes ga, GenomicSequence sequence,
       dots.NaSequence query_sequence, sres.OntologyTerm so
  WHERE e.na_sequence_id = ba.query_na_sequence_id
    AND aseq.na_sequence_id = ba.query_na_sequence_id
    AND sequence.na_sequence_id = ba.target_na_sequence_id
    AND ga.sequence_id = sequence.source_id
    AND least(ba.target_end, ga.gene_end_max) - greatest(ba.target_start, ga.gene_start_min) >= 0
    AND query_sequence.na_sequence_id = ba.query_na_sequence_id
    AND query_sequence.sequence_ontology_id = so.ontology_term_id
    AND so.name = 'EST'
    AND ba.target_na_sequence_id = sequence.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE EstAlignmentNoGene NOLOGGING AS
SELECT * from EstAlignmentGene WHERE 1=0 UNION /* define datatype for null column */
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, e.accession,
       e.library_id, ba.query_taxon_id, ba.target_na_sequence_id,
       ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
       ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
       sequence.source_id AS target_sequence_source_id,
       NULL AS est_gene_overlap_length,
       ba.query_bases_aligned / (query_sequence.length)
       * 100 AS percent_est_bases_aligned,
       NULL AS gene
FROM dots.BlatAlignment ba, dots.Est e, dots.AssemblySequence aseq,
     dots.NaSequence sequence, dots.NaSequence query_sequence
WHERE e.na_sequence_id = ba.query_na_sequence_id
  AND e.na_sequence_id = query_sequence.na_sequence_id
  AND aseq.na_sequence_id = ba.query_na_sequence_id
  AND ba.target_na_sequence_id = sequence.na_sequence_id
  AND ba.blat_alignment_id IN
   ( /* set of blat_alignment_ids not in in first leg of UNION */
    /* (because they overlap no genes) */
    SELECT ba.blat_alignment_id
    FROM dots.BlatAlignment ba, dots.NaSequence query_sequence,
         sres.OntologyTerm so
    WHERE query_sequence.na_sequence_id = ba.query_na_sequence_id
      AND query_sequence.sequence_ontology_id = so.ontology_term_id
      AND so.name = 'EST'
  MINUS
    SELECT blat_alignment_id FROM EstAlignmentGene)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE EstAlignmentGeneSummary&1 NOLOGGING AS
SELECT * FROM EstAlignmentNoGene
UNION
SELECT * FROM EstAlignmentGene
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index EstSumm_libOverlap_ix&1
             ON EstAlignmentGeneSummary&1
                (library_id, percent_identity, is_consistent,
                 est_gene_overlap_length, percent_est_bases_aligned)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index EstSumm_estSite_ix&1
             ON EstAlignmentGeneSummary&1
                (target_sequence_source_id, target_start, target_end,
                 library_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

<!--
  <tuningTable name="SnpStrains">
    <comment> Each record captures info for an (organism, strain,
         external_database_release_id) 3-tuple. Used in the model, including
         gene and SNP queries, as well as the gene record. Also used by the
         FindPolymorphismsPlugin in the workflow.
     </comment>
    <internalDependency name="OrganismAttributes"/>
    <externalDependency name="apidb.Snp"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
CREATE TABLE SnpStrains&1 NOLOGGING AS
SELECT s.name as study_name
     , oa.organism_name as organism
     , b.name as strain
     , sd.name as study_db_name
     , bd.name as biosample_db_name
     , sr.external_database_release_id
     , ds.taxon_id
from  study.study s
    , rad.studybiomaterial sb
    , study.biosample b
    , sres.externaldatabase sd
    , sres.externaldatabaserelease sr
    , sres.externaldatabase bd
    , sres.externaldatabaserelease br
    , apidb.datasource ds
    , organismattributes oa
WHERE s.study_id = sb.study_id
  and s.external_database_release_id = sr.external_database_release_id
  and sr.external_database_id = sd.external_database_id
  and sb.bio_material_id = b.bio_material_id
  and b.external_database_release_id = br.external_database_release_id
  and br.external_database_id = bd.external_database_id
  and sd.name = ds.name
  and oa.component_taxon_id = ds.taxon_id
  and ds.type = 'isolates' 
  and ds.subtype = 'HTS_SNP'
UNION /* use union to get the reference strain */
SELECT distinct s.name as study_name
     , oa.organism_name as organism
     , o.strain_abbrev as strain
     , sd.name as study_db_name
     , sd.name as biosample_db_name
     , sr.external_database_release_id
     , ds.taxon_id
from  study.study s
    , rad.studybiomaterial sb
    , study.biosample b
    , sres.externaldatabase sd
    , sres.externaldatabaserelease sr
    , sres.externaldatabase bd
    , sres.externaldatabaserelease br
    , apidb.datasource ds
    , organismattributes oa
    , apidb.organism o
WHERE s.study_id = sb.study_id
  and s.external_database_release_id = sr.external_database_release_id
  and sr.external_database_id = sd.external_database_id
  and sb.bio_material_id = b.bio_material_id
  and b.external_database_release_id = br.external_database_release_id
  and br.external_database_id = bd.external_database_id
  and sd.name = ds.name
  and oa.component_taxon_id = ds.taxon_id
  and oa.source_id = o.abbrev
  and ds.type = 'isolates' 
  and ds.subtype = 'HTS_SNP'
/**
SELECT distinct var.strain,
       sa.organism,
       snp.external_database_release_id,
       d.name as extdb_name, vd.name as var_extdb_name, sa.taxon_id
FROM   apidb.snp snp, 
       apidb.sequencevariation var,     
       GenomicSequenceAttributes sa,
       sres.ExternalDatabase d, 
       sres.ExternalDatabaseRelease rel,
       sres.ExternalDatabase vd, 
       sres.ExternalDatabaseRelease vrel
WHERE  sa.na_sequence_id = snp.na_sequence_id
   AND snp.location = var.location
   and snp.na_sequence_id = var.ref_na_sequence_id
   AND snp.external_database_release_id = rel.external_database_release_id
   AND rel.external_database_id = d.external_database_id
   AND var.external_database_release_id = vrel.external_database_release_id
   AND vrel.external_database_id = vd.external_database_id
*/



      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX SnpStrains_ix&1 ON SnpStrains&1(study_db_name,external_database_release_id,strain,organism)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="SnpChipStrains">
    <comment> Each record captures info for an (organism, strain,
         external_database_release_id) 3-tuple. Used in the model, including
         gene and SNP queries, as well as the gene record. Also used by the
         FindPolymorphismsPlugin in the workflow.
     </comment>
    <internalDependency name="GenomicSequenceAttributes"/>
    <externalDependency name="dots.SnpFeature"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
CREATE TABLE SnpChipStrains&1 NOLOGGING AS
SELECT distinct bmc.value as strain, sa.organism, 
       snp.name, snp.external_database_release_id, 
       bs.name as isolate_id, 
       ed.name as extdb_name, sa.taxon_id
FROM   study.study s,
       RAD.STUDYBIOMATERIAL sbm,
       study.biosample bs,
       STUDY.BIOMATERIALCHARACTERISTIC bmc,
       Study.Ontologyentry oe,
       GenomicSequenceAttributes sa,
       dots.snpfeature snp,
       sres.externaldatabase ed, 
       sres.externaldatabaserelease edr
WHERE  s.study_id = sbm.study_id
   AND bs.BIO_MATERIAL_ID = sbm.BIO_MATERIAL_ID
   AND bmc.BIO_MATERIAL_ID = bs.BIO_MATERIAL_ID
   AND edr.external_database_id = ed.external_database_id
   AND s.external_database_release_id = edr.external_database_release_id
   /*AND bmc.ONTOLOGY_ENTRY_ID = 96  strain */
   AND oe.category = 'BioMaterialCharacteristics'
   AND oe.value = 'StrainOrLine'
   and Bmc.Ontology_Entry_Id = Oe.Ontology_Entry_Id
   AND snp.NA_SEQUENCE_ID = sa.na_sequence_id
   AND snp.EXTERNAL_DATABASE_RELEASE_ID = edr.external_database_release_id
   AND snp.name in ('Broad_barcode','Broad_3k_chip','Broad_hd_array')

/**
  SELECT distinct sv.strain,
                  sa.organism,
                  sf.name,
                  sf.external_database_release_id,
                  d.name as extdb_name, vd.name as var_extdb_name, sa.taxon_id
  FROM   dots.SnpFeature sf, 
         (select strain, external_database_release_id, max(parent_id) as parent_id
          from dots.SeqVariation
          group by strain, external_database_release_id) sv, 
         GenomicSequenceAttributes sa,
         sres.ExternalDatabase d, 
         sres.ExternalDatabaseRelease rel,
         sres.ExternalDatabase vd, 
         sres.ExternalDatabaseRelease vrel
  WHERE sa.na_sequence_id = sf.na_sequence_id
    AND sf.na_feature_id = sv.parent_id
    AND sf.external_database_release_id = rel.external_database_release_id
    AND rel.external_database_id = d.external_database_id
    AND sv.external_database_release_id = vrel.external_database_release_id
    AND vrel.external_database_id = vd.external_database_id
    AND sf.name in ('Broad_barcode', 'Broad_3k_chip', 'Broad_hd_array')
*/
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX SnpChipStrains_ix&1 ON SnpChipStrains&1(extdb_name,external_database_release_id,strain,organism)
tablespace indx
      ]]>
    </sql>
  </tuningTable>




  <tuningTable name="IsolateAttributes">
    <comment> The BFMV for the WDK isolate record. Widely used in the model for
         queries related to isolates (including gene and SNP queries as well as
         isolate queries). Used as input in the creation of half a dozen other
         tuning tables, including GeneIsolateOverlap, IsolateSequence,
         IsolateSNPs, OrganismAttributes, SnpsWithIsolates, and TajimasStats.
         Aggregated into portal instances for use in the portal site.
     </comment>
    <internalDependency name="GenomicSequenceAttributes"/>
    <externalDependency name="apidb.IsolateMapping"/>
    <externalDependency name="apidb.IsolateVocabulary"/>
    <externalDependency name="apidb.VocabularyBiomaterial"/>
    <externalDependency name="apidb.IsolateGPS"/>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="dots.isolatefeature"/>
    <externalDependency name="dots.IsolateSource"/>
    <externalDependency name="rad.StudyBiomaterial"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.BiomaterialCharacteristic"/>
    <externalDependency name="study.Biosource"/>
    <externalDependency name="study.Biosample"/>
    <externalDependency name="study.OntologyEntry"/>
    <externalDependency name="study.Study"/>
    <sql>
      <![CDATA[
CREATE TABLE IsolateAttributes&1 NOLOGGING AS
select null as na_sequence_id,
       null as na_feature_id,
       b.bio_material_id,
       o.taxon_id,
       edr.version as external_db_version,
       ed.name as external_db_name,
       expt_edr.version AS experiment_external_db_version,
       expt_ed.name AS experiment_external_db_name,
       b.source_id,
       nvl(o.name, 'Unknown') as organism,
       nvl(strain.strain, 'Unknown') as strain,
       nvl(host.value, 'Unknown') as specific_host,
       nvl(isolation_source.value, 'Unknown') as isolation_source,
       nvl(geographic_location.value, 'Unknown') as geographic_location,
      'N/A' as product,
       null as note,
       /*b.description,  */
       null as description,
       null as is_reference,
       project.name as project_id,
       'SNP' as data_type,
       host.annotated_value as annotated_specific_host,
       isolation_source.annotated_value as annotated_isolation_source,
       geographic_location.annotated_value as annotated_geographic_location,
       0 as lat,
       0 as lng,
       nvl(geographic_location.value, 'Unknown') as country,
       null as length, 
       null as pcr_primers, 
       null as collected_by
 From /* study.Biosource b,  */
     study.biomaterial b,
     study.Study s, sres.ExternalDatabase expt_ed, sres.ExternalDatabaseRelease expt_edr,
     rad.StudyBiomaterial sb, sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr,
     (

select distinct bs.bio_material_id, tn.name, tn.taxon_id
from study.OntologyEntry oe,
     study.BiomaterialCharacteristic bmc,
     study.biomaterial bs,
     sres.TaxonName tn
where oe.category = 'BioMaterialCharacteristics'
  and oe.value = 'Organism'
  and  bmc.ontology_entry_id = oe.ontology_entry_id
  and Bmc.Bio_Material_Id = bs.Bio_Material_Id
  and bmc.value = tn.name 
      ) o,
     (
select distinct bmc.bio_material_id, sample.name as strain
from study.OntologyEntry oe,
     study.BiomaterialCharacteristic bmc,
     study.biomaterial bs,
     study.biosample sample
where oe.category = 'BioMaterialCharacteristics'
  and oe.value = 'StrainOrLine'
  and bmc.ontology_entry_id = oe.ontology_entry_id
  and bmc.Bio_Material_Id = bs.Bio_Material_Id
  AND sample.external_database_release_id = bs.external_database_release_id
      ) strain,
     (
select distinct bs.bio_material_id,  bmc.value, bmc.value as  annotated_value
from study.OntologyEntry oe, 
     study.BiomaterialCharacteristic bmc,
     study.biomaterial bs
where oe.category = 'EnvironmentalHistory'
  and oe.value = 'Host'
  and bmc.ontology_entry_id = oe.ontology_entry_id
  and Bmc.Bio_Material_Id = bs.Bio_Material_Id 
     ) host,
     (
select distinct bs.bio_material_id,  bmc.value, bmc.value  as annotated_value
from study.OntologyEntry oe,
     study.BiomaterialCharacteristic bmc,
     study.biomaterial bs
where oe.category = 'BioMaterialCharacteristics'
  and oe.value = 'BioSourceType'
  and bmc.ontology_entry_id = oe.ontology_entry_id
  and Bmc.Bio_Material_Id = bs.Bio_Material_Id 
      ) isolation_source,
     (
select distinct bs.bio_material_id,  bmc.value, bmc.value as  annotated_value
from study.OntologyEntry oe, 
     study.BiomaterialCharacteristic bmc,
     study.biomaterial bs
where oe.category = 'Sample Collection Location'
  and oe.value = 'GeographicLocation'
  and bmc.ontology_entry_id = oe.ontology_entry_id
  and Bmc.Bio_Material_Id = bs.Bio_Material_Id 
      ) geographic_location,
     (select name, project_id from core.projectInfo) project
where lower(s.name) like '%_hts%'
and b.row_project_id = project.project_id
and s.study_id = sb.study_id
and s.external_database_release_id = expt_edr.external_database_release_id
and expt_edr.external_database_id = expt_ed.external_database_id
and sb.bio_material_id = b.bio_material_id
and b.external_database_release_id = edr.external_database_release_id
and edr.external_database_id = ed.external_database_id
and b.bio_material_id = o.bio_material_id (+)
and b.bio_material_id = strain.bio_material_id (+)
and b.bio_material_id = host.bio_material_id (+)
and b.bio_material_id = isolation_source.bio_material_id (+)
and b.bio_material_id = geographic_location.bio_material_id (+)
UNION /* sequence typed isolate  */
select i.na_sequence_id,
       i.na_feature_id,
       null as bio_material_id,
       i.taxon_id,
       i.external_db_version,
       i.external_db_name,
       '' AS experiment_external_db_version,
       '' AS experiment_external_db_name,
       i.source_id,
       decode(i.organism, null, 'Unknown', substr(i.organism, 1, 100)) as organism,
       decode(i.strain, null, 'Unknown', substr(i.strain, 1, 100)) as strain,
       decode(i.specific_host, null, 'Unknown', substr(i.specific_host, 1, 100)) as specific_host,
       decode(i.isolation_source, null, 'Unknown', substr(i.isolation_source, 1, 200)) as isolation_source,
       decode(i.country, null, 'Unknown', substr(i.country, 1, 200)) as geographic_location,
       nvl(nvl(prod.product, prod.gene), 'Unknown') as product,
       substr(i.note, 1, 400) as note,
       substr(i.description, 1, 400) as description,
       i.is_reference,
       i.project_id,
       i.data_type,
       s_h.annotated_specific_host,
       i_s.annotated_isolation_source,
       g_l.annotated_geographic_location,
       0 as lat,
       0 as lng,
       nvl(g_l.annotated_geographic_location, 'Unknown') as country,
       i.length, 
       i.pcr_primers, 
       i.collected_by
FROM (
       SELECT  etn.na_sequence_id,
               etn.taxon_id,
               etn.length,
               edr.version as external_db_version, 
               src.na_feature_id,
               edb.name as external_db_name,
               '' AS experiment_external_db_version,
               '' AS experiment_external_db_name,
               CASE 
                 WHEN etn.source_id is null 
                   THEN decode(edb.name,
                                         'pfal3D7_SNPChip_Broad75KGenotyping_RSRC', 'CPHD.'||strain,
                                         'pfal3D7_SNPChip_Broad3KGenotyping_RSRC', 'CP3.'||strain,
                                         'pfal3D7_SNPChip_BroadIsolateBarcode_RSRC','BC.'||strain,
                                         'Isolate barcode data from Broad','BC.'||strain)
                ELSE etn.source_id 
              END as source_id,
              tn.name as organism,
              CASE 
                WHEN src.strain != src.isolate 
                  THEN src.strain || ' ' || src.isolate 
                WHEN src.strain is  not null 
                  THEN src.strain
                ELSE src.isolate 
              END as strain,
              src.specific_host as specific_host,
              src.isolation_source as isolation_source,
              src.country as country,
              src.note as note,
              etn.description as description,
              src.pcr_primers,
              src.collected_by,
              src.is_reference,
              decode(edb.name,
                               'pfal3D7_SNPChip_Broad75KGenotyping_RSRC', 'HD_Array',
                               'pfal3D7_SNPChip_Broad3KGenotyping_RSRC', 'SNP (3kChip)',
                               'pfal3D7_SNPChip_BroadIsolateBarcode_RSRC','SNP (Barcode)',
                               'tgonME49_isolates_ChunleiSu_RFLP_RSRC', 'RFLP Typed',
                               'tgonME49_isolates_Menezes_chicken_RFLP_RSRC', 'RFLP Typed',
                               'Sequencing Typed') as data_type,
                pinfo.name as project_id
      FROM dots.ExternalNaSequence etn, dots.IsolateSource src,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase edb, core.ProjectInfo pinfo, 
           (select  distinct taxon_id,name from sres.TaxonName where name_class = 'scientific name') tn
      WHERE etn.na_sequence_id = src.na_sequence_id
       AND  etn.taxon_id = tn.taxon_id(+)
       AND edr.external_database_id = edb.external_database_id
       AND edr.external_database_release_id = etn.external_database_release_id
       AND pinfo.project_id = etn.row_project_id
      ) i,
      (select im.na_sequence_id, apidb.tab_to_string(set(cast(COLLECT(iv.term) as apidb.varchartab)),',') as annotated_isolation_source
      from apidb.IsolateVocabulary iv, apidb.IsolateMapping im
      where iv.isolate_vocabulary_id = im.isolate_vocabulary_id
      and iv.type = 'isolation_source'
      group by im.na_sequence_id
      ) i_s,
      (select im.na_sequence_id, apidb.tab_to_string(set(cast(COLLECT(iv.term) as apidb.varchartab)),',') as annotated_specific_host
      from apidb.IsolateVocabulary iv, apidb.IsolateMapping im
      where iv.isolate_vocabulary_id = im.isolate_vocabulary_id
      and iv.type = 'specific_host'
      group by im.na_sequence_id
      ) s_h,
      (select im.na_sequence_id, apidb.tab_to_string(set(cast(COLLECT(iv.term) as apidb.varchartab)),',') as annotated_geographic_location
      from apidb.IsolateVocabulary iv, apidb.IsolateMapping im
      where iv.isolate_vocabulary_id = im.isolate_vocabulary_id
      and iv.type = 'geographic_location'
      group by im.na_sequence_id
      ) g_l,
      (select na_sequence_id,
              apidb.tab_to_string(set(cast(COLLECT(product order by product) as apidb.varchartab)),'; ') as product,
              apidb.tab_to_string(set(cast(COLLECT(gene order by gene) as apidb.varchartab)),'; ') as gene
       from dots.IsolateFeature group by na_sequence_id
      ) prod
WHERE i.na_sequence_id = i_s.na_sequence_id
and i.na_sequence_id = s_h.na_sequence_id
and i.na_sequence_id = g_l.na_sequence_id
and i.na_sequence_id = prod.na_sequence_id (+)
UNION /* SNPChip: similar to HTS SNPs except metadata are loaded differently */
select distinct null as na_sequence_id,
       null as na_feature_id,
       0 as bio_material_id,
       o.taxon_id,
       '' as external_db_version,
       '' as external_db_name,
       '' AS experiment_external_db_version,
       '' AS experiment_external_db_name,
       bs.name || '_' || 
       case when ed.name = 'pfal3D7_SNPChip_Broad75KGenotyping_RSRC' then 'HD_Array'  
            when ed.name = 'pfal3D7_SNPChip_Broad3KGenotyping_RSRC' then '3kChip'  
            when ed.name = 'pfal3D7_SNPChip_BroadIsolateBarcode_RSRC' then 'Barcode'  
            else ''
       end as source_id,
       nvl(o.name, 'Unknown') as organism,
       nvl(strain.strain, 'Unknown') as strain,
       'Unknown' as specific_host,
       'Unknown' as isolation_source,
       nvl(geographic_location.value, 'Unknown') as geographic_location,
      'N/A' as product,
       '' as note,
       '' as description,
       0 as is_reference,
       'PlasmoDB' as project_id,
       case when ed.name = 'pfal3D7_SNPChip_Broad75KGenotyping_RSRC' then 'HD_Array'  
            when ed.name = 'pfal3D7_SNPChip_Broad3KGenotyping_RSRC' then '3kChip'  
            when ed.name = 'pfal3D7_SNPChip_BroadIsolateBarcode_RSRC' then 'Barcode'  
            else 'SNPChip'
       end as data_type,
       'Unknown' as annotated_specific_host,
       'Unknown' as annotated_isolation_source,
       geographic_location.annotated_value as annotated_geographic_location,
       0 as lat,
       0 as lng,
       nvl(geographic_location.value, 'Unknown') as country,
       null as length, 
       null as pcr_primers, 
       null as collected_by
FROM study.study s, 
     rad.studybiomaterial sb,
     study.biosample bs,
     sres.ExternalDatabase ed, 
     sres.ExternalDatabaseRelease edr,
    ( SELECT bmc.value as strain, bmc.bio_material_id
      FROM  study.study s,
            rad.studybiomaterial sbm,
            study.biosample bs,
            study.biomaterialcharacteristic bmc,
            study.ontologyentry oe
      WHERE s.study_id = sbm.study_id
        AND bs.BIO_MATERIAL_ID = sbm.BIO_MATERIAL_ID
        AND bmc.BIO_MATERIAL_ID = bs.BIO_MATERIAL_ID
        AND oe.ontology_entry_id = bmc.ONTOLOGY_ENTRY_ID
        AND oe.category = 'BioMaterialCharacteristics' 
        AND oe.value = 'StrainOrLine' 
    ) strain,
    ( SELECT tn.name, tn.taxon_id, bmc.bio_material_id
      FROM  study.study s,
            rad.studybiomaterial sbm,
            study.biosample bs,
            study.biomaterialcharacteristic bmc,
            study.ontologyentry oe,
            sres.taxonName tn
      WHERE s.study_id = sbm.study_id
        AND bs.BIO_MATERIAL_ID = sbm.BIO_MATERIAL_ID
        AND bmc.BIO_MATERIAL_ID = bs.BIO_MATERIAL_ID
        AND oe.ontology_entry_id = bmc.ONTOLOGY_ENTRY_ID
        AND oe.category = 'BioMaterialCharacteristics' 
        AND oe.value = 'Organism' 
        AND tn.name = bmc.value ) o,
    ( SELECT distinct bmc.bio_material_id, bmc.value, bmc.value as annotated_value
      FROM  study.study s,
            rad.studybiomaterial sbm,
            study.biosample bs,
            study.biomaterialcharacteristic bmc,
            study.ontologyentry oe
      WHERE s.study_id = sbm.study_id
        AND bs.BIO_MATERIAL_ID = sbm.BIO_MATERIAL_ID
        AND bmc.BIO_MATERIAL_ID = bs.BIO_MATERIAL_ID
        AND oe.ontology_entry_id = bmc.ONTOLOGY_ENTRY_ID
        AND oe.category = 'Sample Collection Location' 
        AND oe.value = 'GeographicLocation' 
    ) geographic_location
WHERE s.study_id = sb.study_id
  and bs.BIO_MATERIAL_ID = sb.BIO_MATERIAL_ID
  and s.external_database_release_id = edr.external_database_release_id
  and edr.external_database_id = ed.external_database_id
  and ed.name like '%SNPChip%'
  and sb.bio_material_id = strain.bio_material_id(+)
  and sb.bio_material_id = o.bio_material_id(+)
  and sb.bio_material_id = geographic_location.bio_material_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index IsolateAttr_sourceId_idx&1 ON IsolateAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>

     <sql>
       <![CDATA[
update IsolateAttributes&1 a
set (a.lat, a.lng, a.country) = (select g.lat, g.lng, g.country
                                 from apidb.IsolateGPS g 
                                 where regexp_like ( a.annotated_geographic_location, g.country, 'i' ) 
                                   and rownum = 1
                                  )
       ]]>
     </sql>

  </tuningTable>

  <tuningTable name="ChIPProtocolParams">
    <comment> Used by the GenesByChipChip(Plasmo|Toxo) query, as well as by GBrowse.
     </comment>
    <externalDependency name="rad.Analysis"/>
    <externalDependency name="rad.AnalysisParam"/>
    <externalDependency name="rad.ProtocolParam"/>
    <sql>
      <![CDATA[
        create table ChIPProtocolParams&1 NOLOGGING AS
select pp.*, e.experiment_name from
(
select a.analysis_id,
       a.protocol_id,
       antbd.antibody as antibody,
       strn.strain as strain,
       treamnt.treatment as treatment,
       replcte.replicate as replicate,
       gentyp.genotype as genotype,
       celltyp.celltype as celltype,
       CASE
          WHEN lower(p.name) like '%peak%' then 'called_peaks'
       ELSE 'raw'
       END as protocol_type
from   rad.analysis a,rad.protocol p,
      (select ap.analysis_id,ap.value as antibody
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'antibody') antbd,
      (select ap.analysis_id,ap.value as strain
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'strain') strn,
      (select ap.analysis_id,ap.value as treatment
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'treatment') treamnt,
      (select ap.analysis_id,ap.value as replicate
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'replicate') replcte,
      (select ap.analysis_id,ap.value as genotype
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'genotype') gentyp,
      (select ap.analysis_id,ap.value as celltype
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'celltype') celltyp
where a.protocol_id = p.protocol_id
and p.name in ('ChIP chip Smoothed',
               'ChIP chip Peak Calls',
                /* legacy ones too */
                'NimbleScan_ChIP_Hakimi_called_peaks',
                'NimbleScan_ChIP_Hakimi',
                'NimbleGen_ChIP_Myler_Lmajor',
                'ChIP_chip_Einstein',
                'ChIP_chip_Einstein_called_peaks',
                'ChIP_chip_Einstein_ME1',
                'ChIP_chip_Einstein_ME1_Peak_Calls')
and   a.analysis_id = antbd.analysis_id (+)
and   a.analysis_id = strn.analysis_id (+)
and   a.analysis_id = treamnt.analysis_id (+)
and   a.analysis_id = replcte.analysis_id (+)
and   a.analysis_id = gentyp.analysis_id (+)
and   a.analysis_id = celltyp.analysis_id (+)
) pp, (
select replace(d.name, '_' || a.name || '_chipChipSample_RSRC', '') as experiment_name, a.analysis_id
from sres.ExternalDatabase d, rad.analysis a
where d.name like '%' || a.name ||'%_chipChipSample_RSRC') e
where pp.analysis_id = e.analysis_id (+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index chp_prtparam_idx&1 ON ChIPProtocolParams&1 (analysis_id,protocol_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ChIPchipGene">
    <comment> Used by the GenesByChipChip(Plasmo|Toxo) query, as well as by
         generateGeneMetrics. Also an input to OrganismAttributes.
     </comment>
    <internalDependency name="FeatureLocation"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="GenomicSequenceAttributes"/>
    <internalDependency name="ExpressionElement"/>
    <sql>
      <![CDATA[
        create table ChIPchipGene&1 NOLOGGING AS
select distinct
      ga.source_id as gene_source_id,
      aef.feature_source_id as probe_id,
      aef.na_feature_id as chip_na_feature_id,
      CASE 
        WHEN ga.is_reversed = 0 
        THEN round(abs(ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0)
        ELSE round(abs(ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0) 
      END as distance,
      CASE 
        WHEN /* distance > 0 */
          CASE WHEN ga.is_reversed = 0 
            THEN ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)
            ELSE ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)
          END > 0 
        THEN 
          CASE 
            WHEN ga.is_reversed = 0 
            THEN '-' 
            ELSE '+'
          END 
        ELSE 
          CASE 
            WHEN ga.is_reversed = 1 
            THEN '-' 
            ELSE '+'
          END 
        END as direction
from  ExpressionElement aef,
      FeatureLocation arrloc,
      GeneAttributes ga,
      rad.analysis a,
      rad.protocol p
where aef.na_feature_id = arrloc.na_feature_id
and   aef.analysis_id = a.analysis_id
and   a.protocol_id = p.protocol_id
and   p.name in ('ChIP chip Peak Calls','ChIP_chip_Einstein_called_peaks','NimbleScan_ChIP_Hakimi_called_peaks')
and   arrloc.na_sequence_id = ga.na_sequence_id
and   ( (ga.is_reversed = 0 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.start_min) <= 3000)
                  or (ga.is_reversed = 1 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.end_max) <= 3000) )
     ]]>
    </sql>
    <sql>
      <![CDATA[
       create index chpgene_geneid_idx&1 ON ChIPchipGene&1 (gene_source_id, chip_na_feature_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TFBSGene">
    <comment> Used by gene queries, as well as by generateGeneMetrics. Also an input
         to OrganismAttributes.
     </comment>
    <internalDependency name="FeatureLocation"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="GenomicSequenceAttributes"/>
    <sql>
      <![CDATA[
        create table TFBSGene&1 NOLOGGING AS
select distinct
      ga.source_id as gene_source_id,
      ga.organism as organism,
      ga.species as species,
      aef.source_id as probe_id,
      aef.na_feature_id as tfbs_na_feature_id,
      CASE 
        WHEN ga.is_reversed = 0 
        THEN round(abs(ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0)
        ELSE round(abs(ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0) 
      END as distance,
      CASE 
        WHEN /* distance > 0 */
          CASE WHEN ga.is_reversed = 0 
            THEN ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)
            ELSE ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)
          END > 0 
        THEN 
          CASE 
            WHEN ga.is_reversed = 0 
            THEN '-' 
            ELSE '+'
          END 
        ELSE 
          CASE 
            WHEN ga.is_reversed = 1 
            THEN '-' 
            ELSE '+'
          END 
        END as direction,
        aef.*
from  dots.BindingSiteFeature aef,
      FeatureLocation arrloc,
      GeneAttributes ga
where aef.na_feature_id = arrloc.na_feature_id
and   arrloc.na_sequence_id = ga.na_sequence_id
and   ( (ga.is_reversed = 0 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.start_min) <= 3000)
                  or (ga.is_reversed = 1 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.end_max) <= 3000) )
     ]]>
    </sql>
    <sql>
      <![CDATA[
       create index tfbs_geneid_idx&1 ON TFBSGene&1 (gene_source_id, tfbs_na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index geneid_tfbs_idx&1 ON TFBSGene&1 (tfbs_na_feature_id,gene_source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>
-->


  <tuningTable name="Subcellular">
    <comment> Each record maps a gene onto a subcellular location. Used by
         GenesBySubcellularLocalization.
     </comment>
    <internalDependency name="GeneId"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="dots.PredictedAaFeature"/>
    <sql>
      <![CDATA[
CREATE TABLE Subcellular&1 NOLOGGING AS
select distinct gi.gene as source_id, targetting_domain
from (
select paf.source_id, 'ht' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf
where ed.name in ('subcellular motif from Haldar','pfal3D7_cellularLocation_Haldar_RSRC')
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
union
select paf.source_id, 'pexel' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf
where ed.name in ('subcellular motif from Cowman','pfal3D7_cellularLocation_Cowman_RSRC')
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
union
select paf.source_id, 'apicoplast' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf
where ed.name in ('apicoplast targeting data from 4.4','pfal3D7_cellularLocation_ApicoplastTargeting_RSRC')
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
) sc, GeneId gi
where gi.id = sc.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index subc_ix&1 ON Subcellular&1(source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


<!--
  <tuningTable name="TajimasStats">
    <comment> Each record stores values for the Tajima's D statistic associated with
         a particular N value. Used by GenesByTajimasDHtsSnps.
     </comment>
    <internalDependency name="IsolateAttributes"/>
    <sql>
      <![CDATA[ 
create table TajimasStats&1 (
   n  number(5),
   a1 number(10,6),
   a2 number(10,6),
   b1 number(10,6),
   b2 number(10,6),
   c1 number(10,6),
   c2 number(10,6), 
   e1 number(10,6),
   e2 number(10,6)
 )
      ]]> 
    </sql>
    <perl>
      <![CDATA[ 
      use strict;
      use lib "$ENV{GUS_HOME}/lib/perl";

      my $sql = "select count(*) as hts_isolates from IsolateAttributes where data_type = 'HTS'";

      
      my $queryHandle = $dbh->prepare($sql) or die $dbh->errstr;
      $queryHandle->execute();

      my ($hts_isolates_count) = $queryHandle->fetchrow_array();
      $queryHandle->finish();

      my $insert_sql = <<SQL;
        insert into TajimasStats&1(n, a1, a2, b1, b2, c1, c2, e1, e2)
         values (?, ?, ?, ?, ?, ?, ?, ?, ?)
SQL

      my $insertHandle = $dbh->prepare($insert_sql) or die $dbh->errstr;

      foreach my $n (3..$hts_isolates_count) {
  
        my $a1 = &sum(map { 1/$_ } 1..$n-1);
        my $a2 = &sum(map { 1 / $_**2 } 1..$n-1);
        my $b1 =($n + 1) / (3 * ($n - 1));
        my $b2 = (2 * ($n**2 + $n + 3)) / (9 * $n * ($n - 1));
        my $c1 = $b1 - (1 / $a1);
        my $c2 = $b2 - (($n + 2) / ($a1 * $n)) + $a2 / $a1**2;
        my $e1 = $c1 / $a1;
        my $e2 = $c2 / ($a1**2 + $a2);

       $insertHandle->execute($n, 
                              sprintf("%.6f", $a1),
                              sprintf("%.6f", $a2),
                              sprintf("%.6f", $b1),
                              sprintf("%.6f", $b2),
                              sprintf("%.6f", $c1),
                              sprintf("%.6f", $c2),
                              sprintf("%.6f", $e1),
                              sprintf("%.6f", $e2)
                             );
      }

      $insertHandle->finish();
      1;
      sub sum {
         my $rv = 0;
         foreach ( @_ ) {
           $rv += $_;
         }
         $rv
     }
      ]]> 
    </perl>
  </tuningTable>


  <tuningTable name="SimilaritySpanLocation">
    <comment> Like dots.SimilaritySpan, except that for sequences that are mapped by
         SequencePiece into parts of other sequences, both locations are stored.
         Used by GBrowse, and also in the creation of the Blastx tuning table.
     </comment>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.SimilaritySpan"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.NaSequence"/>
    <internalDependency name="SequencePieceClosure"/>
    <sql>
      <![CDATA[
create table SimilaritySpanLocation&1 NOLOGGING as
select sim.similarity_id, sim.query_id, sim.subject_id, sim.query_table_id,
       sim.subject_table_id, sim.score as similarity_score, sim.min_query_start,
       sim.max_query_end, sim.is_reversed as similarity_is_reversed,
       sim.pvalue_mant, sim.pvalue_exp,
       round(100 * sim.number_identical / sim.total_match_length,1) as percent_identical,
       round(100 * sim.number_positive / sim.total_match_length,1) as percent_positive,
       sim.min_subject_start, sim.max_subject_end, sim.total_match_length,
       simp.similarity_span_id, simp.score as span_score, simp.query_start, simp.query_end,
       simp.subject_start, simp.subject_end,
       simp.is_reversed as span_is_reversed,
       'direct' as location_mapping
from dots.similarity sim, dots.similarityspan simp, core.TableInfo ti
where sim.similarity_id = simp.similarity_id
  and sim.query_table_id = ti.table_id
  and ti.name = 'ExternalNASequence'
union
select sim.similarity_id, scaffold.na_sequence_id as query_id, sim.subject_id,
       sim.query_table_id,
       sim.subject_table_id, sim.score as similarity_score,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - greatest(sim.min_query_start, sim.max_query_end) + 1
           else sp.distance_from_left + least(sim.min_query_start, sim.max_query_end) - sp.start_position + 1
       end as min_query_start,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - least(sim.min_query_start, sim.max_query_end) + 1
           else sp.distance_from_left + greatest(sim.min_query_start, sim.max_query_end) - sp.start_position + 1
       end as max_query_end,
       sim.is_reversed, sim.pvalue_mant, sim.pvalue_exp,
       round(100 * sim.number_identical / sim.total_match_length,1) as percent_identical,
       round(100 * sim.number_positive / sim.total_match_length,1) as percent_positive,
       sim.min_subject_start, sim.max_subject_end, sim.total_match_length, 
       simp.similarity_span_id, simp.score as span_score,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - greatest(simp.query_start, simp.query_end) + 1
           else sp.distance_from_left + least(simp.query_start, simp.query_end) - sp.start_position + 1
       end as query_start,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - least(simp.query_start, simp.query_end) + 1
           else sp.distance_from_left + greatest(simp.query_start, simp.query_end) - sp.start_position + 1
       end as query_end,
       simp.subject_start, simp.subject_end,
       simp.is_reversed as span_is_reversed,
       'virtual' as location_mapping
from dots.similarity sim, dots.similarityspan simp, core.TableInfo ti,
     dots.NaSequence contig, &prefixSequencePieceClosure sp, dots.NaSequence scaffold
where sim.similarity_id = simp.similarity_id
  and sim.query_table_id = ti.table_id
  and ti.name = 'ExternalNASequence'
  and sim.query_id = sp.piece_na_sequence_id
  and sp.start_position <= sim.min_query_start
  and sp.end_position >= sim.max_query_end
  and sim.query_id = contig.na_sequence_id
  and sp.virtual_na_sequence_id = scaffold.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
update SimilaritySpanLocation&1
set pvalue_exp = (select min(pvalue_exp) from SimilaritySpanLocation&1)
where pvalue_mant = 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index spanloc_query_ix&1
        on SimilaritySpanLocation&1 (query_id, min_query_start, max_query_end, query_table_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="IsolateSNPs">
    <comment> Associates SNPs with isolates. Used for the SNP record and for SNP ID
         queries, as well as for the creation of the SnpsWithIsolates tuning table.
     </comment>
    <internalDependency name="FeatureLocation"/>
    <internalDependency name="IsolateAttributes"/>
    <internalDependency name="SnpChipAttributes"/>
    <externalDependency name="dots.IsolateFeature"/>
    <sql>
      <![CDATA[
create table IsolateSNPs&1 NOLOGGING as
select atr.na_sequence_id as is_na_sequence_id,
       atr.source_id as is_source_id,
       isof.allele,
       sa.source_id as snp_source_id,
       sa.dataset as snp_db_name,
       sa.na_sequence_id as snp_na_sequence_id,
       sa.start_min as snp_start_min
from dots.IsolateFeature isof,  FeatureLocation isol, 
     SnpChipAttributes sa, IsolateAttributes atr
where atr.na_feature_id = isof.parent_id
and isof.na_feature_id = isol.na_feature_id
and sa.na_sequence_id = isol.na_sequence_id
and sa.start_min = isol.start_min
and sa.dataset in ('pfal3D7_SNP_combined_Su_Broad_Sanger_gff_RSRC','PlasmoDB combined SNPs','Broad SNPs','pfal3D7_SNP_Broad_gff_RSRC')
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index IsolateSNPs_is_sid_idx&1 on IsolateSNPs&1 (is_source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index IsolateSNPs_snp_db_id_idx&1 on IsolateSNPs&1 (snp_db_name,snp_source_id,allele)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index IsolateSNPs_snp_id_idx&1 on IsolateSNPs&1 (snp_source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index isnps_snp_sq_strt_idx&1 on IsolateSNPs&1 (snp_na_sequence_id,snp_start_min)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SnpsWithIsolates">
    <comment> Each record summarizes statistics for a single SNP location within a
         single isolate external database release. Used by GBrowse.
     </comment>
    <internalDependency name="IsolateAttributes"/>
    <internalDependency name="IsolateSNPs"/>
    <sql>
      <![CDATA[
create table SnpsWithIsolates&1 NOLOGGING as
select iso_ext_db_name,snp_source_id, 
 apidb.tab_to_string(set(cast(COLLECT(CASE WHEN frequency < 0.5 THEN allele END order by allele) as apidb.varchartab)), ', ') as minor_allele,
 apidb.tab_to_string(set(cast(COLLECT(CASE WHEN frequency > 0.5 THEN allele END order by allele) as apidb.varchartab)), ', ') as major_allele,
 to_char(min(frequency), '0.99') as minor_allele_frequency,
 min(number_isolates) as number_isolates
from (
 select s.snp_source_id as snp_source_id, s.external_db_name as iso_ext_db_name, s.allele, s.ct/t.tot as frequency, s.ct as allele_count, t.tot as number_isolates
                 from (
                       select ia.external_db_name, isos.snp_source_id,isos.allele,count(*) as ct
                       from IsolateSNPs isos,IsolateAttributes ia
                       where  isos.allele in ('A','C','G','T')
                       and isos.is_source_id = ia.source_id
                       group by ia.external_db_name, isos.snp_source_id,isos.allele
                       ) s,
                       (
                       select ia.external_db_name, isos.snp_source_id, count(*) as tot
                       from IsolateSNPs isos,IsolateAttributes ia
                       where  isos.allele in ('A','C','G','T')
                       and isos.is_source_id = ia.source_id
                       group by ia.external_db_name, isos.snp_source_id
                       ) t
                       where s.snp_source_id = t.snp_source_id
                       and s.external_db_name = t.external_db_name
                       )
                 group by iso_ext_db_name,snp_source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index snpswiso_id_db_idx&1 on SnpsWithIsolates&1 (snp_source_id,iso_ext_db_name)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
update SnpsWithIsolates&1 swa
set swa.major_allele = (select max(allele) from IsolateAttributes ia, IsolateSNPs isnp 
                    where isnp.snp_source_id = swa.snp_source_id and ia.EXTERNAL_DB_NAME = swa.iso_ext_db_name
                    group by isnp.snp_source_id,ia.EXTERNAL_DB_NAME),
swa.minor_allele = (select min(allele) from IsolateAttributes ia, IsolateSNPs isnp 
                    where isnp.snp_source_id = swa.snp_source_id and ia.EXTERNAL_DB_NAME = swa.iso_ext_db_name
                    group by isnp.snp_source_id,ia.EXTERNAL_DB_NAME)
where swa.major_allele is null
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Blastp">
    <comment> Each record stores a Blastp similarity of a gene. Used by the gene-page
         Blastp table. 
     </comment>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.ExternalAaSequence"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="core.TableInfo"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <sql>
      <![CDATA[
create table Blastp&1 nologging as
select rownum as blastp_id, gf.source_id, ga.project_id, sim.similarity_id,
       subject.source_id as subject_source_id, sim.score score, sim.query_id, 
       sim.min_query_start, sim.max_query_end, sim.pvalue_mant, sim.pvalue_exp,
       sim.number_identical, sim.total_match_length,
       substr(replace(subject.description, chr(1), ''), 1, 300) as description,
       sim.number_positive, ed.name as external_database_name,
       substr(tn.name, 1, 50) AS query_organism, ns.taxon_id as query_taxon_id
from dots.Similarity sim, core.TableInfo qti, core.TableInfo sti, dots.ExternalAaSequence subject,
     dots.GeneFeature gf, dots.Transcript t, dots.TranslatedAaFeature taf,
     sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
     dots.NaSequence ns, /* TaxonSpecies st, */
     sres.TaxonName tn, GeneAttributes ga
where qti.table_id = sim.query_table_id
  and qti.name = 'TranslatedAASequence'
  and sti.table_id = sim.subject_table_id
  and sti.name = 'ExternalAASequence'
  and subject.aa_sequence_id = sim.subject_id
  and ga.source_id = gf.source_id
  and gf.na_feature_id = t.parent_id
  and t.na_feature_id = taf.na_feature_id
  and taf.aa_sequence_id = sim.query_id
  and subject.external_database_release_id = edr.external_database_release_id
  and edr.external_database_id = ed.external_database_id
  and gf.na_sequence_id = ns.na_sequence_id
  and ns.taxon_id =
/*    st.taxon_id and st.species_taxon_id = # TaxonSpecies mapping commented out */
                     tn.taxon_id
  and tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
update Blastp&1
set pvalue_exp = (select min(pvalue_exp) from Blastp&1)
where pvalue_mant = 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Blastp_src_ix&1 on Blastp&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Blastp_query_ix&1 on Blastp&1 (query_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Blastp_text_ix&1 on Blastp&1(description) indextype is ctxsys.context
             parameters('DATASTORE CTXSYS.DEFAULT_DATASTORE')
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneIsolateOverlap">
    <comment> Each record stores a colocated (gene, isolate) 2-tuple. Used by the
         gene page as well as the IsolateByOverlap query.
     </comment>
    <internalDependency name="IsolateAttributes"/>
    <internalDependency name="FeatureLocation"/>
    <externalDependency name="dots.Similarity"/>
    <sql>
      <![CDATA[
create table GeneIsolateOverlap&1 nologging as
select substr(ia.source_id, 1, 30) as isolate_source_id,
       fl.feature_source_id as gene_source_id,
       min(pvalue_exp) as min_pvalue_exp
from IsolateAttributes ia, dots.Similarity sim, FeatureLocation fl
where fl.feature_type = 'GeneFeature'
  and fl.na_sequence_id = sim.subject_id
  and fl.start_min < sim.max_subject_end
  and fl.end_max > sim.min_subject_start
  and sim.query_id = ia.na_sequence_id
group by ia.source_id, fl.feature_source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index gi_i_ix&1 on GeneIsolateOverlap&1 (isolate_source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index gi_g_ix&1 on GeneIsolateOverlap&1 (gene_source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

-->



  <tuningTable name="TaxonSpecies" prefixEnabled="true">
    <comment>Each record maps a taxon_id of interest onto the taxon_id that taxon's
         taxon-tree ancestor whose rank is "species". Used by
         buildAnnotationChangeTT and by gene queries, as well as an input in the
         creation of several tuning tables, including GeneAttributes and
         OrganismTree.
    </comment>
    <internalDependency name="GenomicSequenceAttributes"/>
    <externalDependency name="sres.Taxon"/>
    <sql>
      <![CDATA[
create table &prefixTaxonSpecies&1 nologging as
select t.taxon_id, species.taxon_id as species_taxon_id
from sres.Taxon species, (select distinct sa.taxon_id
      from &prefixGenomicSequenceAttributes sa) t
where species.taxon_id in (select taxon_id from sres.Taxon
                           connect by taxon_id = prior parent_id and prior rank != 'species'
                           start with taxon_id = t.taxon_id)
  and species.rank = 'species'
      ]]>
    </sql>
  </tuningTable>


<!--
  <tuningTable name="Blastx">
    <comment> Each record stores a Blastx similarity. Used by GBrowse for the
         match:WU_BLASTX track.
     </comment>
    <externalDependency name="dots.ExternalAaSequence"/>
    <externalDependency name="dots.NaSequence"/>
    <internalDependency name="SimilaritySpanLocation"/>
    <sql>
      <![CDATA[
create table Blastx&1
      (similarity_id, name, score, pvalue, na_sequence_id, startm, end, strand, atts,
       constraint blastx&1_pk primary key(na_sequence_id, startm, pvalue, end, similarity_id))
organization index
nologging
as
select distinct sim.similarity_id,
       extt.source_id name, 
       substr(sim.similarity_score || '', 1, 6) score, 
       to_number(sim.pvalue_mant || 'e' || sim.pvalue_exp) pvalue,
       extq.na_sequence_id,
       sim.min_query_start startm, 
       sim.max_query_end end, 
       decode (sim.similarity_is_reversed, 0, '+1', 1, '-1', '.') strand, 
       substr('Score=' || sim.similarity_score || ';;' || 
              'Expect=' || (sim.pvalue_mant || 'e' ||sim.pvalue_exp)||';;'|| 
              'Defline=' || extt.description || ';;' || 
              'PercentIdentity=' || sim.percent_identical || ';;' ||
              'PercentPositive=' || sim.percent_positive || ';;' ||
              'TStart=' || sim.min_query_start || ';;' || 
              'TStop=' || sim.max_query_end, 1, 400) atts 
from SimilaritySpanLocation sim, dots.ExternalAaSequence extt, 
     dots.NaSequence extq
where sim.query_id = extq.na_sequence_id
  and sim.subject_id = extt.aa_sequence_id
  and (sim.max_query_end - sim.min_query_start) < 5000
  and sim.pvalue_exp < -10
      ]]>
    </sql>
  </tuningTable>
-->

  <tuningTable name="TranscriptSequence">
    <comment> Each record stores the transcript sequence of one gene. Used by the
         gene record and the sequence retrieval tool. Propagated to the portal.
     </comment>
    <externalDependency name="dots.SplicedNaSequence"/>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE TranscriptSequence&1 NOLOGGING AS
SELECT ta.transcript_source_id AS source_id, ta.project_id, sns.sequence
FROM TranscriptAttributes ta, dots.SplicedNaSequence sns
WHERE ta.transcript_source_id = sns.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index XScriptSeq_ix&1 on TranscriptSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="CodingSequence">
    <comment> Each record stores the coding sequence of one gene. Used by the
         gene record and the sequence retrieval tool. Propagated to the portal.
     </comment>
    <externalDependency name="dots.SplicedNaSequence"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE CodingSequence&1 NOLOGGING AS
SELECT ta.transcript_source_id  AS source_id, ta.project_id,
       SUBSTR(sns.sequence, tf.translation_start,                            
              tf.translation_stop - tf.translation_start + 1) as sequence
FROM TranscriptAttributes ta, dots.SplicedNaSequence sns, dots.TranslatedAaFeature tf
WHERE ta.transcript_source_id = sns.source_id
 AND ta.na_feature_id = tf.na_feature_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index CodSeq_ix&1 on CodingSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProteinSequence">
    <comment> Each record stores the coding sequence of one gene. Used by the
         gene record and the sequence retrieval tool, as well as by
         buildTrackOldAnnotationTT. Propagated to the portal.
     </comment>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <internalDependency name="ProteinAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE ProteinSequence&1 NOLOGGING AS
WITH pAttr AS (
   SELECT distinct source_id, aa_sequence_id
   FROM ProteinAttributes)
SELECT pa.source_id, pi.name AS project_id, tas.sequence
FROM pAttr pa, dots.TranslatedAaSequence tas, core.Projectinfo pi
WHERE pa.aa_sequence_id = tas.aa_sequence_id
  AND pi.project_id = tas.row_project_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index ProtSeq_ix&1 on ProteinSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GenomicSequenceSequence">
    <comment> Each record stores the nucleotide sequence for one genomic sequence
         that is "official" (in the sense that it can be instantiated as a WDK
         sequence record. Used by generatePathoLogicFile and the sequence
         retrieval tool Propagated to portal instances.
     </comment>
    <internalDependency name="ProjectTaxon"/>
    <internalDependency name="GenomicSequenceAttributes"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE GenomicSequenceSequence&1 NOLOGGING AS
SELECT sa.source_id, cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ns.sequence
FROM GenomicSequenceAttributes sa, dots.NaSequence ns, sres.TaxonName tn
WHERE sa.na_sequence_id = ns.na_sequence_id
  AND ns.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GenomicSeq_ix&1 on GenomicSequenceSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrfSequence">
    <comment> Each record stores the amino-acid sequence of an ORF. Used by the
         relevant attribute query of the WDK ORF record, as well as by the
         sequence retrieval tool. Propagated to portal instances.
     </comment>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <internalDependency name="OrfAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE OrfSequence&1 NOLOGGING AS
SELECT oa.source_id,
       oa.project_id,
       ts.sequence
FROM dots.TranslatedAaSequence ts
            , dots.TranslatedAaFeature tf
            , OrfAttributes oa
 WHERE oa.na_feature_id = tf.na_feature_id
   AND tf.aa_sequence_id = ts.aa_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index OrfSeq_ix&1 on OrfSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EstSequence">
    <comment> Each record stores the nucleotide sequence of an EST, for use by the
         relevant attribute query in the WDK EST record. Propagated to portal
         instances.
     </comment>
    <internalDependency name="ProjectTaxon"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE EstSequence&1 NOLOGGING AS
SELECT ens.source_id,
       cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ens.sequence
FROM dots.ExternalNaSequence ens, sres.OntologyTerm oterm, sres.TaxonName tn
WHERE oterm.name = 'EST'
  AND oterm.ontology_term_id = ens.sequence_ontology_id
  AND ens.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index EstSeq_ix&1 on EstSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="UTR" prefixEnabled="true">
    <comment>Each record represents an untranslated region (UTR) of a gene. Used by
         GBrowse.
    </comment>
    <internalDependency name="FeatureLocation"/>
    <externalDependency name="dots.ExonFeature"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixUTR&1 NOLOGGING AS
SELECT na_feature_id,parent_id,na_sequence_id,start_min,end_max,direction,is_reversed,end_max-start_min+1 as length FROM 
(
  (SELECT exon_loc.na_feature_id,
          exon_loc.parent_id,
          exon_loc.na_sequence_id,
          exon_loc.start_min as start_min,
          CASE WHEN exon_loc.is_reversed = 0 THEN exon_loc.coding_start - 1 
               ELSE exon_loc.coding_end - 1 
               END end_max,
          CASE WHEN exon_loc.is_reversed = 0 THEN 5 
               WHEN exon_loc.is_reversed = 1 THEN 3 
               ELSE 0 END direction,
          exon_loc.is_reversed
   FROM   &prefixFeatureLocation exon_loc, dots.GeneFeature gf, sres.OntologyTerm so
   WHERE  exon_loc.feature_type = 'ExonFeature'
      AND gf.na_feature_id = exon_loc.parent_id
      AND gf.sequence_ontology_id = so.ontology_term_id
      AND so.name = 'protein_coding'
      AND ((exon_loc.is_reversed = 0 AND exon_loc.coding_start - exon_loc.start_min  != 0)
       OR (exon_loc.is_reversed = 1 AND exon_loc.coding_end - exon_loc.start_min  != 0)))
  UNION
  (SELECT exon_loc.na_feature_id, 
          exon_loc.parent_id,
          exon_loc.na_sequence_id,
          CASE WHEN exon_loc.is_reversed = 0 THEN exon_loc.coding_end + 1 
               ELSE exon_loc.coding_start + 1 
               END start_min,
          exon_loc.end_max,
          CASE WHEN exon_loc.is_reversed = 0 THEN 3 
          WHEN exon_loc.is_reversed = 1 THEN 5 
          ELSE 0 END direction,
          exon_loc.is_reversed
   FROM   &prefixFeatureLocation exon_loc, dots.GeneFeature gf, sres.OntologyTerm so
   WHERE  exon_loc.feature_type = 'ExonFeature'
      AND gf.na_feature_id = exon_loc.parent_id
      AND gf.sequence_ontology_id = so.ontology_term_id
      AND so.name = 'protein_coding'
      AND ((exon_loc.is_reversed = 0 AND exon_loc.end_max - exon_loc.coding_end  != 0)
       OR (exon_loc.is_reversed = 1 AND exon_loc.end_max - exon_loc.coding_start  != 0))  )
   UNION
   (SELECT exon_loc.na_feature_id,
           exon_loc.parent_id,
           exon_loc.na_sequence_id,
           exon_loc.start_min,
           exon_loc.end_max,
           CASE WHEN ef.order_number <= eo.max_order_number THEN 5
                WHEN ef.order_number > eo.max_order_number THEN 3
                ELSE 0
                END direction,
           exon_loc.is_reversed
    FROM   &prefixFeatureLocation exon_loc, dots.exonfeature ef, dots.GeneFeature gf, sres.OntologyTerm so,
           (select parent_id, max(order_number) as max_order_number from dots.exonfeature
            where coding_start is not null
            group by parent_id) eo
    WHERE  exon_loc.feature_type = 'ExonFeature'
       AND gf.na_feature_id = exon_loc.parent_id
       AND ef.na_feature_id = exon_loc.na_feature_id
       AND ef.parent_id = eo.parent_id
       AND gf.sequence_ontology_id = so.ontology_term_id
       AND so.name = 'protein_coding'
       AND exon_loc.coding_start is null)
)
WHERE end_max - start_min != 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index UTRSeq_ix&1 on &prefixUTR&1 (na_feature_id, na_sequence_id, start_min, end_max, is_reversed, parent_id, direction, length)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index UTRparent_ix&1 on &prefixUTR&1 (parent_id, start_min, end_max, na_feature_id, is_reversed, direction, length, na_sequence_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index UTRLoc_ix&1 on &prefixUTR&1 (na_sequence_id, start_min, end_max, is_reversed, na_feature_id, parent_id, direction, length)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="TranscriptLocation" prefixEnabled="true">
    <comment>Genomic locations of transcripts
    </comment>
    <externalDependency name="dots.AaFeatureExon"/>
    <externalDependency name="dots.ExonFeature"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.NaLocation"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.RnaFeatureExon"/>
    <externalDependency name="dots.SequencePiece"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <ancillaryTable name="CdsLocation"/>
    <sql>
      <![CDATA[
        create table  &prefixTranscriptLocation&1 (
          feature_source_id    varchar2(80),
          sequence_source_id   varchar2(50),
          na_sequence_id       number(10),
          na_feature_id        number(10),
          start_min            number,
          end_max              number,
          is_reversed          number,
          gene_na_feature_id   number(10),
          is_top_level         number
        )
      ]]> 
    </sql>

    <sql>
      <![CDATA[
        create table  &prefixCdsLocation&1 (
          protein_source_id    varchar2(80),
          transcript_source_id varchar2(80),
          sequence_source_id   varchar2(50),
          na_sequence_id       number(10),
          na_feature_id        number(10),
          start_min            number,
          end_max              number,
          is_reversed          number,
          gene_na_feature_id   number(10),
          is_top_level         number
        )
      ]]> 
    </sql>

    <perl>
      <![CDATA[ 
      use strict;
      use lib "$ENV{GUS_HOME}/lib/perl";
      use GUS::Community::GeneModelLocations;
      # use DBI;
      # use DBD::Oracle;

      use Data::Dumper;

      my $transcriptInsert = $dbh->prepare(<<SQL) or die $dbh->errstr;
        insert into &prefixTranscriptLocation&1
            (feature_source_id, sequence_source_id, na_sequence_id, na_feature_id,
             start_min, end_max, is_reversed, gene_na_feature_id, is_top_level)
        values (?, ?, ?, ?, ?, ?, ?, ?, ?)
SQL

      my $cdsInsert = $dbh->prepare(<<SQL) or die $dbh->errstr;
        insert into &prefixCdsLocation&1
            (transcript_source_id, protein_source_id, sequence_source_id, na_sequence_id, na_feature_id,
             start_min, end_max, is_reversed, gene_na_feature_id, is_top_level)
        values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
SQL

      my $edrQuery = $dbh->prepare(<<SQL) or die $dbh->errstr;
      select distinct external_database_release_id from dots.geneFeature
SQL
      $edrQuery->execute();

      while (my ($genomeExtDbRlsId) = $edrQuery->fetchrow_array()) {
        foreach my $isTopLevel ((0, 1)) {
          my $geneModelLocations = GUS::Community::GeneModelLocations->new($dbh, $genomeExtDbRlsId, $isTopLevel);

          my $geneList = $geneModelLocations->getAllGeneIds();
          foreach my $geneId (@$geneList) {
            my $gmh = $geneModelLocations->getGeneModelHashFromGeneSourceId($geneId);
            my $locations = $geneModelLocations->bioperlFeaturesFromGeneSourceId($geneId);

            foreach (@{$locations}) {
              if ($_->{_primary_tag} eq "mRNA") {
                $transcriptInsert->execute(
                                           $_->{_gsf_tag_hash}->{ID}[0], # feature_source_id
                                           $_->{_gsf_seq_id}, # sequence_source_id
                                           $_->{_gsf_tag_hash}->{NA_SEQUENCE_ID}[0], # na_sequence_id
                                           $_->{_gsf_tag_hash}->{NA_FEATURE_ID}[0], # na_feature_id
                                           $_->{_location}->{_start}, # start_min
                                           $_->{_location}->{_end}, # end_max
                                           $_->{_location}->{_strand} == -1 ? 1 : 0, # is_reversed
                                           $_->{_gsf_tag_hash}->{PARENT_NA_FEATURE_ID}[0], # gene_na_feature_id
                                           $isTopLevel # is_top_level
                                          )
                 or die $dbh->errstr;
              } elsif ($_->{_primary_tag} eq "CDS") {
                $cdsInsert->execute(
                                           $_->{_gsf_tag_hash}->{PARENT}[0], # transcript_source_id
                                           $_->{_gsf_tag_hash}->{ID}[0], # protein_source_id
                                           $_->{_gsf_seq_id}, # sequence_source_id
                                           $_->{_gsf_tag_hash}->{NA_SEQUENCE_ID}[0], # na_sequence_id
                                           $_->{_gsf_tag_hash}->{NA_FEATURE_ID}[0], # na_feature_id
                                           $_->{_location}->{_start}, # start_min
                                           $_->{_location}->{_end}, # end_max
                                           $_->{_location}->{_strand} == -1 ? 1 : 0, # is_reversed
                                           $_->{_gsf_tag_hash}->{PARENT_NA_FEATURE_ID}[0], # gene_na_feature_id
                                           $isTopLevel, # is_top_level,
                                          )
                 or die $dbh->errstr;
              }
            }
          }
        }

      }
      ]]>
    </perl>
  </tuningTable>


<!--
  <tuningTable name="IsolateSequence">
    <comment> Each record stores the nucleotide sequence of one isolate. Used in the
         relevant attribute query of the WDK isolate record, as well as by
         IsolateClustalw. Propagated to portal instances.
     </comment>
    <internalDependency name="IsolateAttributes"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE IsolateSequence&1 NOLOGGING AS
SELECT ia.source_id,
       ia.project_id,
       ns.sequence
FROM IsolateAttributes ia, dots.NaSequence ns, sres.TaxonName tn
WHERE ia.na_sequence_id = ns.na_sequence_id
  AND ns.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index IsolateSeq_ix&1 on IsolateSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TypeAheadCounts">
    <comment> Stores strings that can be used in parameters with type-ahead, such as
         GO terms, EC numbers, or InterPro domains. Each record stores such a
         string, along with the project ID and the number of genes with which it
         is associated. Used for gene queries.
     </comment>
    <internalDependency name="GeneAttributes"/>
    <externalDependency name="dots.DbRefAaFeature"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="dots.AaFeature"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.EnzymeClass"/>
    <externalDependency name="dots.AaSequenceEnzymeClass"/>
    <externalDependency name="dots.GoAssociation"/>
    <externalDependency name="sres.GoTerm"/>
    <externalDependency name="sres.GoRelationship"/>
    <externalDependency name="sres.GoRelationshipType"/>
    <externalDependency name="core.TableInfo"/>
    <sql>
      <![CDATA[
CREATE TABLE TypeAheadCounts&1 NOLOGGING AS
   (SELECT DISTINCT dr.primary_identifier as option_id,
                   count(distinct aaf.aa_sequence_id) AS gene_count,
                   gf.project_id
   FROM dots.DbRefAaFeature draf, sres.DbRef dr, dots.aafeature aaf,
        sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
        dots.TranslatedAAFeature taf,GeneAttributes gf, dots.transcript t
   WHERE draf.db_ref_id = dr.db_ref_id
   AND dr.external_database_release_id
       = edr.external_database_release_id
   AND edr.external_database_id = ed.external_database_id
   AND aaf.aa_feature_id = draf.aa_feature_id
   AND aaf.aa_sequence_id = taf.aa_sequence_id
   AND taf.na_feature_id = t.na_feature_id
   AND gf.na_feature_id = t.parent_id
   GROUP BY gf.project_id,
            dr.primary_identifier)
   UNION
   (SELECT DISTINCT ec.ec_number AS option_id,
          COUNT(DISTINCT aaf.aa_sequence_id) AS gene_count,
          gf.project_id
   FROM sres.EnzymeClass ec, GeneAttributes gf,
        dots.AaSequenceEnzymeClass asec,
        dots.translatedAaFeature taf,
        dots.aafeature aaf, dots.transcript t
   WHERE gf.na_feature_id = t.parent_id
   AND t.na_feature_id = taf.na_feature_id
   AND taf.aa_sequence_id = asec.aa_sequence_id
   AND aaf.aa_sequence_id = taf.aa_sequence_id
   AND asec.enzyme_class_id = ec.enzyme_class_id
   GROUP BY gf.project_id,
            ec.ec_number)
   UNION                
   (SELECT DISTINCT gp.go_id AS option_id,
           COUNT(DISTINCT aaf.aa_sequence_id) AS gene_count,
           gf.project_id
    FROM GeneAttributes gf, dots.Transcript t,
         dots.TranslatedAaFeature taf, dots.AaFeature aaf,
         dots.GoAssociation ga, sres.GoTerm gp,
         sres.GoRelationship gr, core.TableInfo ti,
         sres.GoRelationshipType grt
    WHERE gf.na_feature_id = t.parent_id
    AND t.na_feature_id = taf.na_feature_id
    AND taf.aa_sequence_id = ga.row_id
    AND aaf.aa_sequence_id = taf.aa_sequence_id
    AND ga.table_id = ti.table_id
    AND ti.name = 'TranslatedAASequence'
    AND ga.go_term_id = gr.child_term_id
    AND gr.parent_term_id = gp.go_term_id
    AND gr.go_relationship_type_id = grt.go_relationship_type_id
    AND grt.name = 'closure'
    GROUP BY gf.project_id,
             gp.go_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX TypeAheadCounts_idx&1 ON TypeAheadCounts&1 (option_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ExpressionElement">
    <comment> Each record associates expression values for an NaFeature with that
         feature's ID and location. Used by GBrowse, as well as in the creation
         of the ChIPchipGene table.
     </comment>
    <internalDependency name="FeatureLocation"/>
    <externalDependency name="rad.DataTransformationResult"/>
    <sql>
      <![CDATA[
      create table ExpressionElement&1 nologging as
      select fl.na_feature_id, fl.na_sequence_id, fl.start_min, fl.end_max,
             fl.feature_source_id, dtr.analysis_id, dtr.float_value as score
      from rad.DataTransformationResult dtr, FeatureLocation fl
      where dtr.row_id = fl.na_feature_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index ee_track_ix&1
      on ExpressionElement&1 (na_sequence_id, analysis_id, start_min, end_max, na_feature_id, score)
      tablespace indx
      ]]>
    </sql>
  </tuningTable>
-->


  <tuningTable name="OrthologousPair">
    <comment> Each record contains a pair of genes that are orthologous to each other.
         Used in the creation of the tuning table OrthologGeneTable.
     </comment>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
       create table OrthologousPair&1 nologging as
       select /*+ ordered_predicates */
       ga2.gene_source_id AS ortho_gene_source_id, min(ga2.source_id) as ortho_transcript_source_id,
       ga2.na_sequence_id as ortho_na_sequence_id,
       ga2.gene_start_min as ortho_start_min,
       ga2.organism, ga2.gene_product, ga1.gene_source_id, ga1.project_id, ga1.na_sequence_id,
       ga1.gene_start_min as start_min, nvl(comments.has_comment, 'no') as has_comment
       from TranscriptAttributes ga1, TranscriptAttributes ga2,
       (select distinct 'yes' as has_comment, stable_id as source_id, project_name
       from userlogins5.comments@&dblink
       where comment_target_id = 'gene'
       and review_status_id != 'rejected'
       and is_visible = 1) comments
       where ga2.gene_source_id = comments.source_id(+)
       and ga2.project_id = ga1.project_id
       and ga1.orthomcl_name = ga2.orthomcl_name
       and ga2.gene_source_id != ga1.gene_source_id
       group by ga2.gene_source_id, ga2.na_sequence_id, ga2.gene_start_min,
       ga2.organism, ga2.gene_product, ga1.gene_source_id, ga1.project_id, ga1.na_sequence_id,
       ga1.gene_start_min, has_comment
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index orth_ix&1
      on OrthologousPair&1 (gene_source_id, project_id)
      tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrthologGeneTable">
    <comment> Each record contains a record from OrthologousPair, augmented by the
         IS_SYNTENIC column. Used by the relevant table query of the WDK gene
         record.
      </comment>
    <internalDependency name="OrthologousPair"/>
    <externalDependency name="apidb.Synteny"/>
    <sql>
      <![CDATA[
      create table OrthologGeneTable&1 nologging as
      select
       op.gene_source_id, op.ortho_gene_source_id, op.ortho_transcript_source_id,
       op.organism,
       op.gene_product,
       nvl(synteny.is_syntenic, 'no') as is_syntenic,
       op.has_comment,
       op.project_id
      from OrthologousPair op,
       (select distinct
               'yes' as is_syntenic,
               a_na_sequence_id, b_na_sequence_id, a_start, a_end, b_start, b_end
        from apidb.synteny s) synteny
        where synteny.a_na_sequence_id(+) = op.na_sequence_id
          AND synteny.b_na_sequence_id(+) = op.ortho_na_sequence_id
          AND synteny.a_start(+) <= op.start_min
          AND synteny.a_end(+) >= op.start_min
          AND synteny.b_start(+) <= op.ortho_start_min
          AND synteny.b_end(+) >= op.ortho_start_min
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index ogt_ix&1
      on OrthologGeneTable&1 (gene_source_id, project_id)
      tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrganismAbbreviation">
    <comment> Each record maps an organism name onto an abbreviation, getting the
         pair either from apidb.Organism or (in the case of Tvag), hardwired
         into the below SQL. This table will eventually be replaced by workflow.
      </comment>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
       CREATE TABLE OrganismAbbreviation&1 NOLOGGING AS
       select organism, abbreviation
       From (
  select tn.name as organism, o.name_for_filenames as abbreviation
  from apidb.Organism o, sres.TaxonName tn
  where o.taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
       )
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="OrganismAbbreviationWS">
    <comment> Stores special webservice abbreviations which are not standard organism
         names. Each record maps an organism name onto this abbreviation, as
         well as the species name and project ID. Used by the model and as an
         input in the creation of the OrganismAbbreviationBlast tuning table.
         Propagated to portal instances.
      </comment>
    <internalDependency name="OrganismAbbreviation"/>
    <internalDependency name="OrganismTree"/>
    <sql>
      <![CDATA[
       create table OrganismAbbreviationWS&1 nologging as
       select oa.organism, ot.parentTerm as parent, oa.abbreviation, ot.project_id
       from OrganismAbbreviation oa, OrganismTree ot
       where ot.term = oa.organism
       union
       select special.organism, special.parent,special.abbreviation, ot.project_id from OrganismTree ot,(
  /* TrichDB Repeat Genes */
  select 'Trichomonas vaginalis G3 (Repeated Genes)' as organism, 'Trichomonas vaginalis' as parent, 'TvaginalisRG' as abbreviation from dual
) special
          where special.parent = ot.term
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ProjectIdTaxonLevel">
    <comment> Groups projects by higher level taxonomy. Used in the creation of the
         OrganismTree tuning table.
      </comment>
    <internalDependency name="GenomicSequenceAttributes"/>
    <sql>
      <![CDATA[
       CREATE TABLE ProjectIdTaxonLevel&1 NOLOGGING AS
       SELECT p.project_id, taxon_node, organism
          FROM (SELECT 'PlasmoDB' AS project_id,
		       'Apicomplexa' AS  taxon_node 
		FROM dual 
		UNION
		SELECT 'CryptoDB' AS project_id,
			   'Apicomplexa' AS  taxon_node 
		FROM dual 
		UNION
		SELECT 'ToxoDB' AS project_id,
		           'Apicomplexa' AS  taxon_node 
		FROM dual 
		UNION
		SELECT 'PiroplasmaDB' AS project_id,
		           'Apicomplexa' AS  taxon_node 
		FROM dual
		UNION
		SELECT 'TriTrypDB' AS project_id,
			   'Kinetoplastida' AS  taxon_node 
		FROM dual 
		UNION
		SELECT 'AmoebaDB' AS project_id,
			   'Amoebozoa' AS  taxon_node 
		FROM dual
		UNION 
		SELECT 'MicrosporidiaDB' AS project_id,
		           'Microsporidia' AS  taxon_node 
		FROM dual
		UNION
		SELECT 'GiardiaDB' AS project_id, 
		           'Diplomonadida' AS taxon_node 
		FROM dual
		UNION
		SELECT 'TrichDB' AS project_id,
		           'Trichomonadida' AS taxon_node
		FROM dual
        ) p,
        (select distinct project_id, organism from GenomicSequenceAttributes) s
        where p.project_id = s.project_id
        union 
        SELECT distinct s.project_id as project_id, 
          CASE
            when (s.organism like 'Coprinopsis%' or
                  s.organism like 'Phanerochaete%')
            then 'Agaricomycetes'
            when (s.organism like 'Allomyces%')
            then 'Blastocladiomycetes'
            when (s.organism like 'Batrachochytrium%' or
                  s.organism like 'Spizellomyces%') 
            then 'Chytridiomycetes'
            when (s.organism like 'Aspergillus%' or
                  s.organism like 'Emericella%' or
                  s.organism like 'Coccidioides%' or
                  s.organism like 'Histoplasma%' or
                  s.organism like 'Talaromyces%' or
                  s.organism like 'Penicillium%' or
                  s.organism like 'Neosartorya%' or
                  s.organism like 'Ajellomyces%')
            then 'Eurotiomycetes'
            when (s.organism like 'Sclerotinia%' or
                  s.organism like 'Botrytis%' or 
                  s.organism like 'Botryotinia%')
            then 'Leotiomycetes'
            when (s.organism like 'Hyaloperonospora%' or
                  s.organism like 'Phytophthora%' or
                  s.organism like 'Saprolegnia%' or
                  s.organism like 'Albugo%' or
                  s.organism like 'Aphanomyces%' or
                  s.organism like 'Pythium%')
            then 'Oomycetes'
            when (s.organism like 'Pneumocystis%')
            then 'Pneumocystidomycetes'
            when (s.organism like 'Puccinia%' or
                  s.organism like 'Melampsora%')
            then 'Pucciniomycetes'
            when (s.organism like 'Saccharomyces%' or
                  s.organism like 'Yarrowia%' or
                  s.organism like 'Candida%')
            then 'Saccharomycetes'
            when (s.organism like 'Schizosaccharomyces%')
            then 'Schizosaccharomycetes' 
            when (s.organism like 'Neurospora%' or 
                  s.organism like 'Magnaporthe%' or 
                  s.organism like 'Fusarium%' or 
                  s.organism like 'Gibberella%' or
                  s.organism like 'Trichoderma%' or
                  s.organism like 'Sordaria%')
            then 'Sordariomycetes'
            when (s.organism like 'Tremella%' or
                  s.organism like 'Cryptococcus%')
            then 'Tremellomycetes'
            when (s.organism like 'Ustilago%' or
                  s.organism like 'Malassezia%' or 
                  s.organism like 'Sporisorium%') 
            then 'Ustilaginomycetes'
            when (s.organism like 'Rhizopus%' or
                  s.organism like 'Mucor%' or
                  s.organism like 'Phycomyces%')
            then 'Zygomycetes'
            else 'Missing ProjectIdTaxonLevel'
          end as taxon_node,
          s.organism as organism
        from GenomicSequenceAttributes s
        where s.project_id = 'FungiDB'
	]]>
    </sql>
  </tuningTable>

  <tuningTable name="OrganismTree">
    <comment> Group species by higher level taxonomy. Each row associates a taxon of
         interest with one of its ancestors in the taxon tree. Used in parameter
         queries that have to know about the taxon tree, as well as
         apidb.project_id(), the function that maps an organism name to a
         project. Propagated to portal instances.
      </comment>
    <internalDependency name="ProjectIdTaxonLevel"/>
    <internalDependency name="GenomicSequenceAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.Taxon"/>
    <intermediateTable name="StrainTree"/>
    <sql>
      <![CDATA[
CREATE TABLE StrainTree NOLOGGING AS
SELECT *
FROM (         SELECT organism,term,parentTerm, internal,project_id
         FROM (
           /* all organisms from GenomicSequenceAttributes as organism, organism as term, parentterm is species            */
           SELECT DISTINCT sa.organism AS organism,
                           sa.organism AS term,
                           sn.name AS parentTerm,
                           t.taxon_id AS internal,
                           sa.project_id AS project_id
           FROM GenomicSequenceAttributes sa, sres.TaxonName tn,
                sres.Taxon t, sres.TaxonName sn, TaxonSpecies ts
           WHERE tn.name = sa.organism
           AND  ts.taxon_id = tn.taxon_id
           AND  sn.taxon_id = ts.species_taxon_id
           AND t.taxon_id = ts.taxon_id
           AND sn.name_class = 'scientific name'
           AND t.rank != 'species'
           UNION
           /* all organisms from GenomicSequenceAttributes as organism, species as term, parentterm is genus   */
           /* we are getting a row for species level AND for children here */
           SELECT DISTINCT sa.organism,  
                          sn.name AS term,
                          SUBSTR(sa.organism,0,(INSTR(sa.organism,' ') - 1)) AS parentTerm,
                          tn.taxon_id AS internal,
                          sa.project_id AS project_id
           FROM GenomicSequenceAttributes sa, sres.Taxon t, 
                sres.TaxonName tn, sres.TaxonName sn,
                TaxonSpecies ts
           WHERE tn.name = sa.organism
           AND  ts.taxon_id = tn.taxon_id
           AND  sn.taxon_id = ts.species_taxon_id
           AND t.taxon_id = ts.taxon_id
           AND sn.name_class = 'scientific name'
           UNION 
           SELECT DISTINCT sa.organism,
                          sn.name AS term,
                          SUBSTR(sa.organism,0,(INSTR(sa.organism,' ') - 1)) AS parentTerm,
                          sn.taxon_id AS internal,
                          sa.project_id AS project_id
           FROM GenomicSequenceAttributes sa, sres.Taxon t, 
                sres.TaxonName tn, sres.TaxonName sn,
                TaxonSpecies ts
           WHERE tn.name = sa.organism
           AND  ts.taxon_id = tn.taxon_id
           AND  sn.taxon_id = ts.species_taxon_id
           AND t.taxon_id = ts.taxon_id
           AND sn.name_class = 'scientific name'
           UNION
           /* all organisms from GenomicSequenceAttributes as organism, genus as term, parentterm from taxonlevel */
           SELECT DISTINCT sa.organism,      
                           SUBSTR(sa.organism,0,(INSTR(sa.organism,' ') - 1)) AS term,
                           ptl.taxon_node AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSequenceAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
           AND ptl.organism = sa.organism
           and ptl.organism not like 'Chromera%'
           and ptl.organism not like 'Vitrella%' 
           UNION
           /* all organisms from GenomicSequenceAttributes as organism, taxon_node as term, parentterm is null */
           SELECT DISTINCT sa.organism,               
                           ptl.taxon_node AS term,
                           '' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSequenceAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism
            and ptl.project_id not in ('FungiDB','MicrosporidiaDB')
            and ptl.organism not like 'Chromera%'
            and ptl.organism not like 'Vitrella%' 
            UNION
            -- add the kingdom for Fungi organism (this includes MicrosporidiaDB organisms)
            SELECT DISTINCT sa.organism,               
                           ptl.taxon_node AS term,
                           'Fungi' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSequenceAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism
            and ptl.project_id in ('FungiDB','MicrosporidiaDB')
            and ptl.taxon_node != 'Oomycetes'
            UNION
            SELECT DISTINCT sa.organism,               
                           'Fungi' AS term,
                           '' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSequenceAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism
            and ptl.project_id in ('FungiDB','MicrosporidiaDB')
            and ptl.taxon_node != 'Oomycetes'
            UNION
            -- add the kingdom for Oomycetes in FungiDB
            SELECT DISTINCT sa.organism,               
                           ptl.taxon_node AS term,
                           'Oomycetes' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSequenceAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism
            and ptl.taxon_node = 'Oomycetes'
            UNION
            SELECT DISTINCT sa.organism,               
                           'Oomycetes' AS term,
                           '' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSequenceAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism
            and ptl.taxon_node = 'Oomycetes'
                        UNION
            -- add the phylum for chomera and vitrella
          SELECT DISTINCT sa.organism,               
                            SUBSTR(sa.organism,0,(INSTR(sa.organism,' ') - 1)) AS term,
                           'Chromerida' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSequenceAttributes sa
           WHERE sa.organism like 'Chromera%'
            or sa.organism like 'Vitrella%'
            UNION
            SELECT DISTINCT sa.organism,               
                           'Chromerida' AS term,
                           '' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSequenceAttributes sa
           WHERE sa.organism like 'Chromera%'
            or sa.organism like 'Vitrella%'           
))
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE OrganismTree&1 NOLOGGING AS
         SELECT organism,term,parentTerm, internal,project_id
         FROM (
               SELECT * from StrainTree
               UNION
               SELECT stn.name as organism,
                      st.term as term,
                      st.parentTerm as parentTerm,
                      st.internal as internal,
                      st.project_id as project_id
               FROM StrainTree st, TaxonSpecies ts, sres.TaxonName tn, sres.TaxonName stn
               WHERE tn.taxon_id = ts.taxon_id
                 AND stn.taxon_id = ts.species_taxon_id
                 AND st.organism = tn.name
                 AND tn.name_class = 'scientific name'
                 AND stn.name_class = 'scientific name'
                 AND st.organism != st.term
          )
    	]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrganismAbbreviationBlast">
    <comment> Each record maps an organism to its BLAST abbreviation. Used by
         BLAST-query parameters. Propagated to portal instances.
      </comment>
    <internalDependency name="OrganismAbbreviationWS"/>
    <internalDependency name="OrganismTree"/>
    <internalDependency name="EstAttributes"/>
    <sql>
      <![CDATA[
       create table OrganismAbbreviationBlast&1 nologging as
       select organism, parent, abbreviation, project_id from OrganismAbbreviationWS
         union
      /* All familes for isolates */
      select distinct family_name_for_files || ' Popset/Genbank Isolates' as organism, '' as parent, family_name_for_files as abbreviation, project_name as project_id
      from apidb.Organism 
       where family_name_for_files is not null
       and family_name_for_files NOT IN ('Culicosporidae', 'Dubosqiidae', 'Pleistophoridae')
       union
       select special.organism, special.parent, special.abbreviation, ot.project_id from OrganismTree ot,
       (
  /* All species and speciesAbbreviations from apidb.Organism where we have ests */
  select distinct sp.name as organism,
                  ot.parentTerm as parent,
                  REGEXP_REPLACE(org.name_for_filenames, org.strain_abbrev,'', 1, 1) as abbreviation 
  from sres.TaxonName sp, taxonspecies ts, apidb.Organism org, organismtree ot,
       estattributes ea, sres.TaxonName etn, taxonspecies ets
  where org.taxon_id = ts.taxon_id
  and ts.species_taxon_id = sp.taxon_id
  and sp.name_class = 'scientific name'
  and ot.term = sp.name
  and org.strain_abbrev is not null
  and org.name_for_filenames is not null
  and ets.species_taxon_id = sp.taxon_id
  and (ets.taxon_id = etn.taxon_id OR ets.species_taxon_id = etn.taxon_id)
  and etn.name = ea.organism
  union
  /* TrichDB EST Legacy */
/*  select 'Trichomonas vaginalis' as organism, 'Trichomonas' as parent, 'Tvaginalis' as abbreviation from dual union   */
  /* */
  select 'Cryptosporidiidae SSU_18srRNA Reference Isolates' as organism, 'Cryptosporidium' as parent, 'CryptosporidiidaeReference' as abbreviation from dual
) special
      where special.parent = ot.term
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="BlastTypes">
    <comment> For each project, show which BLAST databases are available for which
         species. Used in BLAST param queries. Propagated to portal instances.
      </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="GenomicSequenceAttributes"/>
    <internalDependency name="EstAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
       create table BlastTypes&1 nologging as
  /* Standard GENES */
  select distinct organism, project_id, type 
  from TranscriptAttributes,
       (select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  where organism not in ('Toxoplasma gondii RH') and gene_type = 'protein coding' 
  UNION
  /* TrichDB Repeat Genes */
  select distinct organism || ' (Repeated Genes)', project_id, type 
  from TranscriptAttributes,
       (select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  where project_id = 'TrichDB'
  UNION
  /* GiardiaDB Deprecated Genes */
  select 'Giardia Assemblage A isolate WB (deprecated)' as organism, 'GiardiaDB' as project_id, type 
  from dual, (select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  UNION
  /* GiardiaDB Scaffolds */
  select 'Giardia Assemblage A isolate WB (scaffolds)' as organism, 'GiardiaDB' as project_id, type 
  from dual, (select 'Genome' as type from dual)
  UNION  
  /* Standard GENOME */
  select distinct organism, project_id, type 
  from GenomicSequenceAttributes,
       (select 'ORFs_AA' as type from dual union select 'Genome' as type from dual)
  UNION
  /* Mitochondrial GENES and GENOME */
  select distinct organism || ' mitochondrial', project_id, type 
  from GenomicSequenceAttributes,       
  (select 'ORFs_AA' as type from dual union select 'Genome' as type from dual union select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  where so_id = 'SO:0000819'
  and not project_id='PlasmoDB' 
  UNION
  /* Plastid GENES and GENOME */
  select distinct organism || ' plastid' as organism, project_id, type 
  from GenomicSequenceAttributes,       
  (select 'ORFs_AA' as type from dual union select 'Genome' as type from dual union select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  where so_id = 'SO:0001259'
  and not project_id='PlasmoDB' 
  UNION
  /* Regular ESTs (all species from estattributes) */
  select distinct sp.name as organism, ea.project_id, 'ESTs' as type
  from EstAttributes ea, sres.TaxonName tn, taxonspecies ts, sres.TaxonName sp
  where ea.organism = tn.name
  and (tn.taxon_id = ts.taxon_id or tn.taxon_id=ts.species_taxon_id)
  and ts.species_taxon_id = sp.taxon_id
  and sp.name_class = 'scientific name'
  UNION
  /* regular Isolates */
  select distinct family_name_for_files || ' Popset/Genbank Isolates' as organism, project_name as project_id, 'Isolates'
  from apidb.Organism 
  where family_name_for_files is not null
  UNION
  /* isolates are hard coded */
  select 'P. falciparum Barcode Isolates' as organism, 'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'P. berghei Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'P. chabaudi Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'P. falciparum Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'P. knowlesi Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'P. reichenowi Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'P. vivax Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'P. yoelii Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'All Giardia Isolates' as organism, 'GiardiaDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'Cryptosporidiidae SSU_18srRNA Reference Isolates' as organism, 'CryptoDB' as project_id, 'Isolates' as type from dual
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="CompoundAttributes"  prefixEnabled="true">
    <comment> The BFMV for the compound WDK record type. Used by the model for the
         compound record and queries, as well as in the creation of the
         PathwayCompounds tuning table. Propagated to portal instances.
      </comment>
    <externalDependency name="apidb.PubChemSubstance"/>
    <externalDependency name="apidb.PubChemCompound"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixCompoundAttributes&1 NOLOGGING AS
SELECT comp.compound_id,  'CID:' || comp.compound_id AS source_id, 
              substr(apidb.tab_to_string(set(cast(COLLECT(to_char(nameTable.name)) AS apidb.varchartab)), ', '), 1, 400) AS preferred_name,
              substr(apidb.tab_to_string(set(cast(COLLECT(to_char(nameTable.name)) AS apidb.varchartab)), ', '), 1, 400) AS compound_name,
	      substr(apidb.tab_to_string(set(cast(COLLECT(to_char(substSyns.name)) AS apidb.varchartab)), ', '), 1, 400) AS substance_name,
	      substr(apidb.tab_to_string(set(cast(COLLECT(to_char(iupacTable.iupac_name)) AS apidb.varchartab)), ', '), 1, 400) AS iupac_name,
              substr(apidb.tab_to_string(set(cast(COLLECT(to_char(substTable.substance_id)) AS apidb.varchartab)), ', '), 1, 80) AS substance_id,
              substr(wtTable.mol_wt, 1, 20) as mol_wt,
              substr(REGEXP_REPLACE(formTable.formula,'(\d)','<sub>\1</sub>'), 1, 300) AS formula
        FROM apidb.PubChemCompound comp,
                  (SELECT compound_id , value as name FROM apidb.PubChemCompound where property='Name') nameTable,
                  (SELECT compound_id , value as mol_wt FROM apidb.PubChemCompound where property='MolecularWeight') wtTable,
                  (SELECT compound_id , value as formula FROM apidb.PubChemCompound where property='MolecularFormula') formTable,
                  (SELECT compound_id , value as iupac_name FROM apidb.PubChemCompound where property='IUPACName') iupacTable,
                  (SELECT substance_id, value as cid FROM apidb.PubChemSubstance where property='CID' )  substTable,
                  (SELECT compound_id, name FROM (
        SELECT  c.compound_id,  apidb.tab_to_string(set(cast(COLLECT(s2.value) as apidb.varchartab)),'_MULTIPLE_') as name
	FROM apidb.PubChemSubstance s1, apidb.PubChemSubstance s2, apidb.PubChemCompound c
	WHERE s1.property='CID' and s2.property = 'Synonym'
	AND  s1.substance_id = s2.substance_id
	AND  s1.value=c.compound_id
	AND NOT  REGEXP_LIKE(s2.value, '^C(\d)+$')    /* exclude KEGG Copmpound IDs */
	AND NOT  REGEXP_LIKE(s2.value, '^(\d)+(\-)')  /* exclude entries like '24959-67-9'  */
	AND c. property = 'Synonym' AND c.value = s2.value
	GROUP by c.compound_id
	) WHERE name NOT LIKE '%_MULTIPLE_%') substSyns
       WHERE comp.compound_id = nameTable.compound_id (+)
       AND comp.compound_id = wtTable.compound_id
       AND comp.compound_id = formTable.compound_id
       AND comp.compound_id = iupacTable.compound_id (+)
       AND comp.compound_id = substTable.cid (+)
       AND comp.compound_id = substSyns.compound_id (+)
       GROUP BY comp.compound_id,wtTable.mol_wt,formTable.formula
      ]]>
    </sql>
    <sql>
      <![CDATA[
update &prefixCompoundAttributes&1
set preferred_name = substance_name
where preferred_name is NULL
      ]]>
    </sql>
    <sql>
      <![CDATA[
update &prefixCompoundAttributes&1
set preferred_name = iupac_name
where preferred_name is NULL
      ]]>
    </sql>

  </tuningTable>

<!--
  <tuningTable name="PathwayCompounds">
    <comment> Each record represents a 5-tuple of (reaction, compound, pathway,
         enzyme, type). Used extensively in the model for pathway-related
         queries, as well as by getImageMap.pl.
      </comment>
    <internalDependency name="CompoundAttributes"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.AaSequenceEnzymeClass"/>
    <externalDependency name="sres.EnzymeClass"/>
    <externalDependency name="apidb.Network"/>
    <externalDependency name="apidb.NetworkNode"/>
    <externalDependency name="apidb.NetworkRelationship"/>
    <externalDependency name="apidb.NetworkRelationshipType"/>
    <externalDependency name="apidb.NetworkContext"/>
    <externalDependency name="apidb.NetworkRelContext"/>
    <externalDependency name="apidb.NetworkRelContextLink"/>
    <externalDependency name="apidb.PubChemSubstance"/>
    <sql>
      <![CDATA[
CREATE TABLE PathwayCompounds&1 NOLOGGING AS
SELECT  '@PROJECT_ID@' AS project_id, ca.compound_id, ca.source_id AS compound_source_id, x.*
FROM   apidb.PubChemSubstance s1, apidb.PubChemSubstance s2, CompoundAttributes ca,
    (  /* CASE  A :  NOT reversible */
      SELECT  CASE WHEN nn1.node_type_id = 2 THEN nn1.display_label
                 WHEN nn2.node_type_id = 2 THEN nn2.display_label
                 ELSE 'None' END AS compound,
            CASE WHEN nn1.node_type_id = 1 THEN REPLACE(nn1.display_label, '_X:_Y:','')
                 WHEN nn2.node_type_id = 1 THEN REPLACE(nn2.display_label, '_X:_Y:','')
                 ELSE 'None' END AS enzyme,
             CASE  WHEN (nrc.source_node = 0 and nn1.node_type_id = 1) THEN  'product' /* reaction from enzyme to compound */
                      ELSE 'substrate' END AS type,
              nrt.display_name AS reaction,
              nc.description ||' ('||nc.name||')' AS pathway, nc.name AS name, nc.network_context_id
     FROM apidb.NetworkRelationshipType nrt, apidb.NetworkRelContext nrc, apidb.NetworkRelationship nr,
              apidb.NetworkRelContextLink nrl, apidb.NetworkContext nc,
              apidb.NetworkNode nn1, apidb.NetworkNode nn2
     WHERE nrc.network_relationship_type_id = nrt.network_relationship_type_id
           /* source_node = 1 means irreversible (this is an adjustment as network schema cant store reversibility) */
            AND nrc.source_node = 1 
     	    AND nrc.network_relationship_id = nr.network_relationship_id
	    AND nr.node_id = nn1.network_node_id
      	    AND nr.associated_node_id = nn2.network_node_id
      	    AND  nrl.network_rel_context_id = nrc.network_rel_context_id
      	    AND  nc.network_context_id = nrc.network_context_id
     UNION
      /* CASE  B :   reversible */
     SELECT  nn2.display_label as compound, REPLACE(nn1.display_label, '_X:_Y:','') AS enzyme, 
                  'substrate/product' AS type,
                  nrt.display_name AS reaction, 
                  nc.description ||' ('||nc.name||')' as pathway, nc.name AS name, nc.network_context_id
       FROM apidb.NetworkRelationshipType nrt, apidb.NetworkRelContext nrc, apidb.NetworkRelationship nr,
              apidb.NetworkRelContextLink nrl, apidb.NetworkContext nc,
              apidb.NetworkNode nn1, apidb.NetworkNode nn2
     WHERE nrc.network_relationship_type_id = nrt.network_relationship_type_id
           /* source_node = 0 means reversible (this is an adjustment as network schema cant store reversibility) */
      	   AND nrc.source_node = 0 
      	   AND nrc.network_relationship_id = nr.network_relationship_id
      	   AND nr.node_id = nn1.network_node_id
      	   AND nr.associated_node_id = nn2.network_node_id
      	   AND  nrl.network_rel_context_id = nrc.network_rel_context_id
      	   AND  nc.network_context_id = nrc.network_context_id
      	   AND nn1.node_type_id = 1
     	   ) x
WHERE s1.property = 'CID'
      AND  s1.value = ca.compound_id 
      AND  s1.substance_id = s2.substance_id
      AND  (s2.value = x.compound)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="CompoundTypeAheads">
    <comment> for use in GenesByReactionCompounds question </comment>
    <internalDependency name="CompoundAttributes"/>
    <internalDependency name="PathwayCompounds"/>
    <sql>
      <![CDATA[
        CREATE TABLE CompoundTypeAheads&1 NOLOGGING AS
        SELECT TO_CHAR(ca.compound_id) AS compound_id,
              TO_CHAR(ca.compound_id)  || ' (' || ca.preferred_name || ')' AS display
        FROM  CompoundAttributes ca, PathwayCompounds pc
        WHERE  pc.compound_id = ca.compound_id
        UNION
        SELECT TO_CHAR(ca.compound_id) AS compound_id,
              pc.compound || ' (' || ca.preferred_name || ')' AS display
        FROM  CompoundAttributes ca, PathwayCompounds pc
        WHERE  pc.compound_id = ca.compound_id
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="MSPeptideSummary">
    <comment> Each row stores mass-spec. based expression evidence for one sample of
         one experiment for one gene. Used for mass spec queries in the model,
         GBrowse, and PBrowse, and also in the creation of the MSGeneSummary
         tuning table.
      </comment>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="MassSpecTerms"/>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="dots.AAFeature"/>
    <externalDependency name="dots.AALocation"/>
    <externalDependency name="Sres.ExternalDatabase"/>
    <externalDependency name="Sres.ExternalDatabaseRelease"/>
    <intermediateTable name="MSExptTrustedSpectrum"/>
    <sql>
<![CDATA[
create table MSExptTrustedSpectrum nologging as        
select distinct mss.external_database_release_id, mss.sample_file
from apidb.massspecsummary mss, dots.massspecfeature msf
where mss.mass_spec_summary_id = msf.source_id
      ]]>
    </sql>        
    <sql>
    <![CDATA[
create table MSPeptideSummary&1 nologging as
select dbms_lob.SUBSTR(seq.SEQUENCE,
                            pep.aa_end_max - pep.aa_start_min + 1,
                            pep.aa_start_min) as peptide_sequence,
       pep.*
from dots.aasequence seq, (
select ga.source_id, 
       mss.sample_file, 
       nvl(dsp.display_name, sample) as experiment,
       d.name as external_database_name,
       sum(msf.spectrum_count) as spectrum_count,
       mss.aa_sequence_id,
       l.start_min as aa_start_min,
       l.end_max as aa_end_max,
       mst.html_color, mst.internal_id, mst.organism, mst.project_id, mst.sample, mst.sort_order
from apidb.massspecsummary mss, dots.massspecfeature msf, dots.aalocation l, 
     geneattributes ga, Msexpttrustedspectrum good, sres.externaldatabase d,
     sres.externaldatabaserelease r, massspecterms mst, datasetnametaxon dsnt, datasetpresenter dsp
where mss.mass_spec_summary_id = msf.source_id
and msf.aa_feature_id = l.aa_feature_id
and mss.aa_sequence_id = ga.aa_sequence_id (+)
and mss.external_database_release_id = r.external_database_release_id
and r.external_database_id = d.external_database_id
and d.name = dsnt.name (+)
and dsnt.dataset_presenter_id = dsp.dataset_presenter_id (+)
and (d.name || '|' || mss.sample_file = mst.internal_id OR d.name = mst.internal_id)
and mss.external_database_release_id = good.external_database_release_id (+)
and mss.sample_file = good.sample_file (+)
group by d.name, ga.source_id, mss.sample_file, dsp.display_name, 
         mss.aa_sequence_id, mss.spectrum_count, l.start_min, l.end_max, good.external_database_release_id, 
         mst.html_color, mst.internal_id, mst.organism, mst.project_id, mst.sample, mst.sort_order
) pep
where pep.aa_sequence_id = seq.aa_sequence_id
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="MSGeneSummary">
    <comment> Mass-spec experiment results for a gene. Used in the model for queries
         related to genes.
      </comment>
    <internalDependency name="MSPeptideSummary"/>
    <sql>
    <![CDATA[
create table MSGeneSummary&1 nologging as
select msps.source_id, msps.external_database_name, msps.experiment, msps.sample, msps.sample_file, msps.internal_id, msps.organism, msps.project_id, sum(msps.spectrum_count) as spectrum_count, count(*) as sequence_count
from mspeptidesummary msps
where source_id is not null
group by msps.source_id, msps.external_database_name, msps.experiment, msps.sample, msps.sample_file, msps.internal_id, msps.organism, msps.project_id
      ]]>
    </sql>
    <sql>
    <![CDATA[
      create index msgs_ix&1 on MSGeneSummary&1 (source_id, project_id)
      tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="MSModifiedPeptideSummary">
    <comment> Mass-spec experiment results for a peptide. Used by the model, GBrowse,
         and PBrowse.
      </comment>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="MassSpecTerms"/>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="dots.AAFeature"/>
    <externalDependency name="dots.AALocation"/>
    <externalDependency name="Sres.ExternalDatabase"/>
    <externalDependency name="Sres.ExternalDatabaseRelease"/>
    <externalDependency name="Sres.SequenceOntology"/>
    <externalDependency name="apidb.massSpecSummary"/>
    <externalDependency name="apidb.massSpecSummary"/>
    <sql>
    <![CDATA[
create table MSModifiedPeptideSummary&1 nologging as
select dbms_lob.substr(seq.sequence, pep.aa_end_max - pep.aa_start_min + 1,
              pep.aa_start_min)                                   as
       peptide_sequence,
       dbms_lob.substr(seq.sequence, 1, pep.residue_location + 1) as residue,
       pep.*
from   dots.aasequence seq,
       (select ga.source_id                     as source_id,
               so.term_name                     as modification_type,
               nvl(dsp.display_name, sample)    as experiment,
               ed.name                          as external_database_name,
               mss.external_database_release_id as external_database_release_id,
               mst.sample                       as Sample,
               mss.sample_file                  as sample_file,
               mss.aa_sequence_id               as aa_sequence_id,
               msf.aa_feature_id                as peptide_aa_feature_id,
               msf.spectrum_count               as spectrum_count,
               mst.html_color                   as html_color,
               aal.start_min                    as residue_location,
               aalp.start_min                   as aa_start_min,
               aalp.end_max                     as aa_end_max,
               pot.description                  as description
        from   dots.posttranslationalmodfeature pot,
               dots.massspecfeature msf,
               apidb.massspecsummary mss,
               dots.aalocation aal,
               dots.aalocation aalp,
               massspecterms mst,
               sres.sequenceontology so,
               geneattributes ga,
               sres.externaldatabase ed,
               sres.externaldatabaserelease edr,
               datasetnametaxon dsnt,
               datasetpresenter dsp
        where  pot.parent_id = msf.aa_feature_id
           and pot.aa_feature_id = aal.aa_feature_id
           and msf.aa_feature_id = aalp.aa_feature_id
           and msf.source_id = mss.mass_spec_summary_id
           and mss.aa_sequence_id = ga.aa_sequence_id
           and mss.external_database_release_id =
               edr.external_database_release_id
           and ed.name = dsnt.name (+)
           and dsnt.dataset_presenter_id = dsp.dataset_presenter_id (+)
           and ( ed.name || '|' || mss.sample_file = mst.internal_id
                 or ed.name = mst.internal_id )
           and edr.external_database_id = ed.external_database_id
           and pot.sequence_ontology_id = so.sequence_ontology_id) pep
where  pep.aa_sequence_id = seq.aa_sequence_id 
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Ssgcid" alwaysUpdate="true">
    <comment> Data from the Seattle Structural Genomics Center for Infectious Disease,
         populated from their web service. Used in the gene record.
      </comment>
    <program commandLine="buildSsgcidTT"/>
  </tuningTable>


  <tuningTable name="MassSpecTerms" alwaysUpdate="true">
    <comment> Used by the model and GBrowse, as well as an input in the creation of
         the tuning tables MSModifiedPeptideSummary and MSPeptideSummary.
      </comment>
    <program commandLine="buildMassSpecTermsTT_trunk"/>
  </tuningTable>


  <tuningTable name="GbrowseTracksOrganism" alwaysUpdate="true">
    <comment> Associates an organism with the GBrowse and PBrowse tracks available
         for it. Used by the gene record.
      </comment>
    <program commandLine="buildGbrowseImageUrlTT"/>
  </tuningTable>
-->

  <tuningTable name="DatasetPresenter" alwaysUpdate="true">
    <comment> Data for a dataset. Used widely in the model, and by GBrowse.
      </comment>
    <ancillaryTable name="DatasetContact"/>
    <ancillaryTable name="DatasetHyperLink"/>
    <ancillaryTable name="DatasetPublication"/>
    <ancillaryTable name="DatasetModelRef"/>
    <ancillaryTable name="DatasetNameTaxon"/>
    <ancillaryTable name="DatasetHistory"/>
    <program commandLine="buildDatasetPresentersTT"/>
  </tuningTable>


  <tuningTable name="EupathBuildDates" alwaysUpdate="true">

    <program commandLine="buildEupathBuildDatesTT"/>
  </tuningTable>

<!--
  <tuningTable name="DatasetDetail" alwaysUpdate="true">
    <comment> Stores text associated with each dataset. Used by dataset queries.
      </comment>
    <internalDependency name="DatasetPresenter"/>
    <sql>
      <![CDATA[
      create table DatasetDetail&1 nologging
      as
            select dataset_presenter_id, 
      name||' '||category||' '||usage||' '|| 
      caveat||' '||acknowledgement||' '||type||' '||subtype
      ||' '| |summary||' '||description||' '||contact||' '||
      institution||' '||pubmed_id||' '||citation as search_string
      from (
      select
      sub.dataset_presenter_id as dataset_presenter_id, 
      sub.name as name, 
      sub.category as category,
      sub.usage as usage, 
      sub.caveat as caveat,
      sub.acknowledgement as acknowledgement, 
      sub.type as type, 
      sub.subtype as subtype,
      sub.contact,
      sub.institution,
      sub.pubmed_id,
      sub.citation,
      dp.summary,
      dp.description
      from DatasetPresenter dp,
      (
      select distinct
      dp.dataset_presenter_id as dataset_presenter_id, 
      dp.display_name as name, 
      dp.display_category as category,
      dp.usage as usage, 
      dp.caveat as caveat,
      dp.acknowledgement as acknowledgement, 
      dp.type as type, 
      dp.subtype as subtype, 
      dc.name as contact,
      dc.affiliation as institution,
      LISTAGG(dpub.pmid, ' ') WITHIN GROUP (ORDER BY dpub.pmid) as pubmed_id,
      LISTAGG(dpub.citation, '  ') WITHIN GROUP (ORDER BY dpub.citation) as citation
      from DatasetPresenter dp, DatasetContact dc, 
           DatasetPublication dpub  
      where dp.dataset_presenter_id = dc.dataset_presenter_id
      and   dp.dataset_presenter_id = dpub.dataset_presenter_id
      and   dc.is_primary_contact = 1
      group by dp.dataset_presenter_id, dp.display_name,dp.display_category,
               dp.usage,dp.caveat,dp.acknowledgement,dp.type,dp.subtype,dc.name,
               dc.affiliation
      ) sub
      
      where dp.dataset_presenter_id = sub.dataset_presenter_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
          CREATE INDEX DATASET_DETAIL_IDX&1 ON DATASETDETAIL&1 (search_string)
          INDEXTYPE IS CTXSYS.CONTEXT
      ]]>
    </sql>

  </tuningTable>




  <tuningTable name="TrackOldAnnotation" alwaysUpdate="true">
    <comment> Stores changes in gene annotation. Used by the model for gene ID and
         table queries.
      </comment>
    <program commandLine="buildTrackOldAnnotationTT"/>
  </tuningTable>


  <tuningTable name="GeneTextSearch">
    <comment> For GenesByTextSearch
      </comment>
    <externalDependency name="apidb.GeneDetail"/>
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
        create table GeneTextSearch&1 nologging as
        select ga.source_id, ga.project_id, gd.field_name, gd.content, ga.taxon_id
        from GeneAttributes ga,
             (select source_id, project_id, field_name, content
              from apidb.GeneDetail
              where (source_id, project_id, field_name, modification_date)
                    in (select source_id, project_id, field_name, max(modification_date)
                        from apidb.GeneDetail
                        where field_name in ('Alias', 'CellularLocalization', 'CommunityAnnotation', 
                                             'EcNumber', 'GeneId', 'Notes', 'PreviousReleaseGenes', 
                                             'Product', 'GoTerms', 'MetabolicPathways', 'Phenotype', 
                                             'InterPro', 'RodMalPhenotype')
                        group by source_id, project_id, field_name)) gd
        where ga.source_id = gd.source_id
          and ga.project_id = gd.project_id
       ]]>
    </sql>
    <sql>
      <![CDATA[
        create index genetext_ix&1 on GeneTextSearch&1(content)
        indextype is ctxsys.context
        parameters('DATASTORE CTXSYS.DEFAULT_DATASTORE SYNC (ON COMMIT)')
      ]]>
    </sql>

  </tuningTable>


  <tuningTable name="ProteomicsCitation">
    <comment> Citation info for proteomics datasets, used by GBrowse </comment>
    <internalDependency name="DatasetPresenter"/>
    <internalDependency name="MSPeptideSummary"/>
    <sql>
      <![CDATA[
      create table ProteomicsCitation&1 nologging as
      with pubs
           as (select name, id, contact_email,
                      listagg(publication, ',') WITHIN GROUP (order by publication) as pmids
               from (select ds.name as name, ds.dataset_presenter_id as id,
                                    c.email as contact_email, p.pmid as publication
                     from DatasetPresenter ds, DatasetContact c,
                          DatasetPublication p
                     where ds.dataset_presenter_id = c.dataset_presenter_id
                       and ds.dataset_presenter_id = p.dataset_presenter_id
                       and c.is_primary_contact = 1
                       and ds.type = 'protein_expression'
                       and ds.subtype is null)
               group by name, id, contact_email),
           samples
           as (select name, id,
                      listagg(sample_i, chr(10)) WITHIN GROUP (order by sample) as sample_table
               from (select distinct ds.name as name,
                                     ds.dataset_presenter_id as id, sample,
                                     '<p style="color:' || html_color || '">' || sample || '</p>' as sample_i
                     from MSPeptideSummary mps, DatasetPresenter ds
                     where (ds.name = mps.external_database_name or mps.external_database_name like ds.dataset_name_pattern))
               group by name, id)
      select name,
             dbms_lob.substr(description, 4000, 1) || ' Primary Contact Email: '|| nvl(email, 'unavailable')
             || ' PMID: ' || publications || '<p style="color:black">Samples:</p>'
             || sample_table || chr(10) ||
             ' Please note that subtrack labels will disappear if the selected subtracks number is over 15!' as citation
      from (select ds.name as name, ds.summary as description, pubs.contact_email as email,
                   pubs.pmids as publications, samples.sample_table as sample_table
            from DatasetPresenter ds, pubs, samples
            where ds.dataset_presenter_id = pubs.id
              and ds.dataset_presenter_id = samples.id)
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EqtlSpan">


    <externalDependency name="dots.ChromosomeElementFeature"/>
    <externalDependency name="apidb.NAFeatureHaploblock"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="dots.NaLocation"/>
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
        create table eqtlSpan&1 nologging as
        select source_id, project_id, haplotype_block_name as hapblock_id, sequence_id,
               start_min, end_max, start_max, end_min,
               max(score) as lod_score, organism
        from (select ga.source_id, ga.project_id, gls.haplotype_block_name,
                     ens.source_id as sequence_id, nl.start_min, nl.end_max, nl.start_max, nl.end_min,
                     to_binary_double(gls.lod_score_mant|| 'e' || gls.lod_score_exp) as score,
                     replace (ga.organism, ' ', '+') as organism
              from dots.ChromosomeElementFeature cef, apidb.NAFeatureHaploblock gls,
                   dots.ExternalNaSequence ens, dots.NaLocation nl, GeneAttributes ga 
              where gls.na_feature_id = ga.na_feature_id
                and cef.name = gls.haplotype_block_name
                and nl.na_feature_id = cef.na_feature_id
                and cef.na_sequence_id = ens.na_sequence_id
                and to_binary_double(gls.lod_score_mant || 'e' || gls.lod_score_exp) >= 1.5)
        group by source_id, project_id, sequence_id, haplotype_block_name,
                 start_min, end_max, start_max, end_min, organism
       ]]>
    </sql>
    <sql>
      <![CDATA[
        create index eqtlSpan_ix&1 on eqtlSpan&1 (source_id, project_id)
      ]]>
    </sql>
  </tuningTable>
-->

</tuningConfig>
