<?xml version="1.0" encoding="UTF-8"?>
<tuningConfig>

  <tuningTable name="SampleId" prefixEnabled="false">
    <comment>Which protocol app nodes for sample record                                                                                                    
    </comment>
    <externalDependency name="study.ProtocolAppNode"/>
    <sql>
      <![CDATA[
create table SampleId&1 as 
select protocol_app_node_id, name from study.protocolappnode where isa_type = 'Sample'
union
select pan.protocol_app_node_id, pan.name
from study.study s
   , sres.externaldatabase d
   , sres.externaldatabaserelease r
   , study.protocolappnode pan
   , study.studylink sl
where s.external_database_release_id = r.external_database_release_id
and r.external_database_id = d.external_database_id
and s.study_id = sl.study_id
and sl.protocol_app_node_id = pan.protocol_app_node_id
and d.name like '%isolates_genbank_RSRC'
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrganismSelectTaxonRank" prefixEnabled="false">
    <comment>Taxon ranks for organisms                                                                                                     
    </comment>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.Taxon"/>
    <sql>
      <![CDATA[
create table OrganismSelectTaxonRank&1 as 
with organism_rank as (
select tn1.name as organism, o.public_abbrev, tn2.name as parent_organism, 
case when tn2.name = 'Oomycetes' then 'class' else r.rank end as rank

from (
select CONNECT_BY_ROOT taxon_id as input, taxon_id, rank
from sres.taxon
start with taxon_id in (select taxon_id from apidb.organism where is_annotated_genome = 1)
connect by prior parent_id = taxon_id) r
, sres.taxonname tn1
, sres.taxonname tn2
, apidb.organism o
where r.input = tn1.taxon_id
and r.taxon_id = tn2.taxon_id
and tn1.name_class = 'scientific name'
and tn2.name_class = 'scientific name'
and (r.rank in ('phylum', 'genus', 'species', 'kingdom', 'class') or (r.rank = 'no rank' and tn2.name = 'Oomycetes'))
and tn1.taxon_id = o.taxon_id
)

select organisms.organism, organisms.public_abbrev, nvl (phylum.parent_organism, 'N/A') as phylum, nvl ( genus.parent_organism, 'N/A') as genus, nvl(species.parent_organism, 'N/A') as species , nvl(kingdom.parent_organism, 'N/A') as kingdom, nvl (class.parent_organism, 'N/A') as class
from 
(select distinct organism, public_abbrev from organism_rank) organisms,
(select * from organism_rank where rank= 'phylum') phylum,
(select * from organism_rank where rank= 'genus') genus,
(select * from organism_rank where rank= 'species') species,
(select * from organism_rank where rank= 'kingdom') kingdom,
(select * from organism_rank where rank= 'class') class
where organisms.organism = phylum.organism (+)
and organisms.organism = genus.organism (+)
and organisms.organism = species.organism (+)
and organisms.organism = kingdom.organism (+)
and organisms.organism = class.organism (+)
 ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ExternalSequenceTaxonRank" prefixEnabled="false">
    <comment>Taxon ranks for 16S reference organisms                                                                                                     
    </comment>
    <externalDependency name="dots.ExternalNASequence"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.Taxon"/>
    <sql>
      <![CDATA[
create table ExternalSequenceTaxonRank&1 nologging as
with organism_rank as (
select tn1.taxon_id as organism, tn2.name as parent_organism, 
           tn2.taxon_id as parent_organism_id, r.rank
from (
select CONNECT_BY_ROOT taxon_id as input, taxon_id, rank
from sres.taxon
start with taxon_id in (  select taxon_id from DOTS.EXTERNALNASEQUENCE
                        union
                          select taxon_id from apidb.SequenceTaxon)
connect by prior parent_id = taxon_id) r
, sres.taxonname tn1
, sres.taxonname tn2
where r.input = tn1.taxon_id
and r.taxon_id = tn2.taxon_id
and tn1.name_class = 'scientific name'
and tn2.name_class = 'scientific name'
and r.rank in ('phylum', 'family','genus', 'species', 'superkingdom','kingdom', 'class', 'order')
)

select organisms.organism, 
        nvl(superkingdom.parent_organism, 'N/A') as superkingdom,
        superkingdom.parent_organism_id as superkingdom_id,
        nvl(kingdom.parent_organism, 'N/A') as kingdom,
        kingdom.parent_organism_id as kingdom_id,
        nvl (phylum.parent_organism, 'N/A') as phylum,
        phylum.parent_organism_id as phylum_id,
        nvl (class.parent_organism, 'N/A') as class,
        class.parent_organism_id as class_id,
        nvl (family.parent_organism, 'N/A') as family,
        family.parent_organism_id as family_id,
        nvl (rank_order.parent_organism, 'N/A') as rank_order,
        rank_order.parent_organism_id as rank_order_id,
        nvl ( genus.parent_organism, 'N/A') as genus,
        genus.parent_organism_id as genus_id,
        nvl(species.parent_organism, 'N/A') as species,
        species.parent_organism_id as species_id
from 
(select distinct organism from organism_rank) organisms,
(select * from organism_rank where rank= 'phylum') phylum,
(select * from organism_rank where rank= 'genus') genus,
(select * from organism_rank where rank= 'species') species,
(select * from organism_rank where rank= 'kingdom') kingdom,
(select * from organism_rank where rank= 'superkingdom') superkingdom,
(select * from organism_rank where rank= 'class') class,
(select * from organism_rank where rank= 'family') family,
(select * from organism_rank where rank= 'order') rank_order
where organisms.organism = phylum.organism (+)
and organisms.organism = genus.organism (+)
and organisms.organism = species.organism (+)
and organisms.organism = kingdom.organism (+)
and organisms.organism = class.organism (+)
and organisms.organism = rank_order.organism (+)
and organisms.organism = family.organism (+)
and organisms.organism = superkingdom.organism (+)
 ]]>
    </sql>
  </tuningTable>

  <tuningTable name="TaxonAbundance" prefixEnabled="false">
    <comment>otu relative abundance values, aggegated at various taxonomic levels
    </comment>
    <externalDependency name="results.OtuAbundance"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <internalDependency name="ExternalSequenceTaxonRank"/>
    <sql>
      <![CDATA[
        CREATE TABLE TaxonAbundance&1 NOLOGGING AS
        WITH leaf_abundance
        AS (SELECT oa.protocol_app_node_id, oa.raw_count AS raw_count,
                   oa.relative_abundance AS relative_abundance,
                   CASE
                     WHEN st.taxon_id IS NOT NULL
                       THEN st.taxon_id
                     ELSE ens.taxon_id
                   END AS taxon_id
            FROM results.OtuAbundance oa, dots.ExternalNaSequence ens, apidb.SequenceTaxon st
            WHERE oa.na_sequence_id = ens.na_sequence_id
              AND ens.na_sequence_id = st.na_sequence_id(+)
           ),
        taxa_string_map
        AS (  SELECT DECODE(REPLACE(estr.kingdom, 'N/A', 'unknown'), 'unknown',
                            REPLACE(estr.superkingdom, 'N/A', 'unknown'), estr.kingdom) AS taxon_string
                     , 'kingdom' AS taxon_node
                     , nvl(kingdom_id, superkingdom_id) AS taxon_id
                     , 1 AS taxon_level
                     , la.protocol_app_node_id
                     , la.relative_abundance
                     , la.raw_count
              FROM ExternalSequenceTaxonRank estr, leaf_abundance la
              WHERE estr.organism = la.taxon_id
            UNION
              SELECT REPLACE(estr.phylum, 'N/A', 'unknown') AS taxon_string
                     , 'phylum' AS taxon_node
                     , phylum_id AS taxon_id
                     , 2 AS taxon_level
                     , la.protocol_app_node_id,la.relative_abundance
                     , la.raw_count
              FROM ExternalSequenceTaxonRank estr, leaf_abundance la
              WHERE estr.organism = la.taxon_id
            UNION
              SELECT REPLACE(estr.class, 'N/A', 'unknown') AS taxon_string
                     , 'class' AS taxon_node
                     , class_id AS taxon_id
                     , 3 AS taxon_level
                     , la.protocol_app_node_id,la.relative_abundance
                     , la.raw_count
                FROM ExternalSequenceTaxonRank estr, leaf_abundance la
              WHERE estr.organism = la.taxon_id
            UNION
              SELECT replace(estr.rank_order, 'N/A', 'unknown')as taxon_string
                     , 'order' AS taxon_node
                     , rank_order_id AS taxon_id
                     , 4 AS taxon_level
                     , la.protocol_app_node_id,la.relative_abundance
                     , la.raw_count
                FROM ExternalSequenceTaxonRank estr, leaf_abundance la
              WHERE estr.organism = la.taxon_id
            UNION
              SELECT replace(estr.family, 'N/A', 'unknown') AS taxon_string
                     , 'family' AS taxon_node
                     , family_id AS taxon_id
                     , 5 AS taxon_level
                     , la.protocol_app_node_id,la.relative_abundance
                     , la.raw_count
                FROM ExternalSequenceTaxonRank estr, leaf_abundance la
              WHERE estr.organism = la.taxon_id
            UNION
              SELECT replace(estr.genus, 'N/A', 'unknown') AS taxon_string
                     , 'genus' AS taxon_node
                     , genus_id AS taxon_id
                     , 6 AS taxon_level
                     , la.protocol_app_node_id,la.relative_abundance
                     , la.raw_count
              FROM ExternalSequenceTaxonRank estr, leaf_abundance la
              WHERE estr.organism = la.taxon_id
            UNION
              SELECT replace(estr.species, 'N/A', 'unknown') AS taxon_string
                     , 'species' AS taxon_node
                     , species_id AS taxon_id
                     , 7 AS taxon_level
                     , la.protocol_app_node_id,la.relative_abundance
                     , la.raw_count
              FROM ExternalSequenceTaxonRank estr, leaf_abundance la
              WHERE estr.organism = la.taxon_id
           ),
        agg_taxon_string_map
        AS (SELECT taxon_string AS taxon_name, taxon_node,
                   taxon_node || '|' || taxon_id AS taxon_id, taxon_level,
                   protocol_app_node_id, SUM(relative_abundance) AS relative_abundance,
                   SUM(raw_count) AS raw_count
            FROM taxa_string_map
            GROUP BY taxon_string, taxon_node, taxon_node || '|' || taxon_id,
                     taxon_level, protocol_app_node_id
           )
        SELECT tsm.protocol_app_node_id, pan.name AS pan_name,
               initcap(tsm.taxon_node) AS category, CAST(tsm.taxon_name AS VARCHAR2(200)) AS term,
               tsm.taxon_id AS term_id, ds.name AS dataset_name, ds.type, ds.subtype,
               study_release.study_name, study_release.investigation_name,
               tsm.taxon_level, tsm.raw_count AS agg_count, tsm.relative_abundance AS value
        FROM agg_taxon_string_map tsm,
             study.ProtocolAppNode pan,
             study.StudyLink sl,
             sres.ExternalDatabaseRelease edr,
             sres.ExternalDatabase ed,
             apidb.Datasource ds,
             (SELECT s.study_id, i.external_database_release_id,
                     s.name AS study_name, i.name AS investigation_name
              FROM study.Study s, study.Study i
              WHERE s.investigation_id = i.study_id
                AND s.name not like '%[%]%'
                AND i.name like 'OTU Profile%'
              ) study_release
        WHERE tsm.protocol_app_node_id = pan.protocol_app_node_id
          AND tsm.protocol_app_node_id = sl.protocol_app_node_id
          AND sl.study_id = study_release.study_id
          AND study_release.external_database_release_id = edr.external_database_release_id
          AND edr.external_database_id = ed.external_database_id
          AND ed.name = ds.name
 ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TaxAbund_panId_Term&1
          ON TaxonAbundance&1 (protocol_app_node_id, term_id,  category, term)
          TABLESPACE INDX
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="PathwayAttributes" prefixEnabled="false">
    <comment>Attributes for Metabolic Pathways
    </comment>
    <externalDependency name="sres.Pathway"/>
    <externalDependency name="sres.PathwayNode"/>
    <sql>
      <![CDATA[
create table PathwayAttributes&1 as
SELECT
  p.source_id
, p.pathway_id
, p.name
, enz.total_enzyme_count
, cpd.total_compound_count
, p.url
, replace(replace(ed.name, 'Pathways_', ''), '_RSRC', '') as pathway_source
, ed.name as external_db_name
, edr.version as external_db_version
FROM
  sres.pathway p
, sres.externalDatabase ed
, sres.externalDatabaseRelease edr
,(SELECT
    COUNT( *) AS total_compound_count
  , pathway_id
  FROM
    sres.pathwayNode pn
  , SRES.ontologyterm ot
  WHERE
    pn.pathway_node_type_id = ot.ontology_term_id
    AND ot.name = 'molecular entity'
  GROUP BY
    pathway_id
  ) cpd
,(SELECT
    COUNT( *) AS total_enzyme_count
  , pathway_id
  FROM
    sres.pathwayNode pn
  , SRES.ontologyterm ot
  WHERE
    pn.pathway_node_type_id = ot.ontology_term_id
    AND ot.name = 'enzyme'
  GROUP BY
    pathway_id
  ) enz
WHERE
  ed.external_database_id = edr.external_database_id
  AND edr.external_database_release_id = p.external_database_release_id
  AND cpd.pathway_id = p.pathway_id
  AND enz.pathway_id = p.pathway_id
  AND source_id NOT IN('ec01100', 'ec01110', 'ec01120')
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX PathAttr_sourceId_pwaySrc&1
          ON &prefixPathwayAttributes&1 (source_id, pathway_source)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index PathAttr_ix&1
        on PathwayAttributes&1 (pathway_id, source_id, name, pathway_source, total_enzyme_count, total_compound_count)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProtocolAppNodeResults" prefixEnabled="false">
    <comment>Table of protocol app node ids and the name of the result table where they are referenced
    </comment>
    <externalDependency name="results.NaFeatureDiffResult"/>
    <externalDependency name="results.ReporterIntensity"/>
    <externalDependency name="results.SegmentResult"/>
    <externalDependency name="results.CompoundMassSpec"/>
    <externalDependency name="results.NaFeatureHostResponse"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="results.EditingEvent"/>
    <externalDependency name="results.FamilyDiffResult"/>
    <externalDependency name="results.FamilyExpression"/>
    <externalDependency name="results.GeneDiffResult"/>
    <externalDependency name="results.GeneExpression"/>
    <externalDependency name="results.GeneSimilarity"/>
    <externalDependency name="results.ReporterDiffResult"/>
    <externalDependency name="results.ReporterExpression"/>
    <externalDependency name="results.RnaDiffResult"/>
    <externalDependency name="results.RnaExpression"/>
    <externalDependency name="results.SegmentDiffResult"/>
    <externalDependency name="results.SeqVariation"/>
    <externalDependency name="results.OtuAbundance"/>
    <externalDependency name="results.AlphaDiversity"/>    
    <externalDependency name="apidb.SequenceVariation"/>
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="apidb.ChrCopyNumber"/>
    <externalDependency name="apidb.GeneCopyNumber"/>
    <externalDependency name="apidb.IntronJunction"/>
    <externalDependency name="apidb.RflpGenotype"/>
    <externalDependency name="apidb.RflpGenotypeNumber"/>
    <externalDependency name="apidb.crisprphenotype"/>
    <sql>
      <![CDATA[
    create table ProtocolAppNodeResults&1 as
      select protocol_app_node_id, 'Results::NAFeatureDiffResult' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.NAFeatureDiffResult)
    union
      select protocol_app_node_id, 'Results::ReporterIntensity' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.ReporterIntensity)
    union
      select protocol_app_node_id, 'Results::SegmentResult' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.SegmentResult)
    union
      select protocol_app_node_id, 'Results::CompoundMassSpec' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.CompoundMassSpec)
    union
      select protocol_app_node_id, 'Results::NaFeatureHostResponse' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.NaFeatureHostResponse)
    union
      select protocol_app_node_id, 'ApiDB::ChrCopyNumber' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from ApiDB.ChrCopyNumber)
    union
      select protocol_app_node_id, 'ApiDB::GeneCopyNumber' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from ApiDB.GeneCopyNumber)
    union
      select protocol_app_node_id, 'Results::NAFeatureExpression' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.NAFeatureExpression)
    union
      select protocol_app_node_id, 'Results::EditingEvent' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.EditingEvent)
    union
      select protocol_app_node_id, 'Results::FamilyDiffResult' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.FamilyDiffResult)
    union
      select protocol_app_node_id, 'Results::FamilyExpression' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.FamilyExpression)
    union
      select protocol_app_node_id, 'Results::GeneDiffResult' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.GeneDiffResult)
    union
      select protocol_app_node_id, 'Results::GeneExpression' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.GeneExpression)
    union
      select protocol_app_node_id, 'Results::GeneSimilarity' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.GeneSimilarity)
    union
      select protocol_app_node_id, 'Results::ReporterDiffResult' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.ReporterDiffResult)
    union
      select protocol_app_node_id, 'Results::ReporterExpression' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.ReporterExpression)
      union
    select protocol_app_node_id, 'Results::RnaDiffResult' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.RnaDiffResult)
      union
    select protocol_app_node_id, 'Results::RnaExpression' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.RnaExpression)
      union
    select protocol_app_node_id, 'Results::OtuAbundance' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.OtuAbundance)
    union
    select protocol_app_node_id, 'Results::AlphaDiversity' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.AlphaDiversity)
    union
    select protocol_app_node_id, 'Results::SegmentDiffResult' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.SegmentDiffResult)
    union
      select protocol_app_node_id, 'Results::SeqVariation' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.SeqVariation)
    union
      select protocol_app_node_id, 'ApiDB::SequenceVariation' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from apidb.sequencevariation)
    union
      select protocol_app_node_id, 'ApiDB::MassSpecSummary' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from apidb.MASSSPECSUMMARY)
    union
      select protocol_app_node_id, 'ApiDB::IntronJunction' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from apidb.IntronJunction)
    union
      select protocol_app_node_id, 'ApiDB::RflpGenotype' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from apidb.RflpGenotype)
    union
      select protocol_app_node_id, 'ApiDB::RflpGenotypeNumber' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from apidb.RflpGenotypeNumber)
    union
      select protocol_app_node_id, 'ApiDB::CrisprPhenotype' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from apidb.crisprphenotype)
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="PANProtocolMetadata" prefixEnabled="false">
    <comment>
    </comment>
    <internalDependency name="ProtocolAppNodeResults"/>
    <internalDependency name="SampleId"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <externalDependency name="study.ProtocolApp"/>
    <externalDependency name="study.Input"/>
    <externalDependency name="study.Output"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Characteristic"/>
    <externalDependency name="study.Protocol"/>
    <externalDependency name="study.ProtocolParam"/>
    <externalDependency name="study.ProtocolAppParam"/>
    <ancillaryTable name="ProtocolAppNodeIO"/>
    <ancillaryTable name="PANCharacteristicMetadata"/>
    <ancillaryTable name="SampleCharMetadata"/>
    <ancillaryTable name="SampleProtocolMetadata"/>
    <ancillaryTable name="SampleDownstream"/>
    <ancillaryTable name="PANExternalDatabaseRelease"/>
    <ancillaryTable name="PANParameterValues"/>
    <sql>
      <![CDATA[
        create table ProtocolAppNodeIO&1 nologging as
        select i.protocol_app_node_ID input_node_id, pa.protocol_app_id, o.protocol_app_node_id output_node_id
        from study.ProtocolApp pa, study.Input i, study.Output o
        where i.protocol_app_id = pa.protocol_app_id
          and o.protocol_app_id = pa.protocol_app_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create table PANProtocolMetadata&1 nologging as
   with node_inputs
        as (select connect_by_root output_node_id as protocol_app_node_id, input_node_id, protocol_app_id
            from ProtocolAppNodeIO
            start with output_node_id in (select protocol_app_node_id from ProtocolAppNodeResults)
            connect by prior input_node_id = output_node_id
            )
         ,param_term_id
         as ( select pp.protocol_param_id, min(ot.ontology_term_id) as ontology_term_id  
              from STUDY.PROTOCOLPARAM pp, SRES.ONTOLOGYTERM ot
              where ot.name = pp.name
              group by pp.protocol_param_id
              )
        select node_inputs.protocol_app_node_id, ds.name as dataset_name,
               case
                       when lower(ds.name) like '%microarrayantibody%'
                            then 'Ontology_icemr_RSRC'
                       when lower(ds.name) like 'otu%'
                            then 'Ontology_microbiomeHierarchy_RSRC'
                       else null
                       end as hierarchy_dataset_name,
               p.name as category, pan.name as pan_name, pp.name as term, param_term_id.ontology_term_id as term_id,
               pap.value, pap.protocol_app_param_id, ds.type, ds.subtype, tn.name as organism,
               study_release.study_name, study_release.investigation_name
        from node_inputs, param_term_id, study.ProtocolAppParam pap, 
             study.ProtocolParam pp, study.Protocol p, study.StudyLink sl, 
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
             apidb.Datasource ds, study.ProtocolAppNode pan, sres.TaxonName tn,
             (  select s.study_id, i.external_database_release_id,
                       s.name as study_name, i.name as investigation_name
                from study.Study s, study.Study i
                where s.investigation_id = i.study_id
              union
                select s.study_id, s.external_database_release_id,
                       s.name as study_name, null as investigation_name
                from study.Study s) study_release
        where node_inputs.protocol_app_id = pap.protocol_app_id
          and pap.protocol_param_id = pp.protocol_param_id
          and pp.protocol_id = p.protocol_id
          and node_inputs.protocol_app_node_id = sl.protocol_app_node_id
          and sl.study_id = study_release.study_id
          and study_release.external_database_release_id = edr.external_database_release_id
          and edr.external_database_id = ed.external_database_id
          and ed.name = ds.name
          and node_inputs.protocol_app_node_id = pan.protocol_app_node_id
          and ds.taxon_id = tn.taxon_id(+)
          and (tn.name_class = 'scientific name' or tn.name_class is null)
          and p.name not like '%::%' -- avoid Perl class names
          and p.name not like '%data transformation' -- avoid data transformation protocol parameters
          and pp.PROTOCOL_PARAM_ID = param_term_id.protocol_param_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create table PANCharacteristicMetadata&1 nologging as
        with node_inputs
        as (select connect_by_root output_node_id as protocol_app_node_id, input_node_id, protocol_app_id
            from ProtocolAppNodeIO&1
            start with output_node_id in (select protocol_app_node_id from ProtocolAppNodeResults)
            connect by prior input_node_id = output_node_id
           )
select sample_pan.protocol_app_node_id, nvl(mt.name, 'assay') as category, attribute_term.name as term, -- if not a material type it has to be an assay
               attribute_term.ontology_term_id as term_id, 
               case when c.value is not null and LENGTH(TRIM(TRANSLATE(c.value, ' +-.0123456789', ' '))) is null 
                    then to_char(nvl(round(c.value, 2), 0))
                    else nvl(c.value, value_term.name)
               end as value,
               c.characteristic_id,
               ds.name as dataset_name, sample_pan.name as pan_name, ds.type,
               case
                       when lower(ds.name) like '%microarrayantibody%'
                            then 'Ontology_icemr_RSRC'
                       when lower(ds.name) like 'otu%'
                            then 'Ontology_microbiomeHierarchy_RSRC'
                       else null
                       end as hierarchy_dataset_name,
               ds.subtype, tn.name as organism,
               study_release.study_name, study_release.investigation_name
        from node_inputs, study.ProtocolAppNode pan, study.Characteristic c, sres.OntologyTerm value_term,
             sres.ontologyTerm mt, study.StudyLink sl,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed, sres.OntologyTerm attribute_term,
             apidb.Datasource ds, sres.TaxonName tn, study.ProtocolAppNode sample_pan,
             (  select s.study_id, i.external_database_release_id,
                       s.name as study_name, i.name as investigation_name
                from study.Study s, study.Study i
                where s.investigation_id = i.study_id
              union
                select s.study_id, s.external_database_release_id,
                       s.name as study_name, null as investigation_name
                from study.Study s) study_release
        where pan.protocol_app_node_id = c.protocol_app_node_id
          and pan.type_id = mt.ontology_term_id (+)
          and c.ontology_term_id = value_term.ontology_term_id(+)
          and c.qualifier_id = attribute_term.ontology_term_id(+)
          and node_inputs.input_node_id = pan.protocol_app_node_id
          and node_inputs.protocol_app_node_id = sl.protocol_app_node_id
          and sl.study_id = study_release.study_id
          and study_release.external_database_release_id = edr.external_database_release_id
          and edr.external_database_id = ed.external_database_id
          and ed.name = ds.name
          and node_inputs.protocol_app_node_id = sample_pan.protocol_app_node_id
          and ds.taxon_id = tn.taxon_id(+)
          and (tn.name_class = 'scientific name' or tn.name_class is null)
 and (mt.name is not null or attribute_term.name = 'average mapping coverage' or attribute_term.name ='proportion mapped reads') --temporary may need adjusting for RNASeq      
 ]]>
    </sql>
    <sql>
      <![CDATA[
      create table SampleCharMetadata&1 nologging as
     with node_inputs
        as (select connect_by_root output_node_id as protocol_app_node_id, input_node_id, protocol_app_id
            from protocolappnodeio&1
            start with output_node_id in (select protocol_app_node_id from sampleid)
            connect by prior input_node_id = output_node_id
           )
        select sample_pan.protocol_app_node_id, mt.name as category, attribute_term.name as term,
               attribute_term.ontology_term_id as term_id, nvl(c.value, value_term.name) as value, c.characteristic_id,
                sample_pan.name as pan_name
        from node_inputs, study.ProtocolAppNode pan, study.Characteristic c, sres.OntologyTerm value_term,
             sres.ontologyterm mt, 
             sres.ontologyterm attribute_term,
             study.ProtocolAppNode sample_pan
        where pan.protocol_app_node_id = c.protocol_app_node_id
          and pan.type_id = mt.ontology_term_id
          and c.ontology_term_id = value_term.ontology_term_id(+)
          and c.qualifier_id = attribute_term.ontology_term_id(+)
          and node_inputs.input_node_id = pan.protocol_app_node_id
          and node_inputs.protocol_app_node_id = sample_pan.protocol_app_node_id
        union
       select pan.protocol_app_node_id, mt.name, ot.name, ot.ontology_term_id, nvl(c.value, vot.name) as value, c.characteristic_id, pan.name
        from study.protocolappnode pan
           , sres.ontologyterm mt
           , study.characteristic c
           , sres.ontologyterm ot
           , sres.ontologyterm vot
        where pan.protocol_app_node_id in  (select protocol_app_node_id from sampleid)
         and pan.protocol_app_node_id = c.protocol_app_node_id
         and c.qualifier_id = ot.ontology_term_id
         and c.ontology_term_id = vot.ontology_term_id (+)
         and pan.type_id = mt.ontology_term_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create table SampleProtocolMetadata&1 nologging as
        with node_inputs
        as (select connect_by_root output_node_id as protocol_app_node_id, input_node_id, protocol_app_id
            from protocolappnodeio&1
            start with output_node_id in (select protocol_app_node_id from sampleid)
            connect by prior input_node_id = output_node_id
           )
        select node_inputs.protocol_app_node_id, 
               p.name as category, 
               pan.name as pan_name, 
               pp.name as term,
               pap.value, 
               pap.protocol_app_param_id
        from node_inputs
           , study.protocolappparam pap
           , study.protocolparam pp
           , study.protocol p
           , study.ProtocolAppNode pan
        where node_inputs.protocol_app_id = pap.protocol_app_id
          and pap.protocol_param_id = pp.protocol_param_id
          and pp.protocol_id = p.protocol_id
          and node_inputs.protocol_app_node_id = pan.protocol_app_node_id
          and p.name not like '%::%' -- avoid Perl class names
          and p.name not like '%data transformation'
      ]]>
    </sql>

    <sql>
      <![CDATA[
create table SampleDownstream&1 nologging as
SELECT
  p1.name
, p1.protocol_app_node_id
, p3.name as input
, p3.protocol_app_node_id as input_protocol_app_node_id
, case
    WHEN ot3.name LIKE 'data%'
    THEN 'Data'
    else p3.isa_type
  end as input_isa_type
, ot3.name as input_material_type
, p.name AS protocol
, p2.name AS output
, p2.protocol_app_node_id AS output_protocol_app_node_id
, case
    WHEN ot2.name LIKE 'data%'
    THEN 'Data'
    else p2.isa_type
  end as output_isa_type
, ot2.name AS output_material_type
FROM
  (SELECT
    connect_by_root input_node_id AS protocol_app_node_id
  , input_node_id
  , output_node_id
  , protocol_app_id
  from
    protocolappnodeio&1
    start with input_node_id in (SELECT protocol_app_node_id FROM sampleid)
    CONNECT BY prior output_node_id = input_node_id
  ) io
, study.protocolappnode p1
, study.protocolappnode p2
, study.protocolappnode p3
, sres.ontologyterm ot2
, sres.ontologyterm ot3
, study.protocol p
, study.protocolapp pa
WHERE
  io.protocol_app_node_id = p1.protocol_app_node_id
  and io.output_node_id = p2.protocol_app_node_id
  and io.input_node_id = p3.protocol_app_node_id
  and p2.type_id = ot2.ontology_term_id (+)
  and p3.type_id = ot3.ontology_term_id (+)
  and io.protocol_app_id = pa.protocol_app_id
  and pa.protocol_id = p.protocol_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
 create table PANExternalDatabaseRelease&1 nologging as
SELECT DISTINCT
  sl.protocol_app_node_id
, s.external_database_release_id
FROM
  study.study s
, study.studylink sl
WHERE
  s.study_id = sl.study_id
  and s.external_database_release_id is not null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create table PANParameterValues&1 nologging as
select
  p.name as protocol
, pp.name as protocol_param
, pap.value as protocol_param_value
, pan.name as protocol_app_node_name
, pan.protocol_app_node_id
FROM
  study.protocolappparam pap
, study.protocolparam pp
, study.protocol p
, protocolappnodeio&1 io
, study.protocolappnode pan
WHERE
  pp.protocol_param_id = pap.protocol_param_id
  AND p.protocol_id = pp.protocol_id
  AND io.protocol_app_id = pap.protocol_app_id
  AND io.output_node_id = pan.protocol_app_node_id
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="FallbackMetadata">
    <comment>
      For datasets that have results but no metadata, a fallback set of metadata comprising the name of each ProtocolAppNode
    </comment>
    <internalDependency name="ProtocolAppNodeResults"/>
    <internalDependency name="PANProtocolMetadata"/>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <sql>
      <![CDATA[
        create table FallbackMetadata&1 nologging as
        -- regular query for most datasets
        select ds.name as dataset_name, ds.type, ds.subtype, tn.name as organism,
              case
                       when lower(ds.name) like '%microarrayantibody%'
                            then 'Ontology_icemr_RSRC'
                       when lower(ds.name) like 'otu%'
                            then 'Ontology_microbiomeHierarchy_RSRC'
                       else null
                       end as hierarchy_dataset_name,
               pan.name as pan_name, pan.protocol_app_node_id, 'dataset' as term_name,
               study_release.study_name, study_release.investigation_name, dsp.display_name as value
        from study.ProtocolAppNode pan, apidb.Datasource ds, study.StudyLink sl,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
             sres.TaxonName tn,
             (  select s.study_id, i.external_database_release_id,
                       s.name as study_name, i.name as investigation_name
                from study.Study s, study.Study i
                where s.investigation_id = i.study_id
              union
                select s.study_id, s.external_database_release_id,
                       s.name as study_name, null as investigation_name
                from study.Study s) study_release, 
             DatasetPresenter dsp
        where pan.protocol_app_node_id in (select protocol_app_node_id
                                           from ProtocolAppNodeResults)
--        and ds.name not in (select dataset_name from PANProtocolMetadata)
--        and ds.name not in (select dataset_name from PANCharacteristicMetadata)
          and pan.protocol_app_node_id = sl.protocol_app_node_id
          and sl.study_id = study_release.study_id
          and study_release.external_database_release_id = edr.external_database_release_id
          and edr.external_database_id = ed.external_database_id
          and ed.name = ds.name
          and ds.taxon_id = tn.taxon_id(+)
          and ds.name = dsp.name (+)
          and (tn.name_class = 'scientific name' or tn.name_class is null)
UNION
        -- special query for reference strain
        select ed.name as dataset_name, 'SNP' as type, 'HTS_SNP' as subtype, tn.name as organism,
               null as hierarchy_dataset_name,
               o.strain_abbrev as pan_name, pan.protocol_app_node_id, 'dataset' as term_name,
               study_release.study_name, study_release.investigation_name, 'Reference Genome'
        from study.ProtocolAppNode pan, study.StudyLink sl,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
             sres.TaxonName tn, apidb.Organism o,
             (  select s.study_id, i.external_database_release_id,
                       s.name as study_name, i.name as investigation_name
                from study.Study s, study.Study i
                where s.investigation_id = i.study_id
              union
                select s.study_id, s.external_database_release_id,
                       s.name as study_name, null as investigation_name
                from study.Study s) study_release
        where pan.protocol_app_node_id in (select protocol_app_node_id
                                           from ProtocolAppNodeResults)
--        and ed.name not in (select dataset_name from PANProtocolMetadata)
--        and ed.name not in (select dataset_name from PANCharacteristicMetadata)
          and pan.protocol_app_node_id = sl.protocol_app_node_id
          and sl.study_id = study_release.study_id
          and study_release.external_database_release_id = edr.external_database_release_id
          and edr.external_database_id = ed.external_database_id
          and ed.name like '%_NGS_SNPsAndVariations'
          and o.abbrev = replace(ed.name, '_NGS_SNPsAndVariations', '')
          and o.taxon_id = tn.taxon_id(+)
          and (tn.name_class = 'scientific name' or tn.name_class is null)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="FallbackOrganism">
    <comment>
      Taxon metadata for reference SNPs
    </comment>
    <internalDependency name="ProtocolAppNodeResults"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <sql>
      <![CDATA[
        create table FallbackOrganism&1 nologging as
        select ed.name as dataset_name, 'SNP' as type, 'HTS_SNP' as subtype, tn.name as organism,
               o.strain_abbrev as pan_name, pan.protocol_app_node_id, 'name' as term_name,
               study_release.study_name, study_release.investigation_name
        from study.ProtocolAppNode pan, study.StudyLink sl,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
             sres.TaxonName tn, apidb.Organism o,
             (  select s.study_id, i.external_database_release_id,
                       s.name as study_name, i.name as investigation_name
                from study.Study s, study.Study i
                where s.investigation_id = i.study_id
              union
                select s.study_id, s.external_database_release_id,
                       s.name as study_name, null as investigation_name
                from study.Study s) study_release
        where pan.protocol_app_node_id in (select protocol_app_node_id
                                           from ProtocolAppNodeResults)
--        and ed.name not in (select dataset_name from PANProtocolMetadata)
--        and ed.name not in (select dataset_name from PANCharacteristicMetadata)
          and pan.protocol_app_node_id = sl.protocol_app_node_id
          and sl.study_id = study_release.study_id
          and study_release.external_database_release_id = edr.external_database_release_id
          and edr.external_database_id = ed.external_database_id
          and ed.name like '%_NGS_SNPsAndVariations'
          and o.abbrev = replace(ed.name, '_NGS_SNPsAndVariations', '')
          and o.taxon_id = tn.taxon_id(+)
          and (tn.name_class = 'scientific name' or tn.name_class is null)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="MetadataSpec">
    <comment>
    </comment>
    <internalDependency name="FallbackMetadata"/>
    <internalDependency name="PANProtocolMetadata"/>
    <internalDependency name="MetadataType"/>
    <sql>
      <![CDATA[
        create table MetadataSpec&1 nologging as
        select * from (
        with hierarchy_mapping
        as (select dataset_name,
                   case
                       when lower(dataset_name) like '%microarrayantibody%'
                            then 'Ontology_icemr_RSRC'
                       when lower(dataset_name) like 'otu%'
                            then 'Ontology_microbiomeHierarchy_RSRC'
                       else null
                       end as hierarchy_dataset_name
            from (  select dataset_name
                    from FallbackMetadata
                  union
                    select dataset_name
                    from panCharacteristicMetadata
                  union
                    select dataset_name
                    from panProtocolMetadata)),
        protocol_metadata
        as (select distinct organism, type, subtype, dataset_name, category, term, term_id, value
            from panProtocolMetadata),
        characteristic_metadata
        as (select distinct organism, type, subtype, dataset_name, category, term, term_id, value
            from panCharacteristicMetadata),
        metadata
        as (  select *
              from protocol_metadata
            union
              select *
              from characteristic_metadata),
        ontology_tree_metadata
        as (select distinct term_id, dataset_name, organism, type,subtype,
                            case
                              when lower(dataset_name) like '%microarrayantibody%'
                                   then 'Ontology_icemr_RSRC'
                              when lower(dataset_name) like 'otu%'
                                   then 'Ontology_microbiomeHierarchy_RSRC'
                              else null
                            end as hierarchy_dataset_name
            from PANCharacteristicMetadata
            where lower(dataset_name) like '%microarrayantibody%' or lower(dataset_name) like 'otu%'
           ),
        leaf_term
        as (select distinct term_id, hierarchy_dataset_name
            from ontology_tree_metadata
           ),
        graph_edge
        as (select ed.name as dataset_name, tree.* from (
            select subject_term_id as child_term_id, object_term_id as parent_term_id, external_database_release_id
            from sres.OntologyRelationship orel
            where external_database_release_id in (select edr.external_database_release_id
                                                   from sres.externaldatabase ed, sres.externaldatabaserelease edr
                                                   where ed.external_database_id = edr.external_database_id
                                                     and ed.name in ('Ontology_icemr_RSRC', 'Ontology_microbiomeHierarchy_RSRC')
                                                  )
              and orel.subject_term_id != orel.object_term_id
            start with subject_term_id in (select term_id from leaf_term)
            connect by subject_term_id = prior object_term_id) tree,
            sres.externaldatabase ed, 
            sres.externaldatabaserelease edr
            where tree.external_database_release_id = edr.external_database_release_id
            and ed.external_database_id = edr.external_database_id),
        unparented_term
        as (select parent_term_id as term_id, dataset_name from graph_edge
            minus
            select child_term_id as term_id, dataset_name from graph_edge),
        distinct_term
        as (select parent_term_id as term_id, dataset_name from graph_edge
            union
            select child_term_id as term_id, dataset_name from graph_edge),
        leaf_ancestor_pair 
        as (
        select ancestor.term_id as ancestor_term_id, descendent.term_id as leaf_term_id, ancestor.dataset_name
              from distinct_term ancestor, distinct_term descendent, leaf_term lt
              where descendent.term_id
                    in (select child_term_id
                        from graph_edge
                        start with parent_term_id = ancestor.term_id
                        connect by prior child_term_id = parent_term_id)
                and descendent.term_id = lt.term_id
                and decode(descendent.dataset_name, lt.hierarchy_dataset_name, 1 ,0) = 1 
                and descendent.dataset_name = ancestor.dataset_name
            union
              select term_id as ancestor_term_id, term_id as leaf_term_id, hierarchy_dataset_name as dataset_name
              from leaf_term
            ),
        fallback
        as (select distinct dataset_name, type, subtype, organism, hierarchy_dataset_name, term_name as property
            from FallbackMetadata
           )
        -- END OF WITH CLAUSES (whew!)
        -- parent
          select distinct organism, m.dataset_name, type, subtype, hierarchy_dataset_name, term as property, 'parent' as spec_property, category as spec_value
          from metadata m, hierarchy_mapping hm
          where m.dataset_name = hm.dataset_name
            and hierarchy_dataset_name is null 
        -- leaf
        union
          select organism, m.dataset_name, type, subtype, hierarchy_dataset_name, term as property, 'leaf' as spec_property, 'true' as spec_value
          from metadata m, hierarchy_mapping hm
          where m.dataset_name = hm.dataset_name
        -- filter
        union
          select m.organism, m.dataset_name, m.type, m.subtype, hm.hierarchy_dataset_name,
                 m.term as property, 'filter' as spec_property, mt.filter as spec_value
          from metadata m, hierarchy_mapping hm, MetadataType mt
          where m.dataset_name = hm.dataset_name
            and m.term = mt.property
        -- display
        union
          select distinct organism, m.dataset_name, type, subtype,
                          hierarchy_dataset_name, term as property, 'display' as spec_property,
                          -- work around initcap's apostrophe problem
                          replace(replace(initcap(replace(term, '''', '4834929393')), '4834929393', ''''),
                                  '16s', '16S')
                            as spec_value
          from metadata m, hierarchy_mapping hm
          where m.dataset_name = hm.dataset_name
        -- type
        union
          select m.organism, m.dataset_name, m.type, m.subtype, hm.hierarchy_dataset_name,
                 m.term as property, 'type' as spec_property, mt.type as spec_value
          from metadata m, hierarchy_mapping hm, MetadataType mt
          where m.dataset_name = hm.dataset_name
            and m.term = mt.property
        union
        --description
          select m.organism, m.dataset_name, m.type, m.subtype, hm.hierarchy_dataset_name,
                 m.term as property, 'description' as spec_property, ot.definition as spec_value
          from metadata m, hierarchy_mapping hm, sres.ontologyterm ot
          where m.dataset_name = hm.dataset_name
            and m.term_id = ot.ontology_term_id
        -- parents: parent
        union
          select distinct organism, m.dataset_name, type, subtype, hierarchy_dataset_name, category as property, 'parent' as spec_property, 'protocol' as spec_value
          from protocol_metadata m, hierarchy_mapping hm
          where m.dataset_name = hm.dataset_name
            and (hierarchy_dataset_name is null)
        union
          select distinct organism, m.dataset_name, type, subtype, hierarchy_dataset_name, category as property, 'parent' as spec_property, 'characteristic' as spec_value
          from characteristic_metadata m, hierarchy_mapping hm
          where m.dataset_name = hm.dataset_name
            and (hierarchy_dataset_name is null)
        -- parents: display
        union
          select distinct organism, m.dataset_name, type, subtype, hierarchy_dataset_name, category as property, 'display' as spec_property, category as spec_value
          from metadata m, hierarchy_mapping hm
          where m.dataset_name = hm.dataset_name
            and (hierarchy_dataset_name is null)
        -- grandparents: parent
        union
          select distinct organism, m.dataset_name, type, subtype, hierarchy_dataset_name, 'protocol' as property, 'parent' as spec_property, '' as spec_value
          from protocol_metadata m, hierarchy_mapping hm
          where m.dataset_name = hm.dataset_name
            and (hierarchy_dataset_name is null)
        union
          select distinct organism, m.dataset_name, type, subtype, hierarchy_dataset_name, 'characteristic' as property, 'parent' as spec_property, '' as spec_value
          from characteristic_metadata m, hierarchy_mapping hm
          where m.dataset_name = hm.dataset_name
            and (hierarchy_dataset_name is null)
        -- grandparents: display
        union
          select distinct organism, m.dataset_name, type, subtype, hierarchy_dataset_name, 'protocol' as property, 'display' as spec_property, 'Protocol' as spec_value
          from protocol_metadata m, hierarchy_mapping hm
          where m.dataset_name = hm.dataset_name
            and (hierarchy_dataset_name is null)
        union
          select distinct organism, m.dataset_name, type, subtype, hierarchy_dataset_name, 'characteristic' as property, 'display' as spec_property, 'Characteristic' as spec_value
          from characteristic_metadata m, hierarchy_mapping hm
          where m.dataset_name = hm.dataset_name
            and (hierarchy_dataset_name is null)
        union
          select otm.organism, otm.dataset_name, otm.type, subtype, otm.hierarchy_dataset_name,
                child.name as property, 'parent' as spec_property, parent.name as spec_value
          from ontology_tree_metadata otm, leaf_ancestor_pair lap,
               (select child_term_id, parent_term_id, dataset_name from graph_edge
                union
                select term_id as child_term_id, null as parent_term_id, dataset_name from unparented_term) edge,
               sres.OntologyTerm child, sres.OntologyTerm parent
          where edge.child_term_id = lap.ancestor_term_id
            and lap.leaf_term_id = otm.term_id
            and decode(lap.dataset_name, otm.hierarchy_dataset_name, 1 ,0) = 1
            and edge.child_term_id = child.ontology_term_id
            and edge.parent_term_id = parent.ontology_term_id(+)
            and decode(edge.dataset_name, otm.hierarchy_dataset_name, 1 ,0) = 1
        -- fallback: parent
        union
          select organism, dataset_name, type, subtype, hierarchy_dataset_name, property, 'parent' as spec_property, '' as spec_value
          from fallback
        -- fallback: display
        union
          select organism, dataset_name, type, subtype, hierarchy_dataset_name,
                 property, 'display' as spec_property,
                  -- work around initcap's apostrophe problem:
                 replace(replace(initcap(replace(property, '''', '4834929393')), '4834929393', ''''),
                         '16s', '16S')
                   as spec_value
          from fallback
        -- fallback: filter
        union
          select organism, dataset_name, type, subtype, hierarchy_dataset_name, property, 'filter' as spec_property, 'membership' as spec_value
          from fallback
        -- fallback: leaf
        union
          select organism, dataset_name, type, subtype, hierarchy_dataset_name, property, 'leaf' as spec_property, 'true' as spec_value
          from fallback
        -- fallback: type
        union
          select organism, dataset_name, type, subtype, hierarchy_dataset_name, property, 'type' as spec_property, 'string' as spec_value
          from fallback
        ) 
        where dataset_name not in ('ISASimple_RSRC','ISA_RSRC')
        order by organism, dataset_name, property, spec_property, spec_value
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index msix1&1
        on MetadataSpec&1 (dataset_name, organism, hierarchy_dataset_name, property, spec_property, spec_value)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="TaxonAbundanceSpec">
    <internalDependency name="TaxonAbundance"/>
    <sql>
      <![CDATA[
       create table TaxonAbundanceSpec&1 nologging as

        -- parent
          select  type, subtype, dataset_name,  term_id as property, 'parent' as spec_property, category as spec_value
          from TaxonAbundance
        --grandparent
        union
          select  type, subtype, dataset_name, category as property, 'parent' as spec_property, null as spec_value
          from TaxonAbundance
        -- leaf
        union
          select type, subtype, dataset_name,  term_id as property, 'leaf' as spec_property, 'true' as spec_value
          from TaxonAbundance
        -- filter
        union
          select type, subtype, dataset_name,
                 term_id as property, 'filter' as spec_property, 'range' as spec_value
          from TaxonAbundance
        -- display
        union
          select distinct type, subtype, dataset_name, term_id as property, 'display' as spec_property, term as spec_value
          from TaxonAbundance
        -- parent:display
        union
          select distinct type, subtype, dataset_name, category as property, 'display' as spec_property, category as spec_value
          from TaxonAbundance
        -- type
        union
          select type, subtype, dataset_name, term_id as property, 'type' as spec_property, 'number' as spec_value
          from TaxonAbundance
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TranscriptPathway">
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="PathwayAttributes"/>
    <externalDependency name="sres.PathwayNode"/>
    <externalDependency name="dots.AaSequenceEnzymeClass"/>
    <externalDependency name="sres.EnzymeClass"/>
    <sql>
      <![CDATA[
       create table TranscriptPathway&1 nologging as
        with WildcardedPathwayNode
            as (select pn.pathway_id
                , replace(ec.ec_number, '-', '%') as ec_number_wc
                , ec.ec_number
                from sres.PathwayNode pn
                , sres.ontologyterm ot
                , SRES.ENZYMECLASS ec
                where pn.pathway_node_type_id = ot.ontology_term_id
                and pn.row_id = ec.enzyme_class_id
                and ot.name = 'enzyme'),
            WildcardedEnzymeClass
            as (select enzyme_class_id
                , ec_number
                , replace(ec_number, '-', '%') as ec_number_wc
                from sres.EnzymeClass)
        select distinct ga.source_id
        , ga.gene_source_id
        , pa.source_id as pathway_source_id
        , pa.name as pathway_name
        , ec.ec_number as ec_number_gene
        , (length(ec.ec_number) - length(replace(ec.ec_number, '-', ''))) as wildcard_count_gene
        , pn.ec_number as ec_number_pathway
        , (length(pn.ec_number) - length(replace(pn.ec_number, '-', ''))) as wildcard_count_pathway
        , CASE WHEN ec.ec_number = pn.ec_number
            THEN 1
            ELSE 0 END as exact_match
        , CASE WHEN ec.ec_number not like '%-%' AND pn.ec_number not like '%-%'
            THEN 1
            ELSE 0  END as complete_ec 
        , pa.pathway_id
        , pa.pathway_source
        , p.external_database_release_id
        from PathwayAttributes pa
        , sres.pathway p
        , WildcardedPathwaynode pn
        , WildcardedEnzymeClass ec
        , dots.AaSequenceEnzymeClass asec
        , TranscriptAttributes ga
        where pa.pathway_id = pn.pathway_id
        and p.pathway_id = pa.pathway_id
        and (ec.ec_number_wc like pn.ec_number_wc
           or pn.ec_number_wc like ec.ec_number_wc)
        and asec.enzyme_class_id = ec.enzyme_class_id
        and ga.aa_sequence_id  = asec.aa_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index TranscriptPath_ix&1
        on TranscriptPathway&1(gene_source_id, source_id, pathway_source_id, pathway_name, pathway_id, ec_number_gene)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="PathwayNodeGene">
    <internalDependency name="TranscriptPathway"/>
    <externalDependency name="sres.PathwayNode"/>
    <sql>
      <![CDATA[
       create table PathwayNodeGene&1 nologging as
select distinct pn.pathway_node_id
, tp.gene_source_id
from transcriptpathway tp
   , sres.pathwaynode pn
where tp.pathway_id = pn.pathway_id
and tp.ec_number_gene like replace(pn.display_label, '-', '%')
      ]]>
    </sql>
  </tuningTable>




  <tuningTable name="ProjectTaxon" prefixEnabled="true">
    <comment>map taxon names to project_ids. to be used by the apidb.project_id function</comment>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="apidb.Organism"/>
    <sql>
      <![CDATA[
        create table &prefixProjectTaxon&1 nologging as
        with
          local_taxon /* a taxon found in this instance, either in dots.ExternalNaSequence or in apidb.Organism */
          as (  select distinct tn.name as taxon,
                       substr((tn.name), 1, instr(tn.name||' ', ' ') - 1) as first_word,
                       pi.name as project_id
                from dots.ExternalNaSequence ens, sres.TaxonName tn, core.ProjectInfo pi
                where ens.taxon_id = tn.taxon_id
                  and tn.name_class = 'scientific name' 
                  and ens.row_project_id = pi.project_id
              /* get names from apidb.Organism.family_name_for_files
                 (may not be necessary) */
              union
                select family_name_for_files as taxon,
                       substr((family_name_for_files), 1, instr(family_name_for_files||' ', ' ') - 1) as first_word,
                       project_name as project_id
                from apidb.Organism
                where family_name_for_files in (select name from sres.TaxonName)
                ),
          mononym /* a taxon name that's the first word of a local taxon */
          as (select distinct lower(lt.first_word) as taxon, lt.project_id
              from local_taxon lt, sres.TaxonName tn
              where lt.first_word = tn.name
                and tn.name_class = 'scientific name'),
          full_name /* the full name of a local taxon whose first name is not a taxon */
          as (select distinct lower(lt.taxon) as taxon, lt.project_id
              from local_taxon lt, sres.TaxonName tn
              where lt.taxon = tn.name
                and tn.name_class = 'scientific name'
                and lower(lt.first_word) not in (select taxon from mononym))
          select * from mononym
        union
          select * from full_name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index data_load_prjct_error&1 on &prefixProjectTaxon&1 (taxon)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index projtax_ix&1 on &prefixProjectTaxon&1 (taxon, project_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="OntologyLevels" prefixEnabled="true">
    <comment>the max and min depth of each ontology term in OntologyRelationship. Used by the GoTermSummary tuning table</comment>
    <externalDependency name="sres.OntologyRelationship"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        create table &prefixOntologyLevels&1 nologging as
        with is_a_links -- not closure, just real links
             as (select subject_term_id, object_term_id
                 from sres.OntologyRelationship rel, sres.OntologyTerm pred
                 where rel.predicate_term_id = pred.ontology_term_id
                   and pred.name = 'is_a'),
             roots -- terms with no parents
             as ( select object_term_id from is_a_links
                 minus
                  select subject_term_id from is_a_links),
             levels -- terms and all their depths, unaggregated
             as ( select object_term_id as ontology_term_id, 0 as depth from roots
                 union
                  select subject_term_id as ontology_term_id, level + 1 as depth
                  from is_a_links
                  start with object_term_id in (select object_term_id from roots)
                  connect by object_term_id = prior subject_term_id)
        select ontology_term_id, min(depth) as min_depth, max(depth) as max_depth
        from levels
        group by ontology_term_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index olev_termix&1 on &prefixOntologyLevels&1 (ontology_term_id, min_depth, max_depth)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneGoTerms" prefixEnabled="true">
    <comment>GeneGoTerms: each row represents one GO term assignment to one gene, right from what was loaded.
     </comment>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.GoAssociation"/>
    <externalDependency name="dots.GoAssociationInstance"/>
    <externalDependency name="dots.GoAssociationInstanceLoe"/>
    <externalDependency name="dots.GoAssocInstEvidCode"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
create table &prefixGeneGoTerms&1 nologging as
        with root_term
             as (select ontology_term_id,
                        substr(decode(name, 'biological_process', 'Biological Process',
                                            'molecular_function', 'Molecular Function',
                                            'cellular_component', 'Cellular Component',
                                            name), 1, 20)
                          as ontology
                 from sres.OntologyTerm
                 where source_id in ('GO_0008150','GO_0003674','GO_0005575'))
             select gf.source_id as gene_source_id, t.source_id as transcript_source_id, taf.aa_sequence_id,
                        decode(ga.is_not, 0, '', 1, 'not', ga.is_not) as is_not, substr(gt.source_id, 1, 25) as go_id,
                        gt.ontology_term_id as go_term_id, rt.ontology, substr(gt.name, 1, 250) AS go_term_name,
                        substr(gail.name, 1, 24) AS source, substr(gec.name, 1, 12) as evidence_code,
                        gaiec.reference as reference, gaiec.evidence_code_parameter as evidence_code_parameter
                 from dots.GeneFeature gf, dots.Transcript t, dots.TranslatedAaFeature taf, dots.GoAssociation ga,
                      sres.OntologyTerm gt, dots.GoAssociationInstance gai, dots.GoAssociationInstanceLoe gail,
                      dots.GoAssocInstEvidCode gaiec, sres.OntologyTerm gec, root_term rt
                 where t.parent_id = gf.na_feature_id
                   and t.na_feature_id = taf.na_feature_id
                   and taf.aa_sequence_id = ga.row_id
                   and ga.table_id = (select table_id
                                      from core.TableInfo
                                      where name = 'TranslatedAASequence')and ga.go_term_id = gt.ontology_term_id
                   and ga.go_association_id = gai.go_association_id
                   and gai.go_assoc_inst_loe_id = gail.go_assoc_inst_loe_id
                   and gai.go_association_instance_id = gaiec.go_association_instance_id
                   and gaiec.go_evidence_code_id = gec.ontology_term_id
                   and gt.ancestor_term_id = rt.ontology_term_id(+)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="GoTermSummary" prefixEnabled="true">
    <comment>GoTermSummary: each row represents one GO term assignment to one gene.
         (Typically, a gene has multiple such assignments.) This is used for
          finding gene-GO mappings, such as for the gene-page GO table.
     </comment>
    <internalDependency name="GeneGoTerms"/>
    <internalDependency name="OntologyLevels"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.GoAssociation"/>
    <externalDependency name="dots.GoAssociationInstance"/>
    <externalDependency name="dots.GoAssociationInstanceLoe"/>
    <externalDependency name="dots.GoAssocInstEvidCode"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="sres.OntologyRelationship"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
create table &prefixGoTermSummary&1 nologging as
        select ggt.gene_source_id, ggt.transcript_source_id, ggt.aa_sequence_id, ggt.is_not, replace(ggt.go_id,'_',':') as go_id,
               ggt.go_term_id, ggt.ontology, ggt.go_term_name, ggt.source, ggt.evidence_code, ggt.reference, ggt.evidence_code_parameter,
               cast (1 as number(1)) as is_leaf, ol.min_depth as depth
        from GeneGoTerms ggt, &prefixOntologyLevels ol
             where ggt.go_term_id = ol.ontology_term_id(+)
        union
        select ggt.gene_source_id, ggt.transcript_source_id, ggt.aa_sequence_id, ggt.is_not,
               replace (substr(ot.source_id, 1, 25),'_',':') as go_id,
               ot.ontology_term_id as go_term_id, ggt.ontology,
               substr(ot.name, 1,250) as go_term_name, ggt.source, ggt.evidence_code, ggt.reference, ggt.evidence_code_parameter,
               cast (1 as number(1)) as is_leaf, ol.min_depth as depth
        from GeneGoTerms ggt, sres.OntologyRelationship orel, sres.OntologyTerm ot, &prefixOntologyLevels ol
        where ggt.go_term_id = orel.subject_term_id
          and orel.object_term_id = ot.ontology_term_id
          and ot.ontology_term_id = ol.ontology_term_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixGoTermSummary&1
        set is_leaf = 0
        where (aa_sequence_id, source, go_term_id)
              in (select gts.aa_sequence_id, gts.source, orel.object_term_id
                  from &prefixGoTermSummary&1 gts, sres.OntologyRelationship orel
                  where gts.go_term_id = orel.subject_term_id
                    and orel.subject_term_id != orel.object_term_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index GoTermSum_aaSeqId_idx&1 ON &prefixGoTermSummary&1 (aa_sequence_id, go_id, source)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="DatasetExampleSourceId">
    <comment> Each row maps a dataset onto an ID for which the dataset contains data;
         each dataset gets one such row.
         Used in dataset record queries.
      </comment>
    <externalDependency name="sres.ExternalDatabase"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="Profile"/>
    <sql>
      <![CDATA[
CREATE TABLE DatasetExampleSourceId&1 NOLOGGING AS
with profiles as (
select p.source_id,
       ga.project_id,
       ga.sequence_id,
       d.name,
       row_number() over(partition by d.name
                         order by ga.chromosome_order_num, p.profile_as_string desc) as rn
from Profile p, sres.ExternalDatabase d, GeneAttributes ga
where p.dataset_name = d.name
and p.profile_as_string is not null
and p.source_id = ga.source_id (+)
)
select p.source_id as example_source_id, p.project_id, p.sequence_id, p.name as dataset
from profiles p
where p.rn = 1
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="GeneWord">
    <!-- Each row maps a gene source_id to all words found in the gene's product field
         Used in the word enrichment analysis plugin
         The trick sql was cribbed and modified from: nuijten.blogspot.com/2011/08/splitting-comma-delimited-string-regexp.html
      -->
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
        create table GeneWord&1 nologging as
        select source_id, taxon_id,
               -- for each rn (1 - max_words_in_any_product),
               --    print the rn-th word.
               --    replace leading and trailing parens with empty string, eg (RIFN) becomes RIFN
               substr(regexp_replace(regexp_substr (product, '[^ ,]+', 1, rn), '[\)\(]', ''), 1, 200) word
        from GeneAttributes
        cross
               -- create a table of integers 1 - n where n is the max number of words in any product
        join (select rownum rn
              from (select max (regexp_count (product, '[ ,]')) + 1 mx
                    from GeneAttributes)
              connect by level <= mx
             )
        where regexp_substr (product, '[^, ]+', 1, rn) is not null
        order by source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index GeneWord_idx&1 ON GeneWord&1 (source_id)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrganismAttributes">
    <comment> Stores per-organism information. Used by the organism record, as well
         as by project_id(), the function that maps an organism to a project.
      </comment>
    <internalDependency name="TaxonSpecies"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="GeneId"/>
    <internalDependency name="PopsetAttributes"/>
    <internalDependency name="GoTermSummary"/>
    <internalDependency name="ChIPchipTranscript"/>
    <internalDependency name="TFBSGene"/>
    <internalDependency name="EstAlignmentGeneSummary"/>
    <internalDependency name="EstAttributes"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <internalDependency name="Profile"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.NaLocation"/>
    <externalDependency name="apidb.PhylogeneticProfile"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="dots.SnpFeature"/>
    <intermediateTable name="DataSourceCount"/>
    <intermediateTable name="CommunityCount"/>
    <intermediateTable name="ProfileCount"/>
    <intermediateTable name="PopsetCount"/>
    <intermediateTable name="GeneCount"/>

    <sql>
      <![CDATA[
CREATE TABLE DataSourceCount nologging as ( 
        SELECT ds.taxon_id,
               max(case when ds.type = 'organellar_genome' 
                     then 1 
                     else 0 end) as isOrganellar,
               max(case when ds.type = 'isolates'
                         AND ds.subtype = 'HTS_SNP' 
                     then 1 
                     else 0 end) as hasHTSIsolate,
               max(case when ds.type = 'isolates'
                         AND ds.subtype = 'sequenceing_types' 
                     then 1 
                     else 0 end) as hasPopset,      
               max(case when ds.type = 'epitope'
                     then 1 
                     else 0 end) as hasEpitope,     
               max(case when ds.type = 'transcript_expression'
                         AND ds.subtype = 'array'                       
                     then 1 
                     else 0 end) as hasArray                      
        FROM   apidb.DataSource ds
          group by ds.taxon_id
         )
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create table CommunityCount nologging as
       select taxon_id, count(*) as communityCount
       from GeneAttributes
       where (source_id, project_id)
              in (select distinct stable_id, project_name
                  from userlogins5.mappedComment@prodn.login_comment
                  where is_visible = 1
                    and comment_target_id = 'gene')
       group by taxon_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE ProfileCount nologging as (
        select ga.taxon_id,         
                            count(distinct(case when p.dataset_type = 'transcript_expression'
                                   and p.dataset_subtype like '%rt_pcr%' 
                                   and ga.is_deprecated = 0 
                                  then p.source_id
                                  else ''
                                   end)) as rtPCRCount,     
              count(distinct(case when p.dataset_type = 'transcript_expression'
                                   and p.dataset_subtype = 'rnaseq'
                                   and ga.is_deprecated = 0 
                                  then p.source_id
                                  else ''
                                   end)) as rnaSeqCount,
              count(distinct(case when p.dataset_type = 'transcript_expression'
                                   and p.dataset_subtype = 'array'
                                   and ga.is_deprecated = 0 
                                  then p.source_id
                                  else ''
                                   end)) as geneArrayCount
         from Profile p
              right outer join GeneAttributes ga on ga.source_id = p.source_id
         group by ga.taxon_id
)       
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE PopsetCount nologging as (    
        SELECT count(distinct gene.source_id) as popsetCount, sim.taxon_id
        FROM (
          (SELECT i.source_id, tn.taxon_id, nas.source_id as sequence_source_id
           FROM dots.similarity s,
                PopsetAttributes i,
                core.tableinfo t, dots.nasequence nas, sres.taxonname tn
           WHERE s.query_id = i.na_sequence_id
             AND nas.na_sequence_id = s.subject_id
             AND t.table_id = s.subject_table_id
             AND t.table_id = s.query_table_id
             AND t.name = 'ExternalNASequence'
             AND tn.taxon_id = nas.taxon_id
             AND tn.name_class = 'scientific name'
             AND s.pvalue_exp <= -10
           ) sim left join
           (SELECT i.source_id, seq.source_id as sequence_id
            FROM  dots.similarity s, PopsetAttributes i,
                  GeneAttributes g, 
                  core.tableinfo t, dots.nalocation l, dots.nasequence seq
            WHERE s.query_id = i.na_sequence_id
              AND s.subject_id = g.na_sequence_id
              AND t.table_id = s.subject_table_id
              AND t.table_id = s.query_table_id
              AND s.min_subject_start <=  l.end_max
              AND s.max_subject_end >= l.start_min
              AND l.na_feature_id = g.na_feature_id
              AND g.na_sequence_id = seq.na_sequence_id
              AND t.name = 'ExternalNASequence'
            ) gene
           on gene.source_id = sim.source_id and gene.sequence_id = sim.sequence_source_id)
         GROUP BY sim.taxon_id
)
       
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE GeneCount nologging as (    
select genomestat.taxon_id,
       genomestat.project_id,
       genomestat.database_version,
       genomestat.ncbi_tax_id,
       genomestat.Megabps,
       nvl(snpCount.ct,0) as snpCount,
       nvl(count(distinct ga.source_id),0) as geneCount,
       nvl(count(distinct case when ga.is_pseudo =1  then ga.source_id else '' end),0) as pseudoGeneCount,    
       nvl(count(distinct case when ga.gene_type ='protein coding' then ga.source_id else '' end),0) as codingGeneCount,
       nvl(count(distinct case when ga.gene_type ='protein coding' then '' else ga.source_id end),0) as otherGeneCount, 
       nvl(count (distinct (case when ga.is_deprecated = 0
                  then cct.gene_source_id
                  else NULL 
                  end)),0) ChipChipGeneCount ,
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then pp.source_id
                  else NULL 
                  end)),0) orthologCount, 
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then gts.gene_source_id
                  else NULL 
                  end)),0) goCount, 
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then tfbs.gene_source_id
                  else NULL 
                  end)),0) tfbsCount, 
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then mss.aa_sequence_id
                  else NULL 
                  end)),0) proteomicsCount, 
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then est.source_id
                  else NULL 
                  end)),0) estCount,
      nvl(count (distinct (case when (ga.is_deprecated = 0 and ta.ec_numbers is not null)
                  then ga.source_id 
                  else NULL 
                  end)),0) ecNumberCount
        FROM   GeneAttributes ga
               left outer join apidb.phylogeneticprofile pp on ga.source_id = pp.source_id
               left outer join gotermsummary gts on ga.source_id = gts.gene_source_id
               left outer join TFBSGene tfbs on ga.source_id = tfbs.gene_source_id
               left outer join TranscriptAttributes ta on ta.gene_source_id = ga.source_id
               left outer join apidb.MassSpecSummary mss on ta.aa_sequence_id = mss.aa_sequence_id
               left outer join chipchipTranscript cct on ga.source_id = cct.gene_source_id
               left outer join (SELECT distinct s.gene as source_id 
                                  FROM EstAlignmentGeneSummary s, EstAttributes e 
                                  WHERE s.est_gene_overlap_length >= 100 
                                    AND s.is_best_alignment in (1) 
                                    AND s.percent_est_bases_aligned >= 20  
                                    AND s.percent_identity >= 90  
                                    AND e.best_alignment_count <= 1 
                                    AND e.source_id = s.accession   
                                    GROUP by s.gene HAVING count(*) >= 1) est on ga.source_id = est.source_id
          right outer join
         ( SELECT  project_id, taxon_id,
                 max(database_version) as database_version,
                CASE WHEN ncbi_tax_id > 9000000000 THEN NULL
                     ELSE ncbi_tax_id
                END ncbi_tax_id, 
                to_char(sum(length)/1000000,'9999.99') as megabps 
         FROM   GenomicSeqAttributes 
         WHERE  is_top_level = 1
         GROUP BY project_ID, taxon_id, ncbi_tax_id
       ) genomestat on genomestat.taxon_id = ga.taxon_id
        left outer join       
      (
       SELECT count(distinct ga.source_id) as ct, ga.taxon_id 
       FROM GeneAttributes ga, dots.snpfeature sf  
       WHERE sf.parent_id = ga.na_feature_id 
         AND ga.is_deprecated = 0 
       GROUP BY ga.taxon_id 
      ) snpCount on ga.taxon_id = snpCount.taxon_id
        group by genomestat.taxon_id,
                 genomestat.project_id,
                 genomestat.database_version,
                 genomestat.ncbi_tax_id,
                 genomestat.Megabps,
                 snpCount.ct
)
       
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE OrganismAttributes&1 NOLOGGING AS
SELECT oa.*, tn2.name as species, replace(oa.organism_name, tn2.name) as strain
FROM
(
SELECT o.project_name as project_id,
       case when t.ncbi_tax_id > 10000000
--       then 'TMPTX_' || round(t.ncbi_tax_id / 10000000) || '_' ||
--            mod(t.ncbi_tax_id, 10000000) -- e.g. "TMPTX_930_1"
--       then 'TMPTX_' || t.ncbi_tax_id -- all the many digits
         then 'TMPTX_' || o.public_abbrev
         else 'NCBITAXON_' || t.ncbi_tax_id
       end as source_id,
       o.public_abbrev,
       o.family_name_for_files,
       tn.name as organism_name,
       o.genome_source,
       /*o.strain_abbrev, */
       o.is_annotated_genome,
       o.is_reference_strain,
       o.is_family_representative,
       o.name_for_filenames,
       o.taxon_id as component_taxon_id,
       gc.database_version,
       gc.megabps as megabps,
       gc.ncbi_tax_id as ncbi_tax_id,
       gc.snpCount as snpCount,
       gc.geneCount as geneCount,
       gc.pseudoGeneCount as pseudoGeneCount,
       gc.codingGeneCount as codingGeneCount,
       gc.otherGeneCount as otherGeneCount,
       gc.ChipChipGeneCount as ChipChipGeneCount,
       gc.orthologCount as orthologCount,
       gc.goCount as goCount,    
       gc.tfbsCount as tfbsCount,
       gc.proteomicsCount as proteomicsCount,
       gc.estCount as estCount,
       gc.ecNumberCount as ecNumberCount,
       nvl(dsc.isOrganellar, 0) as isOrganellar,
       nvl(dsc.hasHTSIsolate, 0) as hasHTSIsolate, 
       nvl(dsc.hasPopset, 0) as hasPopset,
       nvl(dsc.hasEpitope, 0) as hasEpitope,
       nvl(dsc.hasArray, 0) as hasArray,
       nvl(cc.communityCount, 0) as communityCount,
       nvl(psc.popsetCount, 0) as popsetCount,
       nvl(pc.geneArrayCount, 0) as arrayGeneCount,
       nvl(pc.rnaSeqCount, 0) as rnaSeqCount,
       nvl(pc.rtPCRCount, 0) as rtPCRCount
FROM   apidb.Organism o,
       sres.Taxon t,
       sres.TaxonName tn,
       DataSourceCount dsc,
       CommunityCount cc,
       GeneCount gc,
       popsetCount psc,
       profileCount pc
WHERE t.taxon_id = tn.taxon_id
  AND tn.taxon_id = o.taxon_id
  AND tn.name_class = 'scientific name' 
  AND o.taxon_id = dsc.taxon_id (+)
  AND o.taxon_id = cc.taxon_id (+)
  AND o.taxon_id = gc.taxon_id (+)
  AND o.taxon_id = psc.taxon_id (+)
  AND o.taxon_id = pc.taxon_id (+)
) oa,
  TaxonSpecies ts,
  sres.taxon t,
  sres.taxonname tn2
where oa.component_taxon_id = ts.taxon_id
and ts.species_taxon_id = t.taxon_id
and ts.species_taxon_id = tn2.taxon_id
and tn2.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Organism_sourceId_idx&1 ON OrganismAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="PdbSimilarity">
    <comment> Each record maps a gene to a PDB structure. Used by the model to find
         genes that have a PDB structure and to find the PDB structures for a
         given gene.
      </comment>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.ExternalAaSequence"/>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE PdbSimilarity&1 NOLOGGING AS
SELECT t.source_id, eas.source_id AS pdb_chain,
       substr(eas.description, 1, 100) AS pdb_title,
       substr(eas.source_id, 1,
              instr(eas.source_id, '_', -1) - 1)
         AS pdb_id,
       s.pvalue_mant, s.pvalue_exp, 
       SUBSTR(tn.name, 1, 100) AS taxon,
       ROUND( (s.number_identical / s.total_match_length) * 100)
         AS percent_identity,
       ROUND( (s.total_match_length / tas.length) * 100)
         AS percent_plasmo_coverage,
       s.score, eas.taxon_id as pdb_taxon_id, tas.taxon_id as gene_taxon_id
FROM dots.TranslatedAaFeature taf,
     dots.TranslatedAaSequence tas, core.TableInfo tas_ti,
     dots.Similarity s, core.TableInfo eas_ti,
     dots.ExternalAaSequence eas,
     sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
     sres.TaxonName tn, dots.transcript t
WHERE taf.aa_sequence_id = tas.aa_sequence_id
  AND tas_ti.name = 'TranslatedAASequence'
  AND tas_ti.table_id = s.query_table_id
  AND s.query_id = tas.aa_sequence_id
  AND eas_ti.name = 'ExternalAASequence'
  AND eas_ti.table_id = s.subject_table_id
  AND s.subject_id = eas.aa_sequence_id
  AND tn.name_class = 'scientific name'
  AND eas.external_database_release_id
      = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ed.name in ('PDBProteinSequences_RSRC','PDB protein sequences')
  AND eas.taxon_id = tn.taxon_id
  AND t.na_feature_id = taf.na_feature_id
ORDER BY taf.source_id, eas.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index PdbSim_sourceId_ix&1
ON PdbSimilarity&1 (source_id, score DESC)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SequencePieceClosure" prefixEnabled="true">
    <comment>Extends dots.SequencePiece to handle multiple levels. Used in
         sequence-record queries and in other tuning tables, including
         GenomicSeqAttributes, and SimilaritySpanLocation
     </comment>
    <externalDependency name="dots.SequencePiece"/>
    <sql>
      <![CDATA[
        create table &prefixSequencePieceClosure&1 nologging as
        select sp.sequence_piece_id,
               sp.virtual_na_sequence_id,
               sp.piece_na_sequence_id, 
               sp.sequence_order, 
               sp.distance_from_left,
               sp.uncertainty,
               sp.strand_orientation,
               sp.start_position,
               sp.end_position, 
               sp.modification_date,
               1 as edge_level
        from dots.SequencePiece sp, dots.NaSequence ns
        where sp.piece_na_sequence_id = ns.na_sequence_id
          and (ns.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        /* known issue: this should be run not just once, but iteratively
           until it doesn't create new records.  Currently (7/2008),
           SequencePieces aren't nested even once. */
        insert into &prefixSequencePieceClosure&1
                    (edge_level, virtual_na_sequence_id, piece_na_sequence_id,
                     distance_from_left, strand_orientation, modification_date, 
                     start_position, end_position, sequence_order, sequence_piece_id)
        select 2, higher.virtual_na_sequence_id, lower.piece_na_sequence_id,
               higher.distance_from_left,
               case
                 when nvl(higher.strand_orientation, '+') = nvl(lower.strand_orientation, '+')
                 then '+'
                 else '-'
               end as strand_orientation,
               sysdate,
               higher.start_position - lower.distance_from_left, 
               higher.end_position - lower.distance_from_left, 
               higher.sequence_order,
               dots.sequencepiece_sq.nextval
        from &prefixSequencePieceClosure&1 higher, &prefixSequencePieceClosure&1 lower
        where higher.piece_na_sequence_id = lower.virtual_na_sequence_id
         and higher.start_position >= lower.start_position + lower.distance_from_left
         and higher.end_position <= lower.end_position + lower.distance_from_left
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneId" prefixEnabled="true">
  <comment>GeneId maps any valid ID for a gene onto its official ID. These two quantities
       are stored in the "id" and "gene" columns, respectively. The "unique_mapping"
       column is set to 1 for IDs which map to only one gene.

       Most of the CREATE TABLE statement is made up of the union of nine subqueries,
       each of which looks in a different place for gene IDs. Each subquery populates
       the "union_member" field with a different literal string, to make it easier to
       understand which part (or parts) of the SQL is responsible for each ID-to-gene
       mapping.
   </comment>
    <internalDependency name="GenomicSeqAttributes"/>
    <externalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="apidb.GeneFeatureName"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.NaFeatureNaGene"/>
    <externalDependency name="dots.NaGene"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <intermediateTable name="CommentAssignment"/>
    <intermediateTable name="NewCsi"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixGeneId&1 NOLOGGING AS
SELECT substr(mapping.id, 1, 100) as id, mapping.gene, cast (null as NUMBER) as unique_mapping,
       SUBSTR(apidb.tab_to_string(set(CAST(COLLECT(union_member order by union_member) AS apidb.varchartab)),'; '), 1, 100) as union_member, 
       SUBSTR(apidb.tab_to_string(set(CAST(COLLECT(database_name order by database_name) AS apidb.varchartab)),'; '), 1, 200) as database_name
/*   we would use listagg() as follows, but it repeats duplicate values, and doesn't provide a way to aggregate DISTINCT values. (lame!)
         substr(listagg(union_member, '; ') within group (order by union_member), 1, 100) as union_member,
         substr(listagg(database_name, '; ') within group (order by database_name), 1, 200) as database_name */
FROM (SELECT substr(t.protein_id, 1, instr(t.protein_id, '.') - 1) AS id,
             gf.source_id AS gene,
             'Transcript.protein_id before dot' as union_member, ed.name as database_name /* dots.Transcript.protein_id, trimmed at period */
      FROM dots.Transcript t, dots.GeneFeature gf,
           sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      WHERE t.parent_id = gf.na_feature_id
        AND substr(t.protein_id, 1, instr(t.protein_id, '.') - 1) IS NOT NULL
        AND gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT t.protein_id AS id,
             gf.source_id AS gene,
             'Transcript.protein_id' as union_member, ed.name as database_name /* dots.Transcript.protein_id */
      FROM dots.Transcript t, dots.GeneFeature gf,
           sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      WHERE t.parent_id = gf.na_feature_id
        AND t.protein_id IS NOT NULL
        AND gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT dr.primary_identifier AS id, 
             gf.source_id AS gene,
             'DbRef.primary_identifier' as union_member, ed.name as database_name /* sres.DbRef.primary_identifier */
      FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
           sres.ExternalDatabase ed
      WHERE dr.primary_identifier IS NOT NULL
        AND gf.na_feature_id = drnf.na_feature_id
        AND drnf.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
              = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND  NOT (ed.name in ('NRDB_gb_dbXRefBySeqIdentity','NRDB_ref_dbXRefBySeqIdentity')  
                                  AND NOT  REGEXP_LIKE (dr.primary_identifier, '\D') )
        AND  NOT edr.id_type = 'synonym'
     UNION
     SELECT dr.primary_identifier AS id, 
             gf.source_id AS gene,
             'synonym' as union_member, ed.name as database_name
      FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
           sres.ExternalDatabase ed
      WHERE dr.primary_identifier IS NOT NULL
        AND gf.na_feature_id = drnf.na_feature_id
        AND drnf.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND edr.id_type  = 'synonym'
     UNION
      SELECT dr.secondary_identifier AS id, 
             gf.source_id AS gene,
             'DbRef.secondary_identifier' as union_member, ed.name as database_name /* sres.DbRef.secondary_identifier */
      FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
           sres.ExternalDatabase ed
      WHERE dr.secondary_identifier IS NOT NULL
        AND gf.na_feature_id = drnf.na_feature_id
        AND drnf.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
              = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND ed.name IN ('NRDB_gb_dbXRefBySeqIdentity',
                        'NRDB_pdb_dbXRefBySeqIdentity',
                        'NRDB_ref_dbXRefBySeqIdentity',
                        'NRDB_sp_dbXRefBySeqIdentity',
                        'Predicted protein structures','Pf_predictedProteinStructures_RSRC',
                        'GenBank')
     UNION
      SELECT dr.primary_identifier AS id, 
             gf.source_id AS gene,
             'genbank DbRef.primary_identifier' as union_member, ed.name as database_name /* sres.DbRef.primary_identifier for Genbank records */
      FROM dots.GeneFeature gf, dots.Transcript t, dots.DbRefNaSequence drns,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
            sres.ExternalDatabase ed
      WHERE gf.na_feature_id = t.parent_id
        AND t.na_sequence_id = drns.na_sequence_id
        AND drns.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND ed.name = 'GenBank'
     UNION
      SELECT pred_loc.feature_source_id AS id,
             gene_loc.feature_source_id AS gene,
             'overlapping predicted gene source_id' as union_member, ed.name as database_name /* dots.GeneFeature.source_id for predicted genes that overlap */
      FROM apidb.FeatureLocation gene_loc, apidb.FeatureLocation pred_loc,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      WHERE pred_loc.feature_type = 'GenePrediction'
        AND gene_loc.feature_type = 'GeneFeature'
        AND pred_loc.na_sequence_id = gene_loc.na_sequence_id
        AND gene_loc.start_min <= pred_loc.end_max
        AND gene_loc.end_max >= pred_loc.start_min
        AND pred_loc.is_reversed = gene_loc.is_reversed
        AND pred_loc.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT ng.name AS id, gf.source_id AS gene,
             'NaGene' as union_member, ed.name as database_name /* dots.NaGene.name */
      FROM dots.GeneFeature gf, dots.NaFeatureNaGene nfng, dots.NaGene ng,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      WHERE gf.na_feature_id = nfng.na_feature_id
        AND ng.na_gene_id = nfng.na_gene_id
        AND gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT source_id AS id, source_id AS gene,
             'same ID' as union_member, ed.name as database_name /* same ID (reflexive mapping) */
      FROM dots.GeneFeature gf,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      WHERE gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT n.name AS id, gf.source_id AS gene,
             'gene name' as union_member, d.name as database_name /* apidb.GeneFeatureName.name */
      from apidb.GeneFeatureName n, dots.genefeature gf, sres.ExternalDatabaseRelease r, sres.ExternalDatabase d
      where n.na_feature_id = gf.na_feature_id
        and gf.external_database_release_id =r.external_database_release_id
        and r.external_database_id = d.external_database_id
        and n.is_preferred = 1) mapping,
      dots.GeneFeature gf, dots.NaSequence ns
where mapping.gene = gf.source_id
  and gf.na_sequence_id = ns.na_sequence_id
  and (ns.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
  and (gf.is_predicted != 1 OR gf.is_predicted is null)
group by mapping.id, mapping.gene
      ]]>
    </sql>
    <sql>
      <![CDATA[
update &prefixGeneId&1
set unique_mapping = 1
where lower(id) in (select lower_id
                    from (select distinct lower(id) as lower_id, gene
                          from &prefixGeneId&1) case_independent_mapping
                    group by lower_id
                    having count(*) = 1)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_gene_idx&1 ON &prefixGeneId&1 (gene, id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_id_idx&1 ON &prefixGeneId&1 (id, gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_uniqid_idx&1 ON &prefixGeneId&1 (unique_mapping, id, gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_lowid_idx&1 ON &prefixGeneId&1 (lower(id), gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_uniqlowid_idx&1 ON &prefixGeneId&1 (unique_mapping, lower(id), gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE &prefixCommentAssignment NOLOGGING AS
WITH projects AS
       (SELECT DISTINCT project_id FROM GenomicSeqAttributes),
     project_comments AS
       (SELECT stable_id, comment_id
        FROM userlogins5.comments@&dblink
        WHERE project_name in (select project_id FROM projects)
          AND comment_target_id = 'gene')
  SELECT stable_id, comment_id
  FROM project_comments
UNION
  SELECT csi.stable_id, csi.comment_id
  FROM project_comments pc, userlogins5.commentStableId@&dblink csi
  WHERE csi.comment_id = pc.comment_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE &prefixNewCsi nologging as
SELECT stable_id, comment_id, userlogins5.CommentStableId_pkseq.nextval@&dblink as comment_stable_id
FROM (  SELECT gi.gene AS stable_id, ca.comment_id
        FROM &prefixGeneId&1 gi, &prefixCommentAssignment ca
        WHERE gi.id = ca.stable_id
          AND gi.id != gi.gene
      MINUS
        SELECT stable_id, comment_id
        FROM &prefixCommentAssignment ca)
      ]]>
    </sql>
    <sql>
      <![CDATA[
INSERT INTO userlogins5.CommentStableId@&dblink
           (stable_id, comment_id, comment_stable_id)
SELECT stable_id, comment_id, comment_stable_id
FROM &prefixNewCsi
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GenomicSequenceId">
  <comment> This table maps IDs for a sequence onto the official ID of the sequence.
       It is analogous to GeneId, which does the same thing for genes. Used by
       genomic-sequence record queries, by the sequence retrieval tool, and by
       the BasketFixer, which updates users' baskets at release time to replace
       old IDs with updated ones.
    </comment>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
CREATE TABLE GenomicSequenceId&1 NOLOGGING AS
SELECT DISTINCT substr(id, 1, 60) as id, substr(sequence, 1, 60) AS sequence
FROM (
  SELECT ns.source_id as id, ns.source_id as sequence
  FROM dots.NaSequence ns, sres.OntologyTerm oterm
  WHERE ns.sequence_ontology_id = oterm.ontology_term_id
    AND oterm.name in ('random_sequence', 'contig', 'supercontig', 'chromosome','mitochondrial_chromosome','plastid_sequence','cloned_genomic','apicoplast_chromosome')
UNION
  SELECT dr.primary_identifier AS id, ns.source_id AS sequence
  FROM dots.NaSequence ns, dots.DbRefNaSequence drnf,
       sres.DbRef dr, sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase ed
  WHERE dr.primary_identifier IS NOT NULL
    AND ns.na_sequence_id = drnf.na_sequence_id
    AND drnf.db_ref_id = dr.db_ref_id
    AND dr.external_database_release_id
          = edr.external_database_release_id
    AND edr.external_database_id = ed.external_database_id
)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GenSeqId_sequence_idx&1 ON GenomicSequenceId&1 (sequence, id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GenSeqId_id_idx&1 ON GenomicSequenceId&1 (id, sequence)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GenSeqId_lowid_idx&1 ON GenomicSequenceId&1 (lower(id), sequence)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EpitopeSummary">
    <comment> Used by GeneTables.Epitopes to map a gene to its epitopes.
     </comment>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.EpitopeFeature"/>
    <externalDependency name="dots.MotifAaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE EpitopeSummary&1 NOLOGGING AS
SELECT t.source_id, 
              al.start_min||'-'||al.end_max AS location,
              ef.source_id as iedb_id,
       mas.sequence, 
       SUBSTR(tn.name, 1, 100) AS name,
       DECODE(ef.type, 'Not Full Set Not on Blast Hit', 'Low',
                       'Not Full Set On Blast Hit', 'Medium',
                       'Full Set Not on Blast Hit', 'Medium',
                       'Full Set On Blast Hit', 'High',
                       'unknown epitope type') AS confidence
FROM dots.Transcript t,
     dots.TranslatedAaFeature taf, 
     dots.MotifAaSequence mas,
     dots.TranslatedAaSequence tas, 
     dots.EpitopeFeature ef,
     dots.AaLocation al, 
     sres.TaxonName tn
WHERE taf.na_feature_id = t.na_feature_id
  AND taf.aa_sequence_id = tas.aa_sequence_id
  AND tas.aa_sequence_id = ef.aa_sequence_id
  AND ef.aa_feature_id = al.aa_feature_id
  AND ef.motif_aa_sequence_id = mas.aa_sequence_id
  AND tas.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Epi_srcId_ix&1 ON EpitopeSummary&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TranscriptCenDistance">
    <comment> Stores (transcript, sequence, distance from centromere) 3-tuples for transcripts
         that lie on a sequence for which we have a centomere location.
     </comment>
    <externalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="apidb.TranscriptLocation"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        CREATE TABLE TranscriptCenDistance&1 NOLOGGING AS
        SELECT tl.feature_source_id AS transcript,
               LEAST(ABS(mfl.start_min - tl.end_max),
                     ABS(mfl.end_max - tl.start_min)) AS centromere_distance,
               tl.sequence_source_id AS genomic_sequence
        FROM apidb.TranscriptLocation tl, apidb.FeatureLocation mfl,
             sres.OntologyTerm so
        WHERE tl.na_sequence_id = mfl.na_sequence_id
          AND mfl.feature_type = 'Miscellaneous'
          AND mfl.sequence_ontology_id = so.ontology_term_id
          AND so.name = 'centromere'
          AND tl.is_top_level = 1
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GCent_loc_ix&1
       on TranscriptCenDistance&1 (genomic_sequence, centromere_distance)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProteinAttributes" prefixEnabled="true">
    <comment>The BFMV for proteins. Each protein gets a single record, which
         stores all its attributes. Used mainly to create TranscriptAttributes
    </comment>
    <externalDependency name="apidb.CdsLocation"/>
    <internalDependency name="GoTermSummary"/>
    <externalDependency name="apidb.AaSequenceAttribute"/>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.AaSequence"/>
    <externalDependency name="dots.AaSequenceEnzymeClass"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.RnaType"/>
    <externalDependency name="dots.SignalPeptideFeature"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="dots.TransmembraneAaFeature"/>
    <externalDependency name="sres.EnzymeClass"/>
    <intermediateTable name="GoTermList"/>
    <intermediateTable name="ProteinGoAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixGoTermList NOLOGGING AS
SELECT aa_sequence_id, ontology, source,
             apidb.tab_to_string(set(cast(COLLECT(go_term_name order by go_term_name) as apidb.varchartab)), ', ') AS go_terms,
             apidb.tab_to_string(set(cast(COLLECT(go_id order by go_term_name) as apidb.varchartab)), ', ') AS go_ids
      FROM (SELECT aa_sequence_id, ontology, 
                        DECODE(evidence_code, 'IEA', 'predicted', 'annotated') AS source, go_term_name, go_id
                 FROM  &prefixGoTermSummary
                 WHERE is_leaf = 1
                 )
      GROUP BY aa_sequence_id, ontology, source
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE &prefixProteinGoAttributes NOLOGGING AS
SELECT DISTINCT gts.aa_sequence_id,
       substr(annotated_go_component.go_terms, 1, 300) AS annotated_go_component,
       substr(annotated_go_function.go_terms, 1, 300) AS annotated_go_function,
       substr(annotated_go_process.go_terms, 1, 300) AS annotated_go_process,
       substr(predicted_go_component.go_terms, 1, 300) AS predicted_go_component,
       substr(predicted_go_function.go_terms, 1, 300) AS predicted_go_function,
       substr(predicted_go_process.go_terms, 1, 300) AS predicted_go_process,

       substr(annotated_go_component.go_ids, 1, 300) AS annotated_go_id_component,
       substr(annotated_go_function.go_ids, 1, 300) AS annotated_go_id_function,
       substr(annotated_go_process.go_ids, 1, 300) AS annotated_go_id_process,
       substr(predicted_go_component.go_ids, 1, 300) AS predicted_go_id_component,
       substr(predicted_go_function.go_ids, 1, 300) AS predicted_go_id_function,
       substr(predicted_go_process.go_ids, 1, 300) AS predicted_go_id_process
FROM (SELECT DISTINCT aa_sequence_id FROM &prefixGoTermSummary) gts,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'annotated' AND ontology = 'Cellular Component')
       annotated_go_component,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'annotated' AND ontology = 'Molecular Function')
       annotated_go_function,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'annotated' AND ontology = 'Biological Process')
       annotated_go_process,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'predicted' AND ontology = 'Cellular Component')
       predicted_go_component,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'predicted' AND ontology = 'Molecular Function')
       predicted_go_function,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'predicted' AND ontology = 'Biological Process')
       predicted_go_process
WHERE gts.aa_sequence_id = annotated_go_component.aa_sequence_id(+)
  AND 'annotated' = annotated_go_component.source(+)
  AND 'Cellular Component' = annotated_go_component.ontology(+)
  AND gts.aa_sequence_id = annotated_go_function.aa_sequence_id(+)
  AND 'annotated' = annotated_go_function.source(+)
  AND 'Molecular Function' = annotated_go_function.ontology(+)
  AND gts.aa_sequence_id = annotated_go_process.aa_sequence_id(+)
  AND 'annotated' = annotated_go_process.source(+)
  AND 'Biological Process' = annotated_go_process.ontology(+)
  AND gts.aa_sequence_id = predicted_go_component.aa_sequence_id(+)
  AND 'predicted' = predicted_go_component.source(+)
  AND 'Cellular Component' = predicted_go_component.ontology(+)
  AND gts.aa_sequence_id = predicted_go_function.aa_sequence_id(+)
  AND 'predicted' = predicted_go_function.source(+)
  AND 'Molecular Function' = predicted_go_function.ontology(+)
  AND gts.aa_sequence_id = predicted_go_process.aa_sequence_id(+)
  AND 'predicted' = predicted_go_process.source(+)
  AND 'Biological Process' = predicted_go_process.ontology(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index ProteinGoAttr_aaSequenceId&1 ON &prefixProteinGoAttributes (aa_sequence_id)
tablespace indx
      ]]>
    </sql>

    <sql>
      <![CDATA[
CREATE TABLE &prefixProteinAttributes&1 NOLOGGING AS
SELECT pi.name as project_id,
             tas.source_id, tas.aa_sequence_id,
             t.source_id as transcript_source_id,
             gf.source_id as gene_source_id,
             cdsl.na_sequence_id as na_sequence_id,
             cdsl.is_reversed, 
             cdsl.start_min as cds_start,
             cdsl.end_max as cds_end,
             (taf.translation_stop - taf.translation_start) + 1 AS cds_length,
             tas.length AS protein_length, 
             NVL(transmembrane.tm_domains, 0) AS tm_count,
             tas.molecular_weight,
             asa.min_molecular_weight, asa.max_molecular_weight,
             asa.isoelectric_point, asa.hydropathicity_gravy_score,
             asa.aromaticity_score,             
             sigp.scores as signalp_scores,
             SUBSTR(sigp.pep, 1, 200) as signalp_peptide,
             ec_numbers,
             ec_numbers_derived,
       go.annotated_go_component,
       go.annotated_go_function,
       go.annotated_go_process,
       go.predicted_go_component,
       go.predicted_go_function,
       go.predicted_go_process,
       go.annotated_go_id_component,
       go.annotated_go_id_function,
       go.annotated_go_id_process,
       go.predicted_go_id_component,
       go.predicted_go_id_function,
       go.predicted_go_id_process,
             SUBSTR(NVL(rt1.anticodon, rt2.anticodon), 1, 3) AS anticodon
      FROM  dots.GeneFeature gf, dots.Transcript t, core.ProjectInfo pi,
            dots.TranslatedAaFeature taf,
            dots.TranslatedAaSequence tas,
            apidb.AaSequenceAttribute asa,
            (SELECT protein_source_id, na_sequence_id, is_reversed,
                 MIN(start_min) AS start_min, MAX(end_max) AS end_max  
             FROM apidb.CdsLocation WHERE is_top_level=1
             GROUP BY protein_source_id, na_sequence_id, is_reversed)  cdsl, 
            &prefixProteinGoAttributes go,
            dots.RnaType rt1, dots.RnaType rt2,
            (SELECT aa_sequence_id, max(tm_domains) AS tm_domains
             FROM (SELECT tmaf.aa_sequence_id, COUNT(*) AS tm_domains
                   FROM dots.TransmembraneAaFeature tmaf, dots.AaLocation al
                   WHERE tmaf.aa_feature_id = al.aa_feature_id
                   GROUP BY tmaf.aa_sequence_id) tms
             GROUP BY tms.aa_sequence_id) transmembrane,
             (SELECT spf.aa_sequence_id,'NN Sum: ' || ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) ||
              ', NN D: ' || round(((spf.means_score + spf.maxy_score) / 2),2) || ', HMM Prob: ' || round(spf.signal_probability,2) as scores,
               apidb.tab_to_string(set(cast(COLLECT(decode(spf.algorithm_name,'SignalPhmm','HMM: ','NN: ') || dbms_lob.substr(s.sequence,aal.end_max,1) order by spf.algorithm_name, dbms_lob.substr(s.sequence, aal.end_max, 1)) as apidb.varchartab)), ', ') as pep
              FROM dots.SignalPeptideFeature spf, dots.AaLocation aal, dots.AaSequence s
              WHERE spf.aa_sequence_id = s.aa_sequence_id 
              and  aal.aa_feature_id = spf.aa_feature_id
              and (spf.signal_probability >= .5
              or ((spf.means_score + spf.maxy_score) / 2) >= .5
              or ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) >= 3)
              group by spf.aa_sequence_id,'NN Sum: ' || ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) ||
              ', NN D: ' || round(((spf.means_score + spf.maxy_score) / 2),2) || ', HMM Prob: ' || round(spf.signal_probability,2)) sigp,
            (SELECT aa_sequence_id,
                    SUBSTR(apidb.tab_to_string(set(cast(COLLECT(ec_number order by ec_number)
                                               as apidb.varchartab)), '; '),
                           1, 300)
                      AS ec_numbers
             FROM (SELECT DISTINCT asec.aa_sequence_id,
                          ec.ec_number || ' (' || ec.description || ')' AS ec_number
                   FROM dots.AaSequenceEnzymeClass asec, sres.EnzymeClass ec
                   WHERE ec.enzyme_class_id = asec.enzyme_class_id
		   AND NOT asec.evidence_code = 'OrthoMCLDerived')
             GROUP BY aa_sequence_id) ec,

            (SELECT aa_sequence_id,
                    SUBSTR(apidb.tab_to_string(set(cast(COLLECT(ec_number order by ec_number)
                                               as apidb.varchartab)), '; '),
                           1, 300)
                      AS ec_numbers_derived
             FROM (SELECT DISTINCT asec.aa_sequence_id,
                          ec.ec_number || ' (' || ec.description || ')' AS ec_number
                   FROM dots.AaSequenceEnzymeClass asec, sres.EnzymeClass ec
                   WHERE ec.enzyme_class_id = asec.enzyme_class_id
		   AND asec.evidence_code = 'OrthoMCLDerived')
             GROUP BY aa_sequence_id) ecDerived
      WHERE gf.na_feature_id = t.parent_id
        AND t.row_project_id = pi.project_id
        AND t.na_feature_id = taf.na_feature_id
        AND taf.aa_sequence_id = tas.aa_sequence_id
        AND taf.aa_sequence_id = asa.aa_sequence_id (+)
        AND tas.aa_sequence_id = sigp.aa_sequence_id(+)
        AND cdsl.protein_source_id =  tas.source_id
        AND t.na_feature_id = rt1.parent_id(+)
        AND gf.na_feature_id = rt2.parent_id(+)
        AND tas.aa_sequence_id = transmembrane.aa_sequence_id(+)
        AND tas.aa_sequence_id = ec.aa_sequence_id(+)
        AND tas.aa_sequence_id = ecDerived.aa_sequence_id(+)
        AND tas.aa_sequence_id = go.aa_sequence_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX PA_sourceId&1 ON &prefixProteinAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX PA_aaSequenceId&1 ON &prefixProteinAttributes&1 (aa_sequence_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TranscriptAttributes" prefixEnabled="true">
    <comment>The BFMV for the gene record. Each gene gets a single record, which
         stores all its attributes. Used widely, in the model and elsewhere, for
         queries involving genes, as well as in the creation of more than a
         dozen other tuning tables.
    </comment>
    <internalDependency name="GeneId"/>
    <externalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="apidb.IntronLocation"/>
    <internalDependency name="ProjectTaxon"/>
    <internalDependency name="ProteinAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <externalDependency name="apidb.TranscriptLocation"/>
    <internalDependency name="SnpAttributes"/>
    <externalDependency name="apidb.GeneFeatureName"/>
    <externalDependency name="apidb.TranscriptProduct"/>
    <externalDependency name="apidb.UtrLocation"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.AaSequence"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="dots.ExonFeature"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.GeneInstance"/>
    <externalDependency name="dots.NaFeatureComment"/>
    <externalDependency name="dots.RnaFeatureExon"/>
    <externalDependency name="dots.RnaType"/>
    <externalDependency name="dots.SequenceGroup"/>
    <externalDependency name="dots.SequenceSequencegroup"/>
    <externalDependency name="dots.SnpFeature"/>
    <externalDependency name="dots.SplicedNaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TransmembraneAaFeature"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <intermediateTable name="GeneProduct"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixTranscriptAttributes&1 NOLOGGING AS
SELECT cast(apidb.prefixed_project_id(tn.name, '&prefix') as varchar2(20)) as project_id,
       t.source_id,
       --first the gene attributes:
       gf.source_id AS gene_source_id, 
       gf.na_feature_id AS gene_na_feature_id,
       LEAST(nl.start_min, nl.end_max) AS gene_start_min,
       GREATEST(nl.start_min, nl.end_max) AS gene_end_max,
       COALESCE(preferred_name.name, any_name.name) AS gene_name,
       cast(null as varchar2(2000)) as gene_product,
       REPLACE(so.name, '_', ' ') AS gene_type,
       gi.gene_id,
       transcripts.gene_transcript_count,
       exons.gene_exon_count,
       cast(null as varchar2(80)) as representative_transcript,
       olds.old_ids AS gene_previous_ids,
       nvl(deprecated.is_deprecated, 0) as is_deprecated, 
       0 as gene_paralog_number, 0 as gene_ortholog_number,
       GREATEST(1, least(nl.start_min, nl.end_max) - 15000) AS gene_context_start,
       LEAST(sequence.length, greatest(nl.start_min, nl.end_max) + 15000) AS gene_context_end,
       GREATEST(1, least(nl.start_min, nl.end_max) - 1500) AS gene_zoom_context_start,
       LEAST(sequence.length, greatest(nl.start_min, nl.end_max) + 1500) AS gene_zoom_context_end,
       substr(orthologs.name, 1, 60) AS orthomcl_name,
       nvl(tothtssnps.total_hts_snps,0) AS gene_total_hts_snps, 
       nvl(tothtssnps.hts_nonsynonymous_snps,0) AS gene_hts_nonsynonymous_snps,
       nvl(tothtssnps.hts_stop_codon_snps,0) AS gene_hts_stop_codon_snps,
       nvl(tothtssnps.hts_noncoding_snps,0) AS gene_hts_noncoding_snps, 
       nvl(tothtssnps.hts_synonymous_snps,0) AS gene_hts_synonymous_snps,
       nvl(tothtssnps.hts_nonsyn_syn_ratio,0) AS gene_hts_nonsyn_syn_ratio, 
       SUBSTR(cmnt.comment_string, 1, 300) AS comment_string,
       uniprot.gene_uniprot_id, uniprot.gene_uniprot_id_internal,
       transcript_uniprot.uniprot_id, transcript_uniprot.uniprot_id_internal,
       entrez_table.entrez_id AS gene_entrez_id, 
       --next the transcript attributes: 
       t.source_id AS transcript_source_id,
       tso.name as transcript_type,
       t.na_feature_id,
       SUBSTR(COALESCE(preferred_product.product, any_product.product, 'unspecified product'), 1, 300) 
            AS transcript_product,
       tl.start_min, tl.end_max,
       pa.cds_start as coding_start, --todo remove?? duplicate w/ cds_start
       pa.cds_end as coding_end,     --todo remove?? duplicate w/ cds_end
       tl.is_reversed,   --CHECK if needed
       DECODE(nvl(tl.is_reversed, 0), 0, 'forward', 1, 'reverse', tl.is_reversed) AS strand,
       DECODE(t.is_pseudo, null, 0, t.is_pseudo) as is_pseudo,
       transcript_exons.exon_count,
       sns.length AS length,
       SUBSTR(sequence.source_id, 1, 50) AS sequence_id,
       SUBSTR(tn.name, 1, 80) AS organism,
       SUBSTR(species_name.name, 1, 60) AS species,
       taxon.ncbi_tax_id,  tn.taxon_id, 
       so.source_id as so_id, SUBSTR(so.name, 1, 150) AS so_term_name,
       CAST(SUBSTR(so.definition, 1, 150) AS VARCHAR2(150)) AS so_term_definition,
       SUBSTR(soRls.version, 1, 7) AS so_version,
       SUBSTR(NVL(rt1.anticodon, rt2.anticodon), 1, 3) AS anticodon,
       ed.name AS external_db_name,
       SUBSTR(edr.version, 1, 10) AS external_db_version,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.chromosome_order_num, sequence.na_sequence_id,
       --next the protein attributes: 
       pa.source_id AS protein_source_id,
       pa.aa_sequence_id,
       pa.cds_start, pa.cds_end, pa.cds_length, 
       pa.protein_length, pa.tm_count,
       pa.molecular_weight,
       pa.isoelectric_point, 
       pa.signalp_scores, pa.signalp_peptide,
       pa.ec_numbers, pa.ec_numbers_derived,
       pa.annotated_go_component,
       pa.annotated_go_function,
       pa.annotated_go_process,
       pa.predicted_go_component,
       pa.predicted_go_function,
       pa.predicted_go_process,
       pa.annotated_go_id_component,
       pa.annotated_go_id_function,
       pa.annotated_go_id_process,
       pa.predicted_go_id_component,
       pa.predicted_go_id_function,
       pa.predicted_go_id_process,
       utr_lengths.five_prime_utr_length, 
       utr_lengths.three_prime_utr_length
FROM dots.GeneFeature gf, apidb.FeatureLocation nl, sres.OntologyTerm so,
     sres.externalDatabaseRelease soRls,
     sres.Taxon, sres.TaxonName tn, dots.RnaType rt1, dots.RnaType rt2,
     dots.Transcript t, sres.ExternalDatabase ed, sres.OntologyTerm tso,
     sres.ExternalDatabaseRelease edr, dots.SplicedNaSequence sns,
     (SELECT rna_feature_id, count(*) as exon_count
      FROM dots.RnaFeatureExon 
      GROUP BY rna_feature_id) transcript_exons,
     ( select na_sequence_id, source_id, chromosome, chromosome_order_num, length, taxon_id
       from dots.ExternalNaSequence
      union
       select na_sequence_id, source_id, chromosome, chromosome_order_num, length, taxon_id
       from dots.VirtualSequence) sequence,
     apidb.TranscriptLocation tl, &prefixProteinAttributes pa,
     dots.geneinstance gi, &prefixTaxonSpecies ts, sres.TaxonName species_name,
     (SELECT DISTINCT gene AS source_id FROM &prefixGeneId) gene,
     (SELECT parent_id, count(*) AS gene_transcript_count
      FROM dots.Transcript
      GROUP BY parent_id) transcripts,
     (SELECT parent_id, count(*) AS gene_exon_count
      FROM dots.ExonFeature
      GROUP BY parent_id) exons,
     (SELECT nfc.na_feature_id,
             MAX(DBMS_LOB.SUBSTR(nfc.comment_string, 300, 1))
               AS comment_string
      FROM dots.NaFeatureComment nfc
      GROUP BY nfc.na_feature_id) cmnt,
     (select distinct gf.source_id, 1 as is_deprecated
      from dots.GeneFeature gf, dots.DbRefNaFeature drnf, sres.DbRef dr, sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      where gf.na_feature_id = drnf.na_feature_id
        and drnf.db_ref_id = dr.db_ref_id
        and dr.external_database_release_id = edr.external_database_release_id
        and edr.external_database_id = ed.external_database_id
        and ed.name = 'gassAWB_dbxref_gene2Deprecated_RSRC') deprecated,
     ( select gene_source_id, total_hts_snps, hts_nonsynonymous_snps, hts_stop_codon_snps,hts_noncoding_snps,hts_synonymous_snps,
        case when (hts_nonsynonymous_snps is null) then 0
              when (hts_synonymous_snps = 0) then 0
                  else round ((hts_nonsynonymous_snps/ hts_synonymous_snps), 2) end as hts_nonsyn_syn_ratio 
      from (
             select gene_source_id,
                    count(*) as total_hts_snps,
                    sum(has_nonsynonymous_allele) as hts_nonsynonymous_snps,
                    sum(has_stop_codon) as hts_stop_codon_snps,
                    sum(is_noncoding_snp) as hts_noncoding_snps,
                    count(*) - sum(has_nonsynonymous_allele) - sum(has_stop_codon) - sum(is_noncoding_snp)  as hts_synonymous_snps
             from &prefixSnpAttributes
             where  gene_source_id is not null
             group by gene_source_id 
      ) ) tothtssnps, 
     (  select gf.na_feature_id, sg.name
        from dots.genefeature gf, dots.SequenceSequenceGroup ssg, 
             dots.SequenceGroup sg, core.TableInfo ti
        where gf.na_feature_id = ssg.sequence_id
          and ssg.sequence_group_id = sg.sequence_group_id
          and ssg.source_table_id = ti.table_id
          and ti.name = 'GeneFeature'
       ) orthologs,
     (select na_feature_id, max(product) as product
      from apidb.TranscriptProduct
      where is_preferred = 1
      group by na_feature_id
     ) preferred_product,
     (select na_feature_id, max(product) as product
      from apidb.TranscriptProduct
      group by na_feature_id
     ) any_product,
     (select na_feature_id, max(name) as name
      from apidb.GeneFeatureName
      where is_preferred = 1
      group by na_feature_id
     ) preferred_name,
     (select na_feature_id, max(name) as name
      from apidb.GeneFeatureName
      group by na_feature_id
     ) any_name,
     (select g.source_id,
             substr(listagg (dr.primary_identifier, ',') within group (order by dr.primary_identifier), 1, 240) as gene_uniprot_id,
             substr(listagg (dr.PRIMARY_IDENTIFIER, '+or+') within group (order by dr.primary_identifier), 1, 240) as gene_uniprot_id_internal
      from sres.dbref dr
         , dots.dbrefnafeature x
         , dots.transcript t
         , sres.externaldatabase d
         , sres.externaldatabaserelease r
         , dots.genefeature g
      where dr.db_ref_id = x.DB_REF_ID
      and x.NA_FEATURE_ID = t.NA_FEATURE_ID
      and dr.EXTERNAL_DATABASE_RELEASE_ID = r.EXTERNAL_DATABASE_RELEASE_ID
      and r.EXTERNAL_DATABASE_ID = d.EXTERNAL_DATABASE_ID
      and t.parent_id = g.na_feature_id
      and (d.name like '%uniprot_dbxref_RSRC'
         or d.name like '%dbxref_gene2Uniprot_RSRC'
         or d.name = 'Links to Uniprot Genes'
         or d.name like '%_dbxref_uniprot_from_annotation_RSRC')
      group by g.source_id
     ) uniprot,
     (select na_feature_id,
             substr(listagg (uniprot_id, ',') within group (order by uniprot_id), 1, 240) as uniprot_id,
             substr(listagg (uniprot_id, '+or+') within group (order by uniprot_id), 1, 240) as uniprot_id_internal
      from (select distinct t.na_feature_id, dr.primary_identifier as uniprot_id
            from sres.DbRef dr, dots.DbRefNaFeature x, dots.Transcript t,
                 sres.ExternalDatabase d, sres.ExternalDatabaseRelease r
            where dr.db_ref_id = x.DB_REF_ID
            and (x.na_feature_id = t.na_feature_id -- 
                 or x.na_feature_id = t.parent_id)
            and dr.external_database_release_id = r.external_database_release_id
            and r.external_database_id = d.external_database_id
            and (d.name like '%uniprot_dbxref_RSRC'
                 or d.name like '%dbxref_gene2Uniprot_RSRC'
                 or d.name = 'Links to Uniprot Genes'
                 or d.name like '%_dbxref_uniprot_from_annotation_RSRC')
           )
      group by na_feature_id
    )  transcript_uniprot,
     (select dbna.na_feature_id,
             substr(listagg (db.primary_identifier, ',') within group (order by db.primary_identifier), 1, 300) as entrez_id
      from sres.ExternalDatabaseRelease edr, sres.DbRef db,
           dots.DbRefNaFeature dbna, sres.ExternalDatabase ed
      where edr.external_database_release_id = db.external_database_release_id
        and ed.external_database_id = edr.external_database_id
        and dbna.db_ref_id = db.db_ref_id
        and lower(ed.name) like '%entrez%'
        group by dbna.na_feature_id
     ) entrez_table,
     (select drnf.na_feature_id,
                 substr(listagg(dr.primary_identifier, ', ') within group (order by dr.primary_identifier), 1, 900) as old_ids
          from dots.DbRefNaFeature drnf, sres.DbRef dr, sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
          where dr.primary_identifier is not null
            and drnf.db_ref_id = dr.db_ref_id
            and dr.external_database_release_id = edr.external_database_release_id
            and edr.external_database_id = ed.external_database_id
            and edr.id_type = 'previous id'
          group by drnf.na_feature_id
     ) olds, 
    (select t.na_feature_id as transcript_na_feature_id, five_prime.utr_length as five_prime_utr_length, three_prime.utr_length as three_prime_utr_length
     from dots.transcript t
      ,(select parent_id, sum(end_max-start_min + 1) as utr_length from apidb.UtrLocation
       where direction = 5
         and is_top_level = 1
       group by parent_id
       ) five_prime
      ,(select parent_id, sum(end_max-start_min + 1) as utr_length from apidb.UtrLocation
       where direction = 3
         and is_top_level = 1
       group by parent_id
       ) three_prime
     where t.na_feature_id = five_prime.parent_id(+)
     and t.na_feature_id = three_prime.parent_id(+)
  ) utr_lengths
WHERE gf.source_id = gene.source_id
  AND gf.na_feature_id = nl.na_feature_id
  AND nl.is_top_level = 1
  AND nl.feature_type = 'GeneFeature' 
  AND nl.na_sequence_id = sequence.na_sequence_id
  AND (sequence.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
  AND gf.sequence_ontology_id = so.ontology_term_id
  AND so.external_database_release_id = soRls.external_database_release_id
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
  AND tn.taxon_id NOT IN
	 (SELECT o.taxon_id FROM apidb.Organism o WHERE  o.is_annotated_genome=0)
  AND t.na_sequence_id = sns.na_sequence_id(+)
  AND gf.na_feature_id = t.parent_id(+)
  AND tl.feature_source_id =  t.source_id
  AND tl. is_top_level=1
  AND t.na_feature_id = transcript_exons.rna_feature_id
  AND t.na_feature_id = rt1.parent_id(+)
  AND gf.na_feature_id = rt2.parent_id(+)
  AND gf.external_database_release_id
       = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND gf.na_feature_id = transcripts.parent_id(+)
  AND gf.na_feature_id = exons.parent_id(+)
  AND gf.na_feature_id = orthologs.na_feature_id(+)
  AND gf.na_feature_id = cmnt.na_feature_id(+)
  AND gf.source_id = deprecated.source_id(+)
  AND gf.na_feature_id = gi.na_feature_id(+)
  AND gf.source_id = tothtssnps.gene_source_id(+)
  AND sequence.taxon_id = ts.taxon_id(+)
  AND ts.species_taxon_id = species_name.taxon_id
  AND species_name.name_class = 'scientific name'
  AND t.na_feature_id = preferred_product.na_feature_id(+)
  AND t.na_feature_id = any_product.na_feature_id(+)
  AND gf.na_feature_id = preferred_name.na_feature_id(+)
  AND gf.na_feature_id = any_name.na_feature_id(+)
  AND (gf.is_predicted != 1 OR gf.is_predicted is null)
  AND tn.name not in ('Plasmodium gallinaceum','Plasmodium reichenowi')
  AND gf.source_id = uniprot.source_id(+)
  AND t.na_feature_id = transcript_uniprot.na_feature_id(+)
  AND gf.na_feature_id = entrez_table.na_feature_id(+)
  AND gf.na_feature_id = olds.na_feature_id(+)
  AND t.source_id = pa.transcript_source_id(+)
  AND t.na_feature_id = utr_lengths.transcript_na_feature_id
  AND t.sequence_ontology_id = tso.ontology_term_id
ORDER BY tn.taxon_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_sourceId&1
          ON &prefixTranscriptAttributes&1 (source_id)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_srcPrj&1
        ON &prefixTranscriptAttributes&1 (source_id, gene_source_id, project_id)
        TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_genesrc&1
        ON &prefixTranscriptAttributes&1 (gene_source_id, source_id, project_id)
        TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_exon_ix&1
          ON &prefixTranscriptAttributes&1 (gene_exon_count, source_id, gene_source_id, project_id)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_loc_ix&1
          ON &prefixTranscriptAttributes&1
               (na_sequence_id, gene_start_min, gene_end_max, is_reversed, na_feature_id,
                is_deprecated, source_id, gene_source_id, project_id)
        TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_feat_ix&1
          ON &prefixTranscriptAttributes&1 (na_feature_id, source_id, gene_source_id, project_id)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_geneid_ix&1
          ON &prefixTranscriptAttributes&1 (gene_id, source_id, gene_source_id, project_id)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TransAttr_orthoname_ix&1
          ON &prefixTranscriptAttributes&1 (orthomcl_name, source_id, taxon_id, gene_type, organism, gene_source_id, project_id)
          TABLESPACE INDX
      ]]>
    </sql>

    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TransAttr_molwt_ix&1
          ON &prefixTranscriptAttributes&1 (taxon_id, molecular_weight, source_id, gene_source_id, project_id)
          TABLESPACE INDX
      ]]>
    </sql>


    <sql>
      <![CDATA[
        CREATE INDEX TransAttr_ortholog_ix&1
          ON &prefixTranscriptAttributes&1
             (source_id, na_sequence_id, gene_start_min, gene_end_max, orthomcl_name, gene_source_id, project_id)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX TransAttr_orgsrc_ix&1
          ON &prefixTranscriptAttributes&1 (organism, source_id, sequence_id, gene_start_min, gene_end_max)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create table &prefixGeneProduct nologging as
        select gene_source_id,
               apidb.tab_to_string(set(cast(COLLECT(transcript_product order by transcript_product) as apidb.varchartab)), ', ')
                 as gene_product
        from &prefixTranscriptAttributes&1
        group by gene_source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gp_ix&1 on &prefixGeneProduct (gene_source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1 ga
        set gene_product =
           (select gene_product
            from &prefixGeneProduct gp
            where gp.gene_source_id = ga.gene_source_id)
      ]]>
    </sql>

    <sql>
      <![CDATA[
  update &prefixTranscriptAttributes&1 ta
  set exon_count = (select count(*) + 1 from apidb.IntronLocation il where il.parent_id = ta.na_feature_id  and il.end_max - il.start_min + 1 > 10 )
  where ta.project_id = 'TriTrypDB' 
      ]]>
    </sql>


<!--
    <sql>
      <![CDATA[
update &prefixTranscriptAttributes&1 ga
set ga.orthomcl_name = (select distinct gb.orthomcl_name from &prefixTranscriptAttributes&1 gb
                     where gb.gene_id = ga.gene_id
                     and gb.orthomcl_name is not null
                     and gb.source_id != gb.orthomcl_name)
where ga.organism like 'Toxo%' 
and ga.orthomcl_name is null
      ]]>
    </sql>
-->
    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1
        set orthomcl_name = 'ORTH_' || gene_id || '.tmp'
        where orthomcl_name is null
        and gene_id is not null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1
        set orthomcl_name = gene_source_id
        where orthomcl_name is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
       update &prefixTranscriptAttributes&1 gaup
       set gene_paralog_number = (select count(*)
                               from &prefixTranscriptAttributes&1 g1
                               where g1.orthomcl_name = gaup.orthomcl_name
                               and g1.organism = gaup.organism
                               and gaup.source_id != g1.source_id),
           gene_ortholog_number = (select count(*)
                               from &prefixTranscriptAttributes&1 g1
                               where g1.orthomcl_name = gaup.orthomcl_name
                               and g1.organism != gaup.organism)
        where gaup.gene_type = 'protein coding'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1
        set gene_id = gene_na_feature_id + (select nvl(max(gene_id), 0) from dots.gene)
        where gene_id is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1
        set representative_transcript = (select min(source_id)
                                   from &prefixTranscriptAttributes&1 ga
                                   where ga.gene_source_id = &prefixTranscriptAttributes&1.gene_source_id)
        where representative_transcript is null
          and gene_id is not null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1
        set representative_transcript = source_id
        where representative_transcript is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX TransAttr_lwrsrc_ix&1
          ON &prefixTranscriptAttributes&1 (lower(source_id), gene_source_id, project_id, source_id)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX TransAttr_species_ix&1
          ON &prefixTranscriptAttributes&1 (species, source_id, gene_id, gene_source_id, project_id)
          TABLESPACE INDX
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="IntronUtrCoords">
    <comment>
      Stores, for each transcript, a string containing the gene-relative coordinates
      of all its introns and UTRs.
    </comment>
    <externalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="apidb.TranscriptLocation"/>
    <sql>
      <![CDATA[
      CREATE TABLE IntronUtrCoords&1 NOLOGGING AS
      SELECT na_feature_id, source_id,
            '[' || regexp_replace(rtrim(xmlagg(XMLELEMENT(e,text,',').EXTRACT('//text()') ORDER BY start_min).GetClobVal(),','), '.quot;', '"') || ']' AS gen_rel_intron_utr_coords
      FROM (SELECT na_feature_id, source_id, start_min,
                   '["' || feature_type || '",' || start_min || ',' || end_max || ']' AS text
            FROM (SELECT fl.feature_type, tl.na_feature_id, tl.feature_source_id AS source_id,
                   CASE
                     WHEN tl.is_reversed = 1
                     THEN tl.end_max - fl.end_max + 1
                     ELSE fl.start_min - tl.start_min + 1
                   END AS start_min,
                   CASE
                     WHEN tl.is_reversed = 1
                     THEN tl.end_max - fl.start_min + 1
                     ELSE fl.end_max - tl.start_min + 1
                   END AS end_max
                  FROM
                   apidb.TranscriptLocation tl, apidb.FeatureLocation fl
                  WHERE
                    tl.na_feature_id = fl.parent_id 
                    and fl.feature_type in('UTR', 'Intron')
                    and tl.is_top_level = 1
                    and fl.is_top_level = 1
                  )
           )
      GROUP BY
        na_feature_id, source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX iuc_srcid_ix&1
          ON IntronUtrCoords&1 (source_id, na_feature_id)
          TABLESPACE INDX
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneAttributes" prefixEnabled="true">
    <comment>The BFMV for the gene record. Each gene gets a single record, which
         stores all its attributes. 
    </comment>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
	    CREATE TABLE &prefixGeneAttributes&1 NOLOGGING AS
	    SELECT DISTINCT project_id
	        , ta.gene_source_id AS source_id
		, gene_na_feature_id AS na_feature_id
		, na_sequence_id
		, is_reversed
		, gene_start_min AS start_min
		, gene_end_max AS end_max
                , decode(strand,'forward','+','reverse','-',null) as strand_plus_minus
		, sequence_id
		, gene_name AS name
		, gene_product AS product
		, gene_type
		, aggregates.is_pseudo
		, organism
		, species
		, taxon_id
		, species as genus_species
                , ltrim(regexp_replace(organism,species,'')) as strain
		, ncbi_tax_id
		, so_id
		, so_term_name
		, so_term_definition
		, so_version
		, anticodon
		, external_db_name
		, external_db_version
		, chromosome
		, chromosome_order_num
		, gene_transcript_count AS transcript_count
		, gene_exon_count as exon_count
		, gene_previous_ids as previous_ids
		, is_deprecated
		, gene_paralog_number as paralog_number
		, gene_ortholog_number as ortholog_number
		, gene_context_start as context_start
		, gene_context_end as context_end
		, orthomcl_name
		, gene_total_hts_snps as total_hts_snps
		, gene_hts_nonsynonymous_snps as hts_nonsynonymous_snps
		, gene_hts_stop_codon_snps as hts_stop_codon_snps
		, gene_hts_noncoding_snps as hts_noncoding_snps
		, gene_hts_synonymous_snps as hts_synonymous_snps
		, gene_hts_nonsyn_syn_ratio as hts_nonsyn_syn_ratio
		, comment_string
		, uniprot.uniprot_id
		, uniprot.uniprot_id_internal
		, gene_entrez_id as entrez_id
		, representative_transcript
                , gene_zoom_context_start as zoom_context_start
                , gene_zoom_context_end as zoom_context_end
            FROM &prefixTranscriptAttributes ta,
                 (SELECT gene_source_id, MIN(is_pseudo) AS is_pseudo
                  FROM &prefixTranscriptAttributes
                  GROUP BY gene_source_id) aggregates,
                 (select na_feature_id,
                         substr(listagg (uniprot_id, ',') within group (order by uniprot_id), 1, 240) as uniprot_id,
                         substr(listagg (uniprot_id, '+or+') within group (order by uniprot_id), 1, 240) as uniprot_id_internal
                  from (select distinct t.parent_id as na_feature_id, dr.primary_identifier as uniprot_id
                        from sres.DbRef dr, dots.DbRefNaFeature x, dots.Transcript t,
                             sres.ExternalDatabase d, sres.ExternalDatabaseRelease r
                        where dr.db_ref_id = x.DB_REF_ID
                        and (x.na_feature_id = t.na_feature_id -- 
                             or x.na_feature_id = t.parent_id)
                        and dr.external_database_release_id = r.external_database_release_id
                        and r.external_database_id = d.external_database_id
                        and (d.name like '%uniprot_dbxref_RSRC'
                             or d.name like '%dbxref_gene2Uniprot_RSRC'
                             or d.name = 'Links to Uniprot Genes'
                             or d.name like '%_dbxref_uniprot_from_annotation_RSRC')
                       )
                  group by na_feature_id
                )  uniprot
            WHERE ta.gene_source_id = aggregates.gene_source_id
              AND ta.gene_na_feature_id = uniprot.na_feature_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index GeneAttr_srcPrj&1
       ON &prefixGeneAttributes&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_exon_ix&1
       ON &prefixGeneAttributes&1 (exon_count, source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_loc_ix&1
       ON &prefixGeneAttributes&1 (na_sequence_id, start_min, end_max, is_reversed, na_feature_id, is_deprecated)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_feat_ix&1
       ON &prefixGeneAttributes&1 (na_feature_id, na_sequence_id, start_min, end_max, is_reversed)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_orthoname_ix&1
       ON &prefixGeneAttributes&1 (orthomcl_name, source_id, taxon_id, gene_type, na_feature_id, organism, species)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_ortholog_ix&1
       ON &prefixGeneAttributes&1 (source_id, na_sequence_id, start_min, end_max, orthomcl_name)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_orgsrc_ix&1
       ON &prefixGeneAttributes&1 (organism, source_id, na_sequence_id, start_min, end_max)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_prjsrc_ix&1
       ON &prefixGeneAttributes&1 (project_id, organism, source_id, NVL(IS_DEPRECATED,0))
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GenomicSeqAttributes" prefixEnabled="true">
    <comment>Each row represents one genomic sequence for which a WDK sequence
         record can be instantiated. Used widely in the workflow, the model,
         and GBrowse, as well as in the creation of a dozen or so other tuning
         tables.
    </comment>
    <internalDependency name="ProjectTaxon"/>
    <internalDependency name="SequencePieceClosure"/>
    <externalDependency name="apidb.Synteny"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixGenomicSeqAttributes&1 NOLOGGING AS
SELECT cast(apidb.prefixed_project_id(tn.name, '&prefix') as varchar2(20)) as project_id,
       SUBSTR(sequence.source_id, 1, 60) AS source_id, sequence.a_count,
       sequence.c_count, sequence.g_count, sequence.t_count,
       (sequence.length
        - (sequence.a_count + sequence.c_count + sequence.g_count + sequence.t_count))
         AS other_count,
       sequence.length,
       to_char((sequence.a_count + sequence.t_count) / sequence.length * 100, '99.99')
         AS at_percent,
       SUBSTR(tn.name, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       taxon.taxon_id,                 
       CASE WHEN sequence.description IS NULL  THEN SUBSTR(tn.name, 1, 100)
            ELSE SUBSTR(sequence.description, 1, 400)
            END AS sequence_description,
       SUBSTR(genbank.genbank_accession, 1, 20) AS genbank_accession,
       SUBSTR(db.database_version, 1, 30) AS database_version, db.database_name,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.external_database_release_id, sequence.sequence_ontology_id,
       sequence.chromosome_order_num, so.source_id as so_id, so.name as sequence_type,
       nvl(virtualization.is_top_level, 1) as is_top_level,
       sequence.na_sequence_id, organism.genome_source,
       organism.name_for_filenames, nvl(msa.has_msa, 0) as has_msa
FROM sres.TaxonName tn, sres.Taxon, sres.OntologyTerm so, apidb.Organism,
     ( select na_sequence_id, source_id, length, chromosome, chromosome_order_num, taxon_id, description,
              a_count, c_count, g_count, t_count, external_database_release_id, sequence_ontology_id
       from dots.ExternalNaSequence
      union
       select na_sequence_id, source_id, length, chromosome, chromosome_order_num, taxon_id, description,
              a_count, c_count, g_count, t_count, external_database_release_id, sequence_ontology_id
       from dots.VirtualSequence) sequence,
     (SELECT drns.na_sequence_id, max(dr.primary_identifier) AS genbank_accession
      FROM dots.dbrefNaSequence drns, sres.DbRef dr,
           sres.ExternalDatabaseRelease gb_edr, sres.ExternalDatabase gb_ed
      WHERE drns.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
            = gb_edr.external_database_release_id
        AND gb_edr.external_database_id = gb_ed.external_database_id
        AND gb_ed.name = 'GenBank'
      GROUP BY drns.na_sequence_id) genbank,
     (SELECT edr.external_database_release_id,
             edr.version AS database_version, ed.name AS database_name
      FROM sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      WHERE edr.external_database_id = ed.external_database_id) db,
     (SELECT distinct piece_na_sequence_id, 0 as is_top_level
      FROM &prefixSequencePieceClosure) virtualization,
     (SELECT a_na_sequence_id as na_sequence_id, 1 as has_msa
      FROM apidb.Synteny syn
      GROUP BY a_na_sequence_id) msa
WHERE sequence.taxon_id = tn.taxon_id(+)
  AND (sequence.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
  AND tn.name_class = 'scientific name'
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.sequence_ontology_id = so.ontology_term_id
  AND so.name IN ('random_sequence', 'chromosome', 'contig', 'supercontig','mitochondrial_chromosome','plastid_sequence','cloned_genomic','apicoplast_chromosome')
  AND sequence.na_sequence_id = genbank.na_sequence_id(+)
  AND sequence.external_database_release_id = db.external_database_release_id(+)
  AND sequence.na_sequence_id = virtualization.piece_na_sequence_id(+)
  AND taxon.taxon_id = organism.taxon_id(+)
  AND sequence.na_sequence_id = msa.na_sequence_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index pk_SeqAttr_&1 ON &prefixGenomicSeqAttributes&1 (lower(source_id), project_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index SeqAttr_source_id&1 ON &prefixGenomicSeqAttributes&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index SeqAttr_naseqid&1 ON &prefixGenomicSeqAttributes&1 (na_sequence_id)
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SnpAttributes" prefixEnabled="true">
    <comment>Each record represents one SNP. Widely used in the model, as well as in
         the creation of several other tuning tables, Includes only NGS SNPs.
    </comment>
    <!-- internalDependency name="ProjectTaxon"/-->
    <externalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="apidb.Snp" noTrigger="true"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixSnpAttributes&1 NOLOGGING AS
WITH allele_total
     AS (SELECT ref_na_sequence_id, location, COUNT(*) AS allele_total
         FROM apidb.SequenceVariation
         GROUP BY ref_na_sequence_id, location),
     stop_codon_snps
     AS (SELECT DISTINCT ref_na_sequence_id, location, 1 as has_stop_codon
         FROM apidb.SequenceVariation
         WHERE product = '*')
SELECT chromosome_info.project_id,
       ed.name as dataset,
       sequence.na_sequence_id,
       sequence.source_id as seq_source_id,
       snp.location,
       snp.source_id,
       snp.reference_strain, 
       snp.reference_na, 
       snp.reference_aa, 
       decode(snp.reference_aa, null, 0, 1) as is_coding,
       snp.position_in_CDS,
       snp.position_in_protein,
       -- has_nonsynonymous should be false if any products are stops
       case when stop_codon_snps.has_stop_codon is null
              then snp.has_nonsynonymous_allele
            else 0
       end as has_nonsynonymous_allele,
       snp.major_allele, 
       snp.minor_allele,
       snp.major_allele_count, 
       snp.minor_allele_count,
       round(snp.major_allele_count / allele_total.allele_total, 2) as major_allele_frequency,
       round(snp.minor_allele_count / allele_total.allele_total, 2) as minor_allele_frequency,
       snp.major_product, 
       snp.minor_product,
       snp.distinct_strain_count,
       snp.distinct_allele_count,
       nvl(stop_codon_snps.has_stop_codon, 0) AS has_stop_codon,
       case when snp.reference_aa is null then 1 else 0 end as is_noncoding_snp,
       fl.feature_source_id as gene_source_id,
       decode(fl.is_reversed,0,'forward',1,'reverse',null) as gene_strand,
       CAST(SUBSTR(sequence.sequence, snp.location - 30, 30) AS VARCHAR2(30)) AS lflank,
       CAST(SUBSTR(sequence.sequence, snp.location + 1, 30) AS VARCHAR2(30)) AS rflank,
       chromosome_info.organism as organism,
       chromosome_info.ncbi_tax_id,
       chromosome_info.chromosome,
       chromosome_info.chromosome_order_num
FROM apidb.Snp, sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr,
     dots.NaSequence sequence, stop_codon_snps,
     allele_total,
     (SELECT feature_source_id, is_reversed, na_feature_id
      FROM apidb.FeatureLocation
      WHERE is_top_level = 1 and feature_type = 'GeneFeature') fl,
     GenomicSeqAttributes chromosome_info
WHERE edr.external_database_release_id = snp.external_database_release_id
  AND ed.external_database_id = edr.external_database_id
  AND sequence.na_sequence_id = snp.na_sequence_id
  AND chromosome_info.na_sequence_id = snp.na_sequence_id
  AND fl.na_feature_id(+) = snp.gene_na_feature_id
  AND snp.na_sequence_id = allele_total.ref_na_sequence_id(+)
  AND snp.location = allele_total.location(+)
  AND snp.na_sequence_id = stop_codon_snps.ref_na_sequence_id(+)
  AND snp.location = stop_codon_snps.location(+)
      ]]>
    </sql>

    <sql>
      <![CDATA[
create unique index SnpAttr_source_id&1 ON &prefixSnpAttributes&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Snp_nafeat_dataset_ix&1
       ON &prefixSnpAttributes&1 (dataset)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Snp_Seq_ix&1
       ON &prefixSnpAttributes&1 (na_sequence_id, dataset, location)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Snp_Freq_ix&1
       ON &prefixSnpAttributes&1 (dataset,major_allele_frequency,minor_allele_frequency)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpAttr_ds_org_ix&1 on &prefixSnpAttributes&1 (dataset,organism)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpVariantIx&1 on &prefixSnpAttributes&1 (dataset, source_id, gene_source_id, location, position_in_protein)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrfAttributes">
    <comment> Each record represents an ORF. Used by the model and the sequence
         retrieval tool for ORF-related queries.
     </comment>
    <externalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
CREATE TABLE OrfAttributes&1 NOLOGGING AS
select gs.project_id,
       SUBSTR(nl.feature_source_id, 1, 60) AS source_id,
       lower(substr(nl.feature_source_id, 1, 60)) as lowercase_source_id,
       gs.organism,
       gs.ncbi_tax_id,
       gs.source_id AS nas_id,
       (nl.end_max - nl.start_min + 1)/3 as length,
       nl.start_min, nl.end_max, nl.is_reversed,
       gs.chromosome,
       gs.chromosome_order_num,
       gs.na_sequence_id,
       nl.na_feature_id
from  sres.OntologyTerm oterm
    , apidb.Featurelocation nl
    , GenomicSeqAttributes gs
WHERE gs.na_sequence_id = nl.na_sequence_id
  AND nl.sequence_ontology_id = oterm.ontology_term_id
  AND nl.is_top_level = 1
  AND oterm.name = 'ORF'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index OrfAttr_source_id&1 ON OrfAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index OrfAttr_location_idx&1 ON OrfAttributes&1 (na_sequence_id, start_min, end_max, is_reversed)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EstAttributes">
    <comment> Each row represents one EST. Used widely in the model, and to make the
         tuning tables BlastTypes, OrganismAbbreviationBlast, and OrganismAttributes.
     </comment>
    <internalDependency name="ProjectTaxon"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.Est"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="dots.Library"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE EstAttributes&1 NOLOGGING AS
SELECT cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ens.source_id,
       e.seq_primer AS primer,
       ens.a_count,
       ens.c_count,
       ens.g_count,
       ens.t_count,
       (ens.length - (ens.a_count + ens.c_count + ens.g_count + ens.t_count))
         AS other_count,
       ens.length,
       replace(l.dbest_name, '''', '-') as dbest_name,
       nvl(regexp_replace(l.vector, '^\s+$', null), 'unknown') AS vector,
       nvl(regexp_replace(l.stage, '^\s+$', null), 'unknown') AS stage,
       SUBSTR(CASE
                WHEN tn.name = 'Giardia lamblia' THEN 'Giardia Assemblage A isolate WB' 
                ELSE tn.name
              END, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       ed.name AS external_db_name,
       nvl(best.best_alignment_count, 0) AS best_alignment_count,
       l.library_id, replace(l.dbest_name, '''', '-') as library_dbest_name
FROM dots.Est e, dots.ExternalNaSequence ens, dots.Library l, sres.Taxon,
     sres.TaxonName tn, sres.ExternalDatabase ed,
     sres.ExternalDatabaseRelease edr, sres.OntologyTerm oterm,
     (select query_na_sequence_id,max(ct) as best_alignment_count
      from (
            SELECT query_na_sequence_id, COUNT(*) AS ct
             FROM dots.BlatAlignment ba
             WHERE is_best_alignment = 1
             GROUP BY target_external_db_release_id,query_na_sequence_id)
      group by query_na_sequence_id) best
WHERE e.na_sequence_id = ens.na_sequence_id
  AND e.library_id = l.library_id
  AND ens.taxon_id = tn.taxon_id
  AND ens.taxon_id = taxon.taxon_id
  AND tn.name_class='scientific name'
  AND ens.external_database_release_id = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ens.sequence_ontology_id = oterm.ontology_term_id
  AND oterm.name = 'EST'
  AND best.query_na_sequence_id(+) = ens.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index EstAttr_source_id&1 ON EstAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>

  </tuningTable>


  <tuningTable name="EstAlignmentGeneSummary">
    <comment> Each row represents a colocated EST alignment - gene pair. Used by the
         model, by generateGeneMetrics, and in the creation of the
         OrganismAttributes tuning table
     </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.AssemblySequence"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.Est"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.OntologyTerm"/>
    <intermediateTable name="EstAlignmentGene"/>
    <intermediateTable name="EstAlignmentNoGene"/>
    <sql>
      <![CDATA[
CREATE TABLE EstAlignmentGene NOLOGGING AS
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, e.accession,
         e.library_id, ba.query_taxon_id, ba.target_na_sequence_id,
         ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
         ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
         sequence.source_id AS target_sequence_source_id,
         least(ba.target_end, ga.gene_end_max)
         - greatest(ba.target_start, ga.gene_start_min) + 1
           AS est_gene_overlap_length,
         ba.query_bases_aligned / (query_sequence.length)
         * 100 AS percent_est_bases_aligned,
         ga.gene_source_id AS gene
  FROM dots.BlatAlignment ba, dots.Est e, dots.AssemblySequence aseq,
       TranscriptAttributes ga, GenomicSeqAttributes sequence,
       dots.NaSequence query_sequence, sres.OntologyTerm so
  WHERE e.na_sequence_id = ba.query_na_sequence_id
    AND aseq.na_sequence_id = ba.query_na_sequence_id
    AND sequence.na_sequence_id = ba.target_na_sequence_id
    AND ga.sequence_id = sequence.source_id
    AND least(ba.target_end, ga.gene_end_max) - greatest(ba.target_start, ga.gene_start_min) >= 0
    AND query_sequence.na_sequence_id = ba.query_na_sequence_id
    AND query_sequence.sequence_ontology_id = so.ontology_term_id
    AND so.name = 'EST'
    AND ba.target_na_sequence_id = sequence.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE EstAlignmentNoGene NOLOGGING AS
SELECT * from EstAlignmentGene WHERE 1=0 UNION /* define datatype for null column */
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, e.accession,
       e.library_id, ba.query_taxon_id, ba.target_na_sequence_id,
       ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
       ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
       sequence.source_id AS target_sequence_source_id,
       NULL AS est_gene_overlap_length,
       ba.query_bases_aligned / (query_sequence.length)
       * 100 AS percent_est_bases_aligned,
       NULL AS gene
FROM dots.BlatAlignment ba, dots.Est e, dots.AssemblySequence aseq,
     dots.NaSequence sequence, dots.NaSequence query_sequence
WHERE e.na_sequence_id = ba.query_na_sequence_id
  AND e.na_sequence_id = query_sequence.na_sequence_id
  AND aseq.na_sequence_id = ba.query_na_sequence_id
  AND ba.target_na_sequence_id = sequence.na_sequence_id
  AND ba.blat_alignment_id IN
   ( /* set of blat_alignment_ids not in in first leg of UNION */
    /* (because they overlap no genes) */
    SELECT ba.blat_alignment_id
    FROM dots.BlatAlignment ba, dots.NaSequence query_sequence,
         sres.OntologyTerm so
    WHERE query_sequence.na_sequence_id = ba.query_na_sequence_id
      AND query_sequence.sequence_ontology_id = so.ontology_term_id
      AND so.name = 'EST'
  MINUS
    SELECT blat_alignment_id FROM EstAlignmentGene)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE EstAlignmentGeneSummary&1 NOLOGGING AS
SELECT * FROM EstAlignmentNoGene
UNION
SELECT * FROM EstAlignmentGene
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index EstSumm_libOverlap_ix&1
             ON EstAlignmentGeneSummary&1
                (library_id, percent_identity, is_consistent,
                 est_gene_overlap_length, percent_est_bases_aligned)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index EstSumm_estSite_ix&1
             ON EstAlignmentGeneSummary&1
                (target_sequence_source_id, target_start, target_end,
                 library_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SnpStrains">
    <comment> Each record captures info for a strain/protocol app node. Used in the model, including
         gene and SNP queries, as well as the gene record. 
     </comment>
    <externalDependency name="apidb.SequenceVariation"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="dots.NaSequence"/>
    <sql>
      <![CDATA[
CREATE TABLE SnpStrains&1 NOLOGGING AS
select distinct pan.name as protocol_app_node_name, pan.protocol_app_node_id, sv.strain, tn.name as organism
from apidb.sequencevariation sv
   , study.protocolappnode pan
   , dots.nasequence s
   , sres.taxonname tn
where pan.protocol_app_node_id = sv.protocol_app_node_id
and sv.ref_na_sequence_id = s.na_sequence_id
and s.taxon_id = tn.taxon_id
and tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX SnpStrains_ix&1 ON SnpStrains&1(strain,organism)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SnpChipStrains">
    <comment> Each record captures info for a strain/protocol app node. Used in the model, including
         gene and SNP queries, as well as the gene record.
     </comment>
    <externalDependency name="results.SeqVariation"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
CREATE TABLE SnpChipStrains&1 NOLOGGING AS
select distinct pan.name as protocol_app_node_name, pan.protocol_app_node_id, sv.strain, tn.name as organism, ds.subtype as platform
from study.study s
   , study.studylink sl
   , study.protocolappnode pan
   , apidb.datasource ds
   , SRES.EXTERNALDATABASE d
   , SRES.EXTERNALDATABASERELEASE r
   , sres.taxonname tn
   , results.seqvariation sv
where ds.type = 'isolates'
and ds.subtype != 'HTS_SNP'
and ds.name = d.name
and ds.version = r.version
and d.EXTERNAL_DATABASE_ID = r.EXTERNAL_DATABASE_ID
and r.EXTERNAL_DATABASE_RELEASE_ID = s.EXTERNAL_DATABASE_RELEASE_ID
and s.study_id = sl.study_id
and sl.protocol_app_node_id = pan.PROTOCOL_APP_NODE_ID
and ds.taxon_id = tn.taxon_id
and tn.name_class = 'scientific name'
and pan.PROTOCOL_APP_NODE_ID = sv.PROTOCOL_APP_NODE_ID
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX SnpChipStrains_ix&1 ON SnpChipStrains&1(strain,organism,platform)
tablespace indx
      ]]>
    </sql>
  </tuningTable>




  <tuningTable name="PopsetAttributes">
    <comment> The BFMV for the WDK popset record. Widely used in the model for
         queries related to popsets.
     </comment>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="results.SegmentResult"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.Characteristic"/>
    <externalDependency name="study.ProtocolAppNode"/>

    <sql>
      <![CDATA[
        create table PopsetAttributes&1 nologging as
        select ens.source_id, pi.name AS project_id, ens.na_sequence_id, pan.protocol_app_node_id,
               sr.segment_result_id, ens.taxon_id, tn.name as organism,
               pan.description, ens.external_database_release_id,
               ed.name as external_db_name, edr.version as external_db_version,
               isolation_source.value as isolation_source,
               cast (null as varchar2(40)) as curated_isolation_source,
               note.value as note,
               gene_name.value as gene_name,
               product.value as product,
               geographic_location.value as geographic_location,
               cast (null as varchar2(40)) as curated_geographic_location,
               lat_lon.latitude, lat_lon.longitude,
               lat_lon.value as lat_lon,
               pcr_primers.value as pcr_primers,
               host.value as host,
               host_tax_id.ncbi_tax_id as host_ncbi_tax_id,
               popset.value as popset,
               strain.value as strain,
               ens.length
        from dots.ExternalNaSequence ens, core.Projectinfo pi, results.SegmentResult sr,
             study.ProtocolAppNode pan, sres.TaxonName tn,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'isolation_source') isolation_source,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'note') note,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'gene') gene_name,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'product') product,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'country') geographic_location,
             (-- for decimal latitude and longitude with one-letter compass points
              --  (e.g. '12.96 S 38.46 W') parse out the latitude and longitude
              select c.protocol_app_node_id,
                     case
                       when regexp_replace(c.value, '[0-9.]* [NS] [0-9.]* [EW]', 'latitude direction longitude direction')
                            = 'latitude direction longitude direction'
                         then
                           to_number(substr(c.value, 1, instr(c.value, ' ') - 1))
                           * case substr(c.value, instr(c.value, ' ') + 1, 1)
                               when 'S' then -1
                               else 1
                             end
                       else null
                     end as latitude,
                     case
                       when regexp_replace(c.value, '[0-9.]* [NS] [0-9.]* [EW]', 'latitude direction longitude direction')
                            = 'latitude direction longitude direction'
                         then
                           to_number(substr(c.value, instr(c.value, ' ', 1, 2) + 1,
                                            instr(substr(c.value, instr(c.value, ' ', 1, 2) + 1, 99), ' ') - 1))
                           * case substr(c.value, -1, 1)
                               when 'W' then -1
                               else 1
                             end
                       else null
                     end as longitude,
                     c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'lat_lon') lat_lon,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'PCR_primers') pcr_primers,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'host') host,
             (select c.protocol_app_node_id, min(t.ncbi_tax_id) as ncbi_tax_id
              from study.Characteristic c, sres.OntologyTerm ot,
                   sres.TaxonName tn, sres.Taxon t
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'host'
                and c.value = tn.name
                and tn.taxon_id = t.taxon_id
              group by c.protocol_app_node_id) host_tax_id,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'isolate') popset,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'strain') strain
        where pi.project_id = ens.row_project_id
          and ens.na_sequence_id = sr.na_sequence_id
          and sr.protocol_app_node_id = pan.protocol_app_node_id
          and pan.name = ens.source_id
          and ens.external_database_release_id = edr.external_database_release_id
          and edr.external_database_id = ed.external_database_id
          and ens.taxon_id = tn.taxon_id(+)
          and tn.name_class = 'scientific name'
          and pan.protocol_app_node_id = isolation_source.protocol_app_node_id(+)
          and pan.protocol_app_node_id = note.protocol_app_node_id(+)
          and pan.protocol_app_node_id = gene_name.protocol_app_node_id(+)
          and pan.protocol_app_node_id = product.protocol_app_node_id(+)
          and pan.protocol_app_node_id = geographic_location.protocol_app_node_id(+)
          and pan.protocol_app_node_id = lat_lon.protocol_app_node_id(+)
          and pan.protocol_app_node_id = pcr_primers.protocol_app_node_id(+)
          and pan.protocol_app_node_id = host.protocol_app_node_id(+)
          and pan.protocol_app_node_id = host_tax_id.protocol_app_node_id(+)
          and pan.protocol_app_node_id = popset.protocol_app_node_id(+)
          and pan.protocol_app_node_id = strain.protocol_app_node_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update PopsetAttributes&1
        set curated_geographic_location = geographic_location
            where geographic_location in (select name from sres.OntologyTerm ot)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update PopsetAttributes&1
        set curated_geographic_location = (select max(ot.name)
                               from sres.OntologyTerm ot, sres.OntologySynonym os
                               where os.ontology_synonym = PopsetAttributes&1.geographic_location
                                 and os.ontology_term_id = ot.ontology_term_id)
        where curated_geographic_location is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update PopsetAttributes&1
        set curated_isolation_source = (select max(ot.name) from SRES.ONTOLOGYterm ot
                where ot.name = PopsetAttributes&1.isolation_source
                and (ot.source_id like 'ENVO%' or ot.source_id like 'UBERON%'))
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update PopsetAttributes&1
        set curated_isolation_source =  (select max(ot.name)
                               from sres.OntologyTerm ot, sres.OntologySynonym os
                               where os.ontology_synonym = PopsetAttributes&1.isolation_source
                                 and os.ontology_term_id = ot.ontology_term_id
                               and (ot.source_id like 'ENVO%' or ot.source_id like 'UBERON%'))
        where curated_isolation_source is null 
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update PopsetAttributes&1 a
        set (a.latitude, a.longitude) = (select g.lat, g.lng
                                from apidb.IsolateGPS g, sres.OntologyTerm ot
                               where a.curated_geographic_location = ot.name
                                 and ot.source_id = g.gazetteer_id )
       ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index PopsetAttr_sourceId_idx&1
        on PopsetAttributes&1 (source_id)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

<!--
  <tuningTable name="ChIPProtocolParams">
    <comment> Used by the GenesByChipChip(Plasmo|Toxo) query, as well as by GBrowse.
     </comment>
    <externalDependency name="rad.Analysis"/>
    <externalDependency name="rad.AnalysisParam"/>
    <externalDependency name="rad.ProtocolParam"/>
    <sql>
      <![CDATA[
        create table ChIPProtocolParams&1 NOLOGGING AS
select pp.*, e.experiment_name from
(
select a.analysis_id,
       a.protocol_id,
       antbd.antibody as antibody,
       strn.strain as strain,
       treamnt.treatment as treatment,
       replcte.replicate as replicate,
       gentyp.genotype as genotype,
       celltyp.celltype as celltype,
       CASE
          WHEN lower(p.name) like '%peak%' then 'called_peaks'
       ELSE 'raw'
       END as protocol_type
from   rad.analysis a,rad.protocol p,
      (select ap.analysis_id,ap.value as antibody
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'antibody') antbd,
      (select ap.analysis_id,ap.value as strain
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'strain') strn,
      (select ap.analysis_id,ap.value as treatment
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'treatment') treamnt,
      (select ap.analysis_id,ap.value as replicate
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'replicate') replcte,
      (select ap.analysis_id,ap.value as genotype
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'genotype') gentyp,
      (select ap.analysis_id,ap.value as celltype
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'celltype') celltyp
where a.protocol_id = p.protocol_id
and p.name in ('ChIP chip Smoothed',
               'ChIP chip Peak Calls',
                /* legacy ones too */
                'NimbleScan_ChIP_Hakimi_called_peaks',
                'NimbleScan_ChIP_Hakimi',
                'NimbleGen_ChIP_Myler_Lmajor',
                'ChIP_chip_Einstein',
                'ChIP_chip_Einstein_called_peaks',
                'ChIP_chip_Einstein_ME1',
                'ChIP_chip_Einstein_ME1_Peak_Calls')
and   a.analysis_id = antbd.analysis_id (+)
and   a.analysis_id = strn.analysis_id (+)
and   a.analysis_id = treamnt.analysis_id (+)
and   a.analysis_id = replcte.analysis_id (+)
and   a.analysis_id = gentyp.analysis_id (+)
and   a.analysis_id = celltyp.analysis_id (+)
) pp, (
select replace(d.name, '_' || a.name || '_chipChipSample_RSRC', '') as experiment_name, a.analysis_id
from sres.ExternalDatabase d, rad.analysis a
where d.name like '%' || a.name ||'%_chipChipSample_RSRC') e
where pp.analysis_id = e.analysis_id (+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index chp_prtparam_idx&1 ON ChIPProtocolParams&1 (analysis_id,protocol_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>
-->

  <tuningTable name="ChIPchipTranscript">
    <comment> Used by the GenesByChipChip(Plasmo|Toxo) query, as well as by
         generateGeneMetrics. Also an input to OrganismAttributes.
     </comment>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="results.SegmentResult"/>
    <externalDependency name="study.StudyLink"/>
    <externalDependency name="study.Study"/>
    <sql>
      <![CDATA[
      create table ChIPchipTranscript&1 NOLOGGING AS
      select distinct ta.source_id, ta.gene_source_id, sr.protocol_app_node_id,
      CASE 
        WHEN ta.is_reversed = 0 
        THEN round(abs(ta.start_min - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)),0)
        ELSE round(abs(ta.end_max - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)),0) 
      END as distance,
      CASE 
        WHEN /* distance > 0 */
          CASE WHEN ta.is_reversed = 0 
            THEN ta.start_min - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)
            ELSE ta.end_max - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)
          END > 0 
        THEN 
          CASE 
            WHEN ta.is_reversed = 0 
            THEN '-' 
            ELSE '+'
          END 
        ELSE 
          CASE 
            WHEN ta.is_reversed = 1 
            THEN '-' 
            ELSE '+'
          END 
        END as direction,
      sr.score1 as score
from  TranscriptAttributes ta,
      Results.segmentresult sr,
      Study.StudyLink sl, 
      Study.Study s
where   sr.na_sequence_id = ta.na_sequence_id
  and   s.study_id = sl.study_id
  and   sl.protocol_app_node_id = sr.protocol_app_node_id
  and   lower(s.name) like '%chip%peaks'
  and   ( (ta.is_reversed = 0 and abs((((sr.segment_end - sr.segment_start) / 2) + sr.segment_start) - ta.start_min) <= 3000)
                  or (ta.is_reversed = 1 and abs((((sr.segment_end - sr.segment_start) / 2) + sr.segment_start) - ta.end_max) <= 3000) )
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index chpgene_geneid_idx&1 ON ChIPchipTranscript&1 (protocol_app_node_id, source_id, gene_source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ChipSeqTranscript">
    <comment> Used by the GenesByChipSeq query
     </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="PANProtocolMetadata"/>
    <internalDependency name="FallbackMetadata"/>
    <externalDependency name="results.SegmentResult"/>
    <sql>
      <![CDATA[
      create table ChipSeqTranscript&1 NOLOGGING AS
      select distinct ta.source_id, ta.gene_source_id, sr.protocol_app_node_id,
      CASE 
        WHEN ta.is_reversed = 0 
        THEN round(abs(ta.start_min - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)),0)
        ELSE round(abs(ta.end_max - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)),0) 
      END as distance,
      CASE 
        WHEN /* distance > 0 */
          CASE WHEN ta.is_reversed = 0 
            THEN ta.start_min - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)
            ELSE ta.end_max - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)
          END > 0 
        THEN 
          CASE 
            WHEN ta.is_reversed = 0 
            THEN '-' 
            ELSE '+'
          END 
        ELSE 
          CASE 
            WHEN ta.is_reversed = 1 
            THEN '-' 
            ELSE '+'
          END 
        END as direction,
      sr.score1 as score
from  TranscriptAttributes ta,
      results.SegmentResult sr
where sr.na_sequence_id = ta.na_sequence_id
  and sr.protocol_app_node_id
          in (      select protocol_app_node_id from FallbackMetadata where subtype = 'chipseq'
              union select protocol_app_node_id from panProtocolMetadata where subtype = 'chipseq'
              union select protocol_app_node_id from panCharacteristicMetadata where subtype = 'chipseq')
  and ( (ta.is_reversed = 0 and abs((((sr.segment_end - sr.segment_start) / 2) + sr.segment_start) - ta.start_min) <= 3000)
                  or (ta.is_reversed = 1 and abs((((sr.segment_end - sr.segment_start) / 2) + sr.segment_start) - ta.end_max) <= 3000) )
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index chpsq_id_idx&1 ON ChipSeqTranscript&1 (protocol_app_node_id, source_id, gene_source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TFBSGene">
    <comment> Used by gene queries, as well as by generateGeneMetrics. Also an input
         to OrganismAttributes.
     </comment>
    <externalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <sql>
      <![CDATA[
        create table TFBSGene&1 NOLOGGING AS
select distinct
      ga.source_id as gene_source_id,
      ga.organism as organism,
      ga.genus_species as species,
      aef.source_id as probe_id,
      aef.na_feature_id as tfbs_na_feature_id,
      CASE 
        WHEN ga.is_reversed = 0 
        THEN round(abs(ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0)
        ELSE round(abs(ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0) 
      END as distance,
      CASE 
        WHEN /* distance > 0 */
          CASE WHEN ga.is_reversed = 0 
            THEN ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)
            ELSE ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)
          END > 0 
        THEN 
          CASE 
            WHEN ga.is_reversed = 0 
            THEN '-' 
            ELSE '+'
          END 
        ELSE 
          CASE 
            WHEN ga.is_reversed = 1 
            THEN '-' 
            ELSE '+'
          END 
        END as direction,
        aef.*
from  dots.BindingSiteFeature aef,
      apidb.FeatureLocation arrloc,
      GeneAttributes ga
where aef.na_feature_id = arrloc.na_feature_id
and   arrloc.na_sequence_id = ga.na_sequence_id
and   ( (ga.is_reversed = 0 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.start_min) <= 3000)
                  or (ga.is_reversed = 1 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.end_max) <= 3000) )
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index tfbs_geneid_idx&1 ON TFBSGene&1 (gene_source_id, tfbs_na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index geneid_tfbs_idx&1 ON TFBSGene&1 (tfbs_na_feature_id,gene_source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Subcellular">
    <comment> Each record maps a gene onto a subcellular location. Used by
         GenesBySubcellularLocalization.
     </comment>
    <internalDependency name="GeneId"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="dots.PredictedAaFeature"/>
    <sql>
      <![CDATA[
CREATE TABLE Subcellular&1 NOLOGGING AS
select distinct gi.gene as source_id, targetting_domain
from (
select paf.source_id, 'ht' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf
where ed.name in ('subcellular motif from Haldar','pfal3D7_cellularLocation_Haldar_RSRC')
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
union
select paf.source_id, 'pexel' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf
where ed.name in ('subcellular motif from Cowman','pfal3D7_cellularLocation_Cowman_RSRC')
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
union
select paf.source_id, 'apicoplast' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf
where ed.name in ('apicoplast targeting data from 4.4','pfal3D7_cellularLocation_ApicoplastTargeting_RSRC')
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
) sc, GeneId gi
where gi.id = sc.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index subc_ix&1 ON Subcellular&1(source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>




  <tuningTable name="SimilaritySpanLocation">
    <comment> Like dots.SimilaritySpan, except that for sequences that are mapped by
         SequencePiece into parts of other sequences, both locations are stored.
         Used by GBrowse, and also in the creation of the Blastx tuning table.
     </comment>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.SimilaritySpan"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.NaSequence"/>
    <internalDependency name="SequencePieceClosure"/>
    <sql>
      <![CDATA[
create table SimilaritySpanLocation&1 NOLOGGING as
select sim.similarity_id, sim.query_id, sim.subject_id, sim.query_table_id,
       sim.subject_table_id, sim.score as similarity_score, sim.min_query_start,
       sim.max_query_end, sim.is_reversed as similarity_is_reversed,
       sim.pvalue_mant, sim.pvalue_exp,
       round(100 * sim.number_identical / sim.total_match_length,1) as percent_identical,
       round(100 * sim.number_positive / sim.total_match_length,1) as percent_positive,
       sim.min_subject_start, sim.max_subject_end, sim.total_match_length,
       simp.similarity_span_id, simp.score as span_score, simp.query_start, simp.query_end,
       simp.subject_start, simp.subject_end,
       simp.is_reversed as span_is_reversed,
       'direct' as location_mapping
from dots.similarity sim, dots.similarityspan simp, core.TableInfo ti
where sim.similarity_id = simp.similarity_id
  and sim.query_table_id = ti.table_id
  and ti.name = 'ExternalNASequence'
union
select sim.similarity_id, scaffold.na_sequence_id as query_id, sim.subject_id,
       sim.query_table_id,
       sim.subject_table_id, sim.score as similarity_score,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - greatest(sim.min_query_start, sim.max_query_end) + 1
           else sp.distance_from_left + least(sim.min_query_start, sim.max_query_end) - sp.start_position + 1
       end as min_query_start,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - least(sim.min_query_start, sim.max_query_end) + 1
           else sp.distance_from_left + greatest(sim.min_query_start, sim.max_query_end) - sp.start_position + 1
       end as max_query_end,
       sim.is_reversed, sim.pvalue_mant, sim.pvalue_exp,
       round(100 * sim.number_identical / sim.total_match_length,1) as percent_identical,
       round(100 * sim.number_positive / sim.total_match_length,1) as percent_positive,
       sim.min_subject_start, sim.max_subject_end, sim.total_match_length, 
       simp.similarity_span_id, simp.score as span_score,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - greatest(simp.query_start, simp.query_end) + 1
           else sp.distance_from_left + least(simp.query_start, simp.query_end) - sp.start_position + 1
       end as query_start,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - least(simp.query_start, simp.query_end) + 1
           else sp.distance_from_left + greatest(simp.query_start, simp.query_end) - sp.start_position + 1
       end as query_end,
       simp.subject_start, simp.subject_end,
       simp.is_reversed as span_is_reversed,
       'virtual' as location_mapping
from dots.similarity sim, dots.similarityspan simp, core.TableInfo ti,
     dots.NaSequence contig, &prefixSequencePieceClosure sp, dots.NaSequence scaffold
where sim.similarity_id = simp.similarity_id
  and sim.query_table_id = ti.table_id
  and ti.name = 'ExternalNASequence'
  and sim.query_id = sp.piece_na_sequence_id
  and sp.start_position <= sim.min_query_start
  and sp.end_position >= sim.max_query_end
  and sim.query_id = contig.na_sequence_id
  and sp.virtual_na_sequence_id = scaffold.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
update SimilaritySpanLocation&1
set pvalue_exp = (select min(pvalue_exp) from SimilaritySpanLocation&1)
where pvalue_mant = 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index spanloc_query_ix&1
        on SimilaritySpanLocation&1 (query_id, min_query_start, max_query_end, query_table_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SnpAttributesDoTS">
    <comment>
         SNP Chip only, such as Plasmo barcode, 3k_chp and hd_array

         Each record represents one SNP. Widely used in the model, as well as in
         the creation of several other tuning tables
     </comment>
    <externalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="ProjectTaxon"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.SnpFeature"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
CREATE TABLE SnpAttributesDoTS&1 NOLOGGING AS
SELECT cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       snp.source_id,
       snp.na_feature_id,
       ed.name AS dataset,
       snp.name as type,
       ds.subtype as platform,
       sequence.na_sequence_id,
       sequence.source_id AS seq_source_id,
       snp_loc.start_min,
       SUBSTR(snp.reference_strain, 1, 200) AS reference_strain,
       SUBSTR(snp.reference_na, 1, 200) AS reference_na,
       snp.is_coding,
       snp.position_in_CDS,
       snp.position_in_protein,
       SUBSTR(snp.reference_aa, 1, 200) AS reference_aa,
       DECODE(snp.has_nonsynonymous_allele, 0, 'no', 1, 'yes')
         AS has_nonsynonymous_allele,
       SUBSTR(snp.major_allele, 1, 40) AS major_allele,
       SUBSTR(snp.major_product, 1, 40) AS major_product,
       snp.major_allele_count, 
       round(snp.major_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as major_allele_frequency,
       SUBSTR(snp.minor_allele, 1, 40) AS minor_allele,
       SUBSTR(snp.minor_product, 1, 40) AS minor_product,
       snp.minor_allele_count,
       round(snp.minor_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as minor_allele_frequency,
       gene_info.source_id AS gene_source_id,
       DECODE(gene_info.is_reversed, 0, 'forward', 1, 'reverse')
         AS gene_strand,
       to_char(SUBSTR(sequence.sequence, snp_loc.start_min - 30, 30)) AS lflank,
       to_char(SUBSTR(sequence.sequence, snp_loc.start_min + 1, 30)) AS rflank,
       SUBSTR(tn.name, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       SUBSTR(chromosome_info.chromosome, 1, 20) AS chromosome,
       chromosome_info.chromosome_order_num
FROM dots.SnpFeature snp, sres.ontologyterm so, apidb.FeatureLocation snp_loc,
     sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, sres.Taxon,
     sres.TaxonName tn, dots.NaSequence sequence, apidb.datasource ds,
     (SELECT gene.source_id, gene_loc.is_reversed, gene.na_feature_id,
             gene_loc.na_sequence_id
      FROM dots.GeneFeature gene, apidb.FeatureLocation gene_loc
      WHERE gene.na_feature_id = gene_loc.na_feature_id
            and gene_loc.is_top_level = 1) gene_info,
     (SELECT na_sequence_id, chromosome, chromosome_order_num
      FROM dots.ExternalNaSequence
     UNION
      SELECT na_sequence_id, chromosome, chromosome_order_num
      FROM dots.VirtualSequence
     UNION
      SELECT na_sequence_id, null as chromosome, null as chromosome_order_num
      FROM dots.NaSequence
      WHERE subclass_view not in ('ExternalNASequence', 'VirtualSequence')
     ) chromosome_info
WHERE edr.external_database_release_id = snp.external_database_release_id
  AND ed.external_database_id = edr.external_database_id
  AND ed.name = ds.name
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
  AND snp_loc.na_feature_id = snp.na_feature_id
  AND snp_loc.is_top_level = 1
  AND sequence.na_sequence_id = snp_loc.na_sequence_id
  AND chromosome_info.na_sequence_id = snp_loc.na_sequence_id
  AND gene_info.na_feature_id(+) = snp.parent_id
  AND snp.sequence_ontology_id = so.ontology_term_id
  AND so.name != 'indel'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index SnpAttrDots_source_id&1 ON SnpAttributesDoTS&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpDots_nafeat_dataset_ix&1
       ON SnpAttributesDoTS&1 (na_feature_id, dataset)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpDoTS_Seq_ix&1
       ON SnpAttributesDoTS&1 (na_sequence_id, dataset, start_min, na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpDoTS_Freq_ix&1
       ON SnpAttributesDoTS&1 (dataset,major_allele_frequency,minor_allele_frequency)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpAttrdots_ds_org_ix&1 on snpattributesdots&1 (dataset,organism,na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpDotsVariantIx&1 on SnpAttributesDoTS&1 (type, dataset, na_feature_id, source_id, gene_source_id, start_min, position_in_protein)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
 create or replace view snpchipattributes as
  select * from snpattributesdots&1
  where platform in ('Broad_3k_array','Broad_75K_array','NIH_10k','Broad_barcode')
      ]]>
    </sql>
    <sql>
      <![CDATA[
   GRANT SELECT ON snpchipattributes TO gus_r
      ]]>
    </sql>


  </tuningTable>



  <tuningTable name="Blastp">
    <comment> Each record stores a Blastp similarity of a gene. Used by the gene-page
         Blastp table. 
     </comment>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.ExternalAaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="core.TableInfo"/>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <sql>
      <![CDATA[
create table Blastp&1 nologging as
select rownum as blastp_id, ga.source_id, ga.gene_source_id, ga.project_id, sim.similarity_id,
       subject.source_id as subject_source_id, sim.score score, sim.query_id, 
       sim.min_query_start, sim.max_query_end, sim.pvalue_mant, sim.pvalue_exp,
       sim.number_identical, sim.total_match_length,
       substr(replace(subject.description, chr(1), ''), 1, 300) as description,
       sim.number_positive, ed.name as external_database_name,
       substr(tn.name, 1, 50) AS query_organism, ns.taxon_id as query_taxon_id
from dots.Similarity sim, core.TableInfo qti, core.TableInfo sti, dots.ExternalAaSequence subject,
     dots.Transcript t, dots.TranslatedAaFeature taf,
     sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
     dots.NaSequence ns, /* TaxonSpecies st, */
     sres.TaxonName tn, TranscriptAttributes ga
where qti.table_id = sim.query_table_id
  and qti.name = 'TranslatedAASequence'
  and sti.table_id = sim.subject_table_id
  and sti.name = 'ExternalAASequence'
  and subject.aa_sequence_id = sim.subject_id
  and ga.na_feature_id = t.na_feature_id
  and t.na_feature_id = taf.na_feature_id
  and taf.aa_sequence_id = sim.query_id
  and subject.external_database_release_id = edr.external_database_release_id
  and edr.external_database_id = ed.external_database_id
  and ga.na_sequence_id = ns.na_sequence_id
  and ns.taxon_id =
/*    st.taxon_id and st.species_taxon_id = # TaxonSpecies mapping commented out */
                     tn.taxon_id
  and tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
update Blastp&1
set pvalue_exp = (select min(pvalue_exp) from Blastp&1)
where pvalue_mant = 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Blastp_src_ix&1 on Blastp&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Blastp_query_ix&1 on Blastp&1 (query_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Blastp_text_ix&1 on Blastp&1(description) indextype is ctxsys.context
             parameters('DATASTORE CTXSYS.DEFAULT_DATASTORE')
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GenePopsetOverlap">
    <comment> Each record stores a colocated (gene, popset) 2-tuple. Used by the
         gene page as well as the PopsetByOverlap query.
     </comment>
    <internalDependency name="PopsetAttributes"/>
    <externalDependency name="apidb.FeatureLocation"/>
    <externalDependency name="dots.Similarity"/>
    <sql>
      <![CDATA[
create table GenePopsetOverlap&1 nologging as
select substr(ia.source_id, 1, 30) as popset_source_id,
       fl.feature_source_id as gene_source_id,
       min(pvalue_exp) as min_pvalue_exp
from PopsetAttributes ia, dots.Similarity sim, apidb.FeatureLocation fl
where fl.feature_type = 'GeneFeature'
  and fl.na_sequence_id = sim.subject_id
  and fl.start_min < sim.max_subject_end
  and fl.end_max > sim.min_subject_start
  and sim.query_id = ia.na_sequence_id
group by ia.source_id, fl.feature_source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index gi_i_ix&1 on GenePopsetOverlap&1 (popset_source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index gi_g_ix&1 on GenePopsetOverlap&1 (gene_source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TaxonSpecies" prefixEnabled="true">
    <comment>Each record maps a taxon_id of interest onto the taxon_id that taxon's
         taxon-tree ancestor whose rank is "species". Used by
         buildAnnotationChangeTT and by gene queries, as well as an input in the
         creation of several tuning tables, including GeneAttributes and
         OrganismTree.
    </comment>
    <internalDependency name="GenomicSeqAttributes"/>
    <externalDependency name="sres.Taxon"/>
    <sql>
      <![CDATA[
create table &prefixTaxonSpecies&1 nologging as
select t.taxon_id, species.taxon_id as species_taxon_id
from sres.Taxon species, (select distinct sa.taxon_id
      from &prefixGenomicSeqAttributes sa) t
where species.taxon_id in (select taxon_id from sres.Taxon
                           connect by taxon_id = prior parent_id and prior rank != 'species'
                           start with taxon_id = t.taxon_id)
  and species.rank = 'species'
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Blastx">
    <comment> Each record stores a Blastx similarity. Used by GBrowse for the
         match:WU_BLASTX track.
     </comment>
    <externalDependency name="dots.ExternalAaSequence"/>
    <externalDependency name="dots.NaSequence"/>
    <internalDependency name="SimilaritySpanLocation"/>
    <sql>
      <![CDATA[
create table Blastx&1
      (similarity_id, name, score, pvalue, na_sequence_id, startm, end, strand, atts,
       constraint blastx&1_pk primary key(na_sequence_id, startm, pvalue, end, similarity_id))
organization index
nologging
as
select distinct sim.similarity_id,
       extt.source_id name, 
       substr(sim.similarity_score || '', 1, 6) score, 
       to_number(sim.pvalue_mant || 'e' || sim.pvalue_exp) pvalue,
       extq.na_sequence_id,
       sim.min_query_start startm, 
       sim.max_query_end end, 
       decode (sim.similarity_is_reversed, 0, '+1', 1, '-1', '.') strand, 
       substr('Score=' || sim.similarity_score || ';;' || 
              'Expect=' || (sim.pvalue_mant || 'e' ||sim.pvalue_exp)||';;'|| 
              'Defline=' || extt.description || ';;' || 
              'PercentIdentity=' || sim.percent_identical || ';;' ||
              'PercentPositive=' || sim.percent_positive || ';;' ||
              'TStart=' || sim.min_query_start || ';;' || 
              'TStop=' || sim.max_query_end, 1, 400) atts 
from SimilaritySpanLocation sim, dots.ExternalAaSequence extt, 
     dots.NaSequence extq
where sim.query_id = extq.na_sequence_id
  and sim.subject_id = extt.aa_sequence_id
  and (sim.max_query_end - sim.min_query_start) < 5000
  and sim.pvalue_exp < -10
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TranscriptSequence" prefixEnabled="true">
    <comment> Each record stores the transcript sequence of one gene. Used by the
         gene record and the sequence retrieval tool. Propagated to the portal.
     </comment>
    <externalDependency name="dots.SplicedNaSequence"/>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixTranscriptSequence&1 NOLOGGING AS
SELECT ta.source_id, ta.project_id, sns.sequence
FROM &prefixTranscriptAttributes ta, dots.SplicedNaSequence sns
WHERE ta.source_id = sns.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index XScriptSeq_ix&1 on &prefixTranscriptSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="CodingSequence">
    <comment> Each record stores the coding sequence of one gene. Used by the
         gene record and the sequence retrieval tool. Propagated to the portal.
     </comment>
    <externalDependency name="dots.SplicedNaSequence"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE CodingSequence&1 NOLOGGING AS
SELECT ta.source_id, ta.project_id,
       SUBSTR(sns.sequence, tf.translation_start,                            
              tf.translation_stop - tf.translation_start + 1) as sequence
FROM TranscriptAttributes ta, dots.SplicedNaSequence sns, dots.TranslatedAaFeature tf
WHERE ta.source_id = sns.source_id
 AND ta.na_feature_id = tf.na_feature_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index CodSeq_ix&1 on CodingSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProteinSequence">
    <comment> Each record stores the coding sequence of one gene. Used by the
         gene record and the sequence retrieval tool, as well as by
         buildTrackOldAnnotationTT. Propagated to the portal.
     </comment>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <internalDependency name="ProteinAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE ProteinSequence&1 NOLOGGING AS
WITH pAttr AS (
   SELECT distinct source_id, aa_sequence_id
   FROM ProteinAttributes)
SELECT pa.source_id, pi.name AS project_id, tas.sequence
FROM pAttr pa, dots.TranslatedAaSequence tas, core.Projectinfo pi
WHERE pa.aa_sequence_id = tas.aa_sequence_id
  AND pi.project_id = tas.row_project_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index ProtSeq_ix&1 on ProteinSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GenomicSequenceSequence">
    <comment> Each record stores the nucleotide sequence for one genomic sequence
         that is "official" (in the sense that it can be instantiated as a WDK
         sequence record. Used by generatePathoLogicFile and the sequence
         retrieval tool Propagated to portal instances.
     </comment>
    <internalDependency name="ProjectTaxon"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE GenomicSequenceSequence&1 NOLOGGING AS
SELECT sa.source_id, cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ns.sequence
FROM GenomicSeqAttributes sa, dots.NaSequence ns, sres.TaxonName tn
WHERE sa.na_sequence_id = ns.na_sequence_id
  AND ns.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GenomicSeq_ix&1 on GenomicSequenceSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrfSequence">
    <comment> Each record stores the amino-acid sequence of an ORF. Used by the
         relevant attribute query of the WDK ORF record, as well as by the
         sequence retrieval tool. Propagated to portal instances.
     </comment>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <internalDependency name="OrfAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE OrfSequence&1 NOLOGGING AS
SELECT oa.source_id,
       oa.project_id,
       ts.sequence
FROM dots.TranslatedAaSequence ts
            , dots.TranslatedAaFeature tf
            , OrfAttributes oa
 WHERE oa.na_feature_id = tf.na_feature_id
   AND tf.aa_sequence_id = ts.aa_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index OrfSeq_ix&1 on OrfSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EstSequence">
    <comment> Each record stores the nucleotide sequence of an EST, for use by the
         relevant attribute query in the WDK EST record. Propagated to portal
         instances.
     </comment>
    <internalDependency name="ProjectTaxon"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE EstSequence&1 NOLOGGING AS
SELECT ens.source_id,
       cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ens.sequence
FROM dots.ExternalNaSequence ens, sres.OntologyTerm oterm, sres.TaxonName tn
WHERE oterm.name = 'EST'
  AND oterm.ontology_term_id = ens.sequence_ontology_id
  AND ens.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index EstSeq_ix&1 on EstSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  
  <tuningTable name="GeneIntronJunction">
    <comment>Contained introns from Gsnap with percentages of max intron score and ratios vs expression
    </comment>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="ExternalDbDatasetPresenter"/>
    <internalDependency name="DatasetPresenter"/>
    <internalDependency name="PANProtocolMetadata"/>
    <externalDependency name="apidb.IntronJunction"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.StudyLink"/>
    <externalDependency name="study.Study"/>
    <sql>
      <![CDATA[
create table GeneIntronJunction&1 NOLOGGING AS
with junexp as (
select distinct junc.protocol_app_node_id as junctions_pan_id, assay.name as junc_name, fpkm.protocol_app_node_id as exp_pan_id,
regexp_replace(fpkm.name, ' \[htseq-union.*', '') as sample_name, 
pvc.protocol_param_value as strand,
CASE WHEN pvc.protocol_param_value = 'secondstrand' THEN 'true' ELSE 'false' END as secondstrand
from (select j.protocol_app_node_id,min(input_node_id) as input_node_id
from (select distinct protocol_app_node_id from apidb.intronjunction) j
, protocolappnodeio io
where j.protocol_app_node_id = io.output_node_id
group by j.protocol_app_node_id) junc
, study.protocolappnode assay
, protocolappnodeio io2
, study.protocolappnode fpkm
, Panparametervalues pva
, Panparametervalues pvb
, Panparametervalues pvc
where  junc.input_node_id = assay.protocol_app_node_id
and junc.input_node_id = io2.input_node_id
and io2.output_node_id = fpkm.protocol_app_node_id
and fpkm.protocol_app_node_id = pva.protocol_app_node_id
AND pva.protocol_param = 'QuantificationType'
AND pva.protocol_param_value = 'HTSeq'
and fpkm.protocol_app_node_id = pvb.protocol_app_node_id
AND pvb.protocol_param = 'Mode'
and pvb.protocol_param_value = 'union'
and fpkm.protocol_app_node_id = pvc.protocol_app_node_id
AND pvc.protocol_param = 'Strand'
and (pvc.protocol_param_value = 'unstranded'
     OR pvc.protocol_param_value = 'firststrand'
     OR pvc.protocol_param_value = 'secondstrand')
), 
--end of junexp 
 namemapping as (
Select distinct edp.dataset_presenter_display_name as exp_name, edp.external_database_name, junexp.sample_name,
junexp.junctions_pan_id, junexp.exp_pan_id, dp.value as switch_strands,junexp.strand,
sj.value as show_intron_junctions, uj.value as include_unified_junctions, pe.value as has_paired_ends
--dp.property,count(*)
FROM junexp, study.studylink sl, study.study s, externaldbdatasetpresenter edp
, datasetproperty dp, datasetproperty sj, datasetproperty uj
, datasetproperty pe
where sl.protocol_app_node_id = junexp.junctions_pan_id
and s.study_id = sl.study_id
and s.name like '%[junctions]'
and s.external_database_release_id = edp.external_database_release_id
and dp.dataset_presenter_id = edp.dataset_presenter_id
AND dp.property = 'switchStrandsProfiles'
AND dp.value = junexp.secondstrand
and sj.dataset_presenter_id = edp.dataset_presenter_id
AND sj.property = 'showIntronJunctions'
and uj.dataset_presenter_id = edp.dataset_presenter_id
AND uj.property = 'includeInUnifiedJunctions'
AND (sj.value = 'true' or uj.value = 'true')
and pe.dataset_presenter_id = edp.dataset_presenter_id
and pe.property = 'hasPairedEnds'
),  
-- end of namemapping 
mappingstats as (
select junctions_pan_id
,round(avg(average_read_length - 2),1) as read_length
, round(avg(number_mapped_reads),1) as mapped_reads
, round(avg(avg_mapping_coverage) * ((avg(average_read_length) - 2) / avg(average_read_length)),2) as avg_mapping_coverage
, count(*) as num_replicates
from (
select Nm.Junctions_Pan_Id,to_number(ca.value) as average_read_length,to_number(cb.value) as number_mapped_reads, to_number(cc.value) as avg_mapping_coverage
from namemapping nm
, STUDY.CHARACTERISTIC ca
, sres.ontologyterm ota
, protocolappnodeio ioa
, STUDY.CHARACTERISTIC cb
, sres.ontologyterm otb
, STUDY.CHARACTERISTIC cc
, sres.ontologyterm otc
where nm.junctions_pan_id = ioa.output_node_id
and ioa.input_node_id = ca.protocol_app_node_id
and ca.value is not null
and ca.QUALIFIER_ID = ota.ONTOLOGY_TERM_ID
and ota.name = 'average read length'
and ca.protocol_app_node_id = cb.protocol_app_node_id
and cb.value is not null
and cb.QUALIFIER_ID = otb.ONTOLOGY_TERM_ID
and otb.name = 'number mapped reads'
and ca.protocol_app_node_id = cc.protocol_app_node_id
and cc.value is not null
and cc.QUALIFIER_ID = otc.ONTOLOGY_TERM_ID
and otc.name = 'average mapping coverage'
)
group by Junctions_Pan_Id
),
-- end of mappingstats
isrmult as (
 select protocol_app_node_id, 'total' as type, count(*) as total_junctions, sum(unique_reads) as total_reads, round(1000000/sum(unique_reads),4) as multiplier
 from apidb.intronjunction
 where unique_reads >= 1
 group by protocol_app_node_id
), 
-- end of isrmult
 annot as (
select distinct gene.feature_source_id as genesource_id,intron.feature_type,intron.na_sequence_id,intron.start_min, intron.end_max, intron.is_reversed
from apidb.FeatureLocation intron,  apidb.FeatureLocation trans, apidb.FeatureLocation gene
where intron.feature_type = 'Intron'
and intron.is_top_level = 1
and trans.na_feature_id = intron.parent_id
and gene.na_feature_id = trans.parent_id
),
-- end of annot = annotated introns
core as (
select junc.intron_junction_id
, nm.exp_name
, nm.external_database_name
, nm.sample_name
, junc.protocol_app_node_id
, junc.na_sequence_id
, junc.segment_start
, junc.segment_end
, junc.unique_reads
, round(junc.unique_reads * isrm.multiplier,2) as isrpm
, junc.nu_reads,max(nafe.value) as value
, nm.switch_strands
, nm.strand
, CASE WHEN max(nafe.value) > 0 THEN round(junc.unique_reads / max(nafe.value),4) ELSE -1 END as exp_ratio
, CASE WHEN max(nafe.value) > 0 THEN round(junc.unique_reads * isrm.multiplier / max(nafe.value),4) ELSE -1 END as isrpm_exp_ratio
, CASE WHEN max(nafe.value) > 0 
  THEN round((max(nafe.value) * ms.mapped_reads / 1000000) * (ms.read_length / 1000),4) 
  ELSE -1 END as avg_coverage
, CASE WHEN max(nafe.value) > 0 
  THEN round(junc.unique_reads / ((max(nafe.value) * ms.mapped_reads / 1000000) * (ms.read_length / 1000)),4)
  ELSE -1 END as isr_coverage_ratio
, junc.is_reversed
-- note:  need to deal with datasets that are unstranded ... this always assumes stranded. 
, CASE WHEN max(ga.is_reversed) keep (dense_rank first order by nafe.value desc) = junc.is_reversed 
  THEN 1 ELSE 0 END as matches_gene_strand
, CASE WHEN count(*) > 1
  THEN max(ga.source_id) keep (dense_rank first order by nafe.value desc)
  ELSE min(ga.source_id)
  END as gene_source_id
, decode(annot.feature_type,'Intron','Yes','No') as annotated_intron
, nm.include_unified_junctions
, nm.show_intron_junctions
FROM apidb.intronjunction junc, geneattributes ga, results.nafeatureexpression nafe, namemapping nm, isrmult isrm, annot, mappingstats ms
WHERE nafe.protocol_app_node_id = nm.exp_pan_id
AND nm.junctions_pan_id = junc.protocol_app_node_id
AND Nm.Junctions_Pan_Id = Ms.Junctions_Pan_Id
AND isrm.protocol_app_node_id = junc.protocol_app_node_id
AND nafe.na_feature_id = ga.na_feature_id
AND ga.na_sequence_id = junc.na_sequence_id
AND ga.start_min <= junc.segment_start
AND ga.end_max >= junc.segment_end
AND ga.is_reversed = junc.is_reversed
AND junc.na_sequence_id = annot.na_sequence_id(+)
AND junc.segment_start = annot.start_min(+)
AND junc.segment_end = annot.end_max(+)
and junc.is_reversed = annot.is_reversed(+)
group by nm.exp_name, nm.external_database_name, nm.sample_name,junc.intron_junction_id,junc.Protocol_App_Node_Id,
         junc.na_sequence_id,junc.segment_start,junc.segment_end,
         junc.unique_reads,junc.nu_reads,nm.switch_strands,junc.is_reversed, isrm.multiplier, nm.strand,
annot.feature_type,nm.include_unified_junctions, 
         nm.show_intron_junctions, ms.read_length, ms.mapped_reads
),  
--end of core
ratiostats as (
select protocol_app_node_id,exp_name,sample_name
, avg(isr_coverage_ratio) as avg_isr_coverage_ratio
, median(isr_coverage_ratio) as median_isr_coverage_ratio
, count(*) as total_introns_averaged
from core
where annotated_intron = 'Yes'
and isr_coverage_ratio != -1
and unique_reads >= 10 
group by protocol_app_node_id,exp_name,sample_name
), -- end of ratiostats
isrmultcons as (
 select protocol_app_node_id, 'consistent' as type, count(*) as total_junctions, sum(unique_reads) as total_reads, round(1000000/sum(unique_reads),4) as multiplier
 from core
 where unique_reads >= 1
 and matches_gene_strand = 1
 group by protocol_app_node_id
),
 totalexpression as (
select Nm.Junctions_Pan_Id,avg(nafe.value) as avg_expression, median(value) as median_expression
from results.nafeatureexpression nafe, namemapping nm
where Nm.Exp_Pan_Id = nafe.protocol_app_node_id
group by Nm.Junctions_Pan_Id
)
/* end with to generate core, namemapping, isrmult and totalexpression --
------------   start of SQL  ------------- */
select intron_junction_id,protocol_app_node_id,exp_name,external_database_name,sample_name,na_sequence_id,segment_start,segment_end,
is_reversed, strand, unique_reads, isrpm, nu_reads,
round(value,4) as exp_value,round(exp_ratio,4) as intron_exp_ratio,round(isrpm_exp_ratio,4) as isrpm_exp_ratio,
avg_coverage, isr_coverage_ratio,norm_isr_coverage_ratio,
round(100 * percent_max_sample,1) as percent_max_sample,
round(100 * percent_max_total,1) as percent_max_total,
round(total_ratio,4) as total_ratio,matches_gene_strand,annotated_intron,
decode(percent_max_sample,-1,0,1) as is_contained, gene_source_id,
intron_sample_avgexp_ratio, isrpm_sample_avgexp_ratio, intron_sample_medexp_ratio,isrpm_sample_medexp_ratio,
isr_avgcoverage_ratio,norm_isr_avgcoverage_ratio,
total_junctions as sample_total_junctions,multiplier as sample_multiplier, consistent_multiplier, 
round(multiplier / consistent_multiplier,4) as total_cons_mult_ratio,
include_unified_junctions, show_intron_junctions
from (select c.*,gene_tot.total_ratio,gene_tot.isrpm_total_ratio,
CASE WHEN gene_tot.max_total_unique >= 1 THEN c.unique_reads / gene_tot.max_total_unique ELSE 0 END as percent_max_total,
CASE WHEN sample_tot.max_sample_unique >= 1 THEN c.unique_reads / sample_tot.max_sample_unique ELSE 0 END as percent_max_sample,
CASE WHEN te.avg_expression > 0 THEN round(c.unique_reads/te.avg_expression,4) ELSE 0 END as intron_sample_avgexp_ratio,
CASE WHEN te.avg_expression > 0 THEN round(c.isrpm/te.avg_expression,4) ELSE 0 END as isrpm_sample_avgexp_ratio,
CASE WHEN te.median_expression > 0 THEN round(c.unique_reads/te.median_expression,4) ELSE 0 END as intron_sample_medexp_ratio,
CASE WHEN te.median_expression > 0 THEN round(c.isrpm/te.median_expression,4) ELSE 0 END as isrpm_sample_medexp_ratio,
CASE WHEN ms.avg_mapping_coverage > 0 THEN round(c.unique_reads/ms.avg_mapping_coverage,4) ELSE 0 END as isr_avgcoverage_ratio,
CASE WHEN ms.avg_mapping_coverage > 0 THEN round(
/*     CASE WHEN c.unique_reads/ms.avg_mapping_coverage / nr.median_isr_coverage_ratio > 1 THEN 1 
          ELSE */ c.unique_reads/ms.avg_mapping_coverage / nr.median_isr_coverage_ratio -- END 
                                                 ,4) ELSE 0 END as norm_isr_avgcoverage_ratio,
CASE WHEN ms.avg_mapping_coverage > 0 THEN round(
/*     CASE WHEN c.isr_coverage_ratio / nr.median_isr_coverage_ratio > 1 THEN 1 
          ELSE */ c.isr_coverage_ratio / nr.median_isr_coverage_ratio -- END
                                                 ,4) ELSE 0 END as norm_isr_coverage_ratio,
isrmult.total_junctions,isrmult.multiplier,isrmultcons.multiplier as consistent_multiplier
  from
  (select gene_source_id,max(unique_reads) as max_total_unique, max(isrpm) as max_isrpm_unique, sum(value) as total_exp, 
  CASE WHEN sum(value) > 0 THEN sum(unique_reads) / sum(value) ELSE null END as total_ratio,
  CASE WHEN sum(value) > 0 THEN sum(isrpm) / sum(value) ELSE null END as isrpm_total_ratio
  from core
  group by core.gene_source_id) gene_tot, 
  (select protocol_app_node_id,gene_source_id,max(unique_reads) as max_sample_unique,max(isrpm) as max_sample_isrpm 
  from core
  group by protocol_app_node_id,gene_source_id) sample_tot,
  core c, totalexpression te, isrmult, isrmultcons, mappingstats ms, ratiostats nr
  where gene_tot.gene_source_id = c.gene_source_id
  AND c.protocol_app_node_id = ms.junctions_pan_id
  AND sample_tot.protocol_app_node_id = c.protocol_app_node_id
  AND sample_tot.gene_source_id = c.gene_source_id
  AND te.junctions_pan_id = c.protocol_app_node_id
  AND c.protocol_app_node_id = isrmult.protocol_app_node_id
  AND c.protocol_app_node_id = isrmultcons.protocol_app_node_id
  AND c.protocol_app_node_id = nr.protocol_app_node_id
  UNION ALL
-- union this with intronjunction that are not in core adding in exp_name,sample_name 
-- first do minus to get missing junctions and join to names.
-- need to add in the isrpm stuff as is above.  Will need to join to isrmult
select introns.intron_junction_id,names.exp_name,names.external_database_name,names.sample_name,introns.Protocol_App_Node_Id,introns.na_sequence_id,introns.segment_start,introns.segment_end, 
introns.unique_reads,round(introns.unique_reads * isrmult.multiplier,2) as isrpm, introns.nu_reads,
-1 as value,names.switch_strands, names.strand,-1 as exp_ratio,-1 as isrpm_exp_ratio,-1 as avg_coverage,-1 as isr_coverage_ratio,
CASE WHEN names.switch_strands = 'false'
  THEN introns.is_reversed
  WHEN names.switch_strands = 'true'
  THEN decode(introns.is_reversed,0,1,1,0,-1)
  ELSE -1
END as is_reversed,
-1 as matches_gene_strand, '' as gene_source_id,'No' as annotated_intron, 
names.include_unified_junctions, names.show_intron_junctions,
-1 as total_ratio,-1 as isrpm_total_ratio,
-1 as percent_max_total, -1 as percent_max_sample,
CASE WHEN te.avg_expression > 0 THEN round(introns.unique_reads/te.avg_expression,4) ELSE 0 END as intron_sample_avgexp_ratio,
CASE WHEN te.avg_expression > 0 THEN round(introns.unique_reads*isrmult.multiplier/te.avg_expression,4) ELSE 0 END as isrpm_sample_avgexp_ratio,
CASE WHEN te.median_expression > 0 THEN round(introns.unique_reads/te.median_expression,4) ELSE 0 END as intron_sample_medexp_ratio,
CASE WHEN te.median_expression > 0 THEN round(introns.unique_reads*isrmult.multiplier/te.median_expression,4) ELSE 0 END as isrpm_sample_medexp_ratio,
CASE WHEN ms.avg_mapping_coverage > 0 THEN round(introns.unique_reads/ms.avg_mapping_coverage,4) ELSE 0 END as isr_avgcoverage_ratio,
CASE WHEN ms.avg_mapping_coverage > 0 THEN round(
/*     CASE WHEN introns.unique_reads/ms.avg_mapping_coverage / nr.median_isr_coverage_ratio > 1 THEN 1 
          ELSE */ introns.unique_reads/ms.avg_mapping_coverage / nr.median_isr_coverage_ratio -- END
                                                 ,4) ELSE 0 END as norm_isr_avgcoverage_ratio,
-1 as norm_isr_coverage_ratio,
isrmult.total_junctions,isrmult.multiplier,isrmultcons.multiplier as consistent_multiplier
FROM (select intron_junction_id
from apidb.intronjunction
MINUS
select intron_junction_id
from core) mi,
namemapping names, totalexpression te, isrmult,isrmultcons, apidb.intronjunction introns, mappingstats ms, ratiostats nr
where introns.intron_junction_id = mi.intron_junction_id
AND introns.protocol_app_node_id = names.junctions_pan_id
AND te.junctions_pan_id = introns.protocol_app_node_id
AND introns.protocol_app_node_id = isrmult.protocol_app_node_id
AND introns.protocol_app_node_id = isrmultcons.protocol_app_node_id
AND introns.protocol_app_node_id = nr.protocol_app_node_id
AND ms.junctions_pan_id = introns.protocol_app_node_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneIntronJunc_ix&1 on GeneIntronJunction&1 (na_sequence_id,segment_start,segment_end)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneIntronJuncGeneId_ix&1 on GeneIntronJunction&1 (gene_source_id, matches_gene_strand)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="PopsetSequence">
    <comment> Each record stores the nucleotide sequence of one popset. Used in the
         relevant attribute query of the WDK popset record, as well as by
         PopsetClustalw. Propagated to portal instances.
     </comment>
    <internalDependency name="PopsetAttributes"/>
    <externalDependency name="dots.NaSequence"/>
    <sql>
      <![CDATA[
CREATE TABLE PopsetSequence&1 NOLOGGING AS
SELECT ia.source_id, ia.project_id,
       ns.sequence
FROM PopsetAttributes ia, dots.NaSequence ns
WHERE ia.na_sequence_id = ns.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index PopsetSeq_ix&1 on PopsetSequence&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>



  <tuningTable name="OrganismAbbreviation">
    <comment> Each record maps an organism name onto an abbreviation, getting the
         pair either from apidb.Organism or (in the case of Tvag), hardwired
         into the below SQL. This table will eventually be replaced by workflow.
      </comment>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
       CREATE TABLE OrganismAbbreviation&1 NOLOGGING AS
       select organism, abbreviation
       From (
  select tn.name as organism, o.name_for_filenames as abbreviation
  from apidb.Organism o, sres.TaxonName tn
  where o.taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
       )
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="OrganismAbbreviationWS">
    <comment> Stores special webservice abbreviations which are not standard organism
         names. Each record maps an organism name onto this abbreviation, as
         well as the species name and project ID. Used by the model and as an
         input in the creation of the OrganismAbbreviationBlast tuning table.
         Propagated to portal instances.
      </comment>
    <internalDependency name="OrganismAbbreviation"/>
    <internalDependency name="OrganismTree"/>
    <sql>
      <![CDATA[
       create table OrganismAbbreviationWS&1 nologging as
       select oa.organism, ot.parentTerm as parent, oa.abbreviation, ot.project_id
       from OrganismAbbreviation oa, OrganismTree ot
       where ot.term = oa.organism
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ProjectIdTaxonLevel">
    <comment> Groups projects by higher level taxonomy. Used in the creation of the
         OrganismTree tuning table.
      </comment>
    <internalDependency name="GenomicSeqAttributes"/>
    <sql>
      <![CDATA[
       CREATE TABLE ProjectIdTaxonLevel&1 NOLOGGING AS
       SELECT p.project_id, taxon_node, organism
          FROM (SELECT 'PlasmoDB' AS project_id,
		       'Apicomplexa' AS  taxon_node 
		FROM dual 
		UNION
		SELECT 'CryptoDB' AS project_id,
			   'Apicomplexa' AS  taxon_node 
		FROM dual 
		UNION
		SELECT 'ToxoDB' AS project_id,
		           'Apicomplexa' AS  taxon_node 
		FROM dual 
		UNION
		SELECT 'PiroplasmaDB' AS project_id,
		           'Apicomplexa' AS  taxon_node 
		FROM dual
		UNION
		SELECT 'TriTrypDB' AS project_id,
			   'Kinetoplastida' AS  taxon_node 
		FROM dual 
		UNION
		SELECT 'AmoebaDB' AS project_id,
			   'Amoebozoa' AS  taxon_node 
		FROM dual
		UNION 
		SELECT 'MicrosporidiaDB' AS project_id,
		           'Microsporidia' AS  taxon_node 
		FROM dual
		UNION
		SELECT 'GiardiaDB' AS project_id, 
		           'Diplomonadida' AS taxon_node 
		FROM dual
		UNION
		SELECT 'TrichDB' AS project_id,
		           'Trichomonadida' AS taxon_node
		FROM dual
        ) p,
        (select distinct project_id, organism from GenomicSeqAttributes) s
        where p.project_id = s.project_id
        union 
        SELECT distinct s.project_id as project_id, 
          CASE
            when (s.organism like 'Coprinopsis%' or
                  s.organism like 'Phanerochaete%')
            then 'Agaricomycetes'
            when (s.organism like 'Allomyces%')
            then 'Blastocladiomycetes'
            when (s.organism like 'Batrachochytrium%' or
                  s.organism like 'Spizellomyces%') 
            then 'Chytridiomycetes'
            when (s.organism like 'Aspergillus%' or
                  s.organism like 'Emericella%' or
                  s.organism like 'Coccidioides%' or
                  s.organism like 'Histoplasma%' or
                  s.organism like 'Talaromyces%' or
                  s.organism like 'Penicillium%' or
                  s.organism like 'Neosartorya%' or
                  s.organism like 'Paracoccidioides%' or
                  s.organism like 'Ajellomyces%')
            then 'Eurotiomycetes'
            when (s.organism like 'Sclerotinia%' or
                  s.organism like 'Botrytis%' or 
                  s.organism like 'Botryotinia%')
            then 'Leotiomycetes'
            when (s.organism like 'Hyaloperonospora%' or
                  s.organism like 'Phytophthora%' or
                  s.organism like 'Saprolegnia%' or
                  s.organism like 'Albugo%' or
                  s.organism like 'Aphanomyces%' or
                  s.organism like 'Pythium%')
            then 'Oomycetes'
            when (s.organism like 'Pneumocystis%')
            then 'Pneumocystidomycetes'
            when (s.organism like 'Puccinia%' or
                  s.organism like 'Melampsora%')
            then 'Pucciniomycetes'
            when (s.organism like 'Saccharomyces%' or
                  s.organism like 'Yarrowia%' or
                  s.organism like 'Candida%')
            then 'Saccharomycetes'
            when (s.organism like 'Schizosaccharomyces%')
            then 'Schizosaccharomycetes' 
            when (s.organism like 'Neurospora%' or 
                  s.organism like 'Magnaporthe%' or 
                  s.organism like 'Fusarium%' or 
                  s.organism like 'Gibberella%' or
                  s.organism like 'Trichoderma%' or
                  s.organism like 'Sordaria%')
            then 'Sordariomycetes'
            when (s.organism like 'Tremella%' or
                  s.organism like 'Cryptococcus%')
            then 'Tremellomycetes'
            when (s.organism like 'Ustilago%' or
                  s.organism like 'Malassezia%' or 
                  s.organism like 'Sporisorium%') 
            then 'Ustilaginomycetes'
            when (s.organism like 'Rhizopus%' or
                  s.organism like 'Mucor%' or
                  s.organism like 'Phycomyces%')
            then 'Zygomycetes'
            else 'Missing ProjectIdTaxonLevel'
          end as taxon_node,
          s.organism as organism
        from GenomicSeqAttributes s
        where s.project_id = 'FungiDB'
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="OrganismTree">
    <comment> Group species by higher level taxonomy. Each row associates a taxon of
         interest with one of its ancestors in the taxon tree. Used in parameter
         queries that have to know about the taxon tree, as well as
         apidb.project_id(), the function that maps an organism name to a
         project. Propagated to portal instances.
      </comment>
    <internalDependency name="ProjectIdTaxonLevel"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.Taxon"/>
    <intermediateTable name="StrainTree"/>
    <sql>
      <![CDATA[
CREATE TABLE StrainTree NOLOGGING AS
SELECT *
FROM (         SELECT organism,term,parentTerm, internal,project_id
         FROM (
           /* all organisms from GenomicSeqAttributes as organism, organism as term, parentterm is species            */
           SELECT DISTINCT sa.organism AS organism,
                           sa.organism AS term,
                           sn.name AS parentTerm,
                           t.taxon_id AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, sres.TaxonName tn,
                sres.Taxon t, sres.TaxonName sn, TaxonSpecies ts
           WHERE tn.name = sa.organism
           AND  ts.taxon_id = tn.taxon_id
           AND  sn.taxon_id = ts.species_taxon_id
           AND t.taxon_id = ts.taxon_id
           AND sn.name_class = 'scientific name'
           AND t.rank != 'species'
           UNION
           /* all organisms from GenomicSeqAttributes as organism, species as term, parentterm is genus   */
           /* we are getting a row for species level AND for children here */
           SELECT DISTINCT sa.organism,  
                          sn.name AS term,
                          SUBSTR(sa.organism,0,(INSTR(sa.organism,' ') - 1)) AS parentTerm,
                          tn.taxon_id AS internal,
                          sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, sres.Taxon t, 
                sres.TaxonName tn, sres.TaxonName sn,
                TaxonSpecies ts
           WHERE tn.name = sa.organism
           AND  ts.taxon_id = tn.taxon_id
           AND  sn.taxon_id = ts.species_taxon_id
           AND t.taxon_id = ts.taxon_id
           AND sn.name_class = 'scientific name'
           UNION 
           SELECT DISTINCT sa.organism,
                          sn.name AS term,
                          SUBSTR(sa.organism,0,(INSTR(sa.organism,' ') - 1)) AS parentTerm,
                          sn.taxon_id AS internal,
                          sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, sres.Taxon t, 
                sres.TaxonName tn, sres.TaxonName sn,
                TaxonSpecies ts
           WHERE tn.name = sa.organism
           AND  ts.taxon_id = tn.taxon_id
           AND  sn.taxon_id = ts.species_taxon_id
           AND t.taxon_id = ts.taxon_id
           AND sn.name_class = 'scientific name'
           UNION
           /* all organisms from GenomicSeqAttributes as organism, genus as term, parentterm from taxonlevel */
           SELECT DISTINCT sa.organism,      
                           SUBSTR(sa.organism,0,(INSTR(sa.organism,' ') - 1)) AS term,
                           ptl.taxon_node AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
           AND ptl.organism = sa.organism
           and ptl.organism not like 'Chromera%'
           and ptl.organism not like 'Vitrella%' 
           UNION
           /* all organisms from GenomicSeqAttributes as organism, taxon_node as term, parentterm is null */
           SELECT DISTINCT sa.organism,               
                           ptl.taxon_node AS term,
                           '' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism
            and ptl.project_id not in ('FungiDB','MicrosporidiaDB')
            and ptl.organism not like 'Chromera%'
            and ptl.organism not like 'Vitrella%' 
            UNION
            -- add the kingdom for Fungi organism (this includes MicrosporidiaDB organisms)
            SELECT DISTINCT sa.organism,               
                           ptl.taxon_node AS term,
                           'Fungi' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism
            and ptl.project_id in ('FungiDB','MicrosporidiaDB')
            and ptl.taxon_node != 'Oomycetes'
            UNION
            SELECT DISTINCT sa.organism,               
                           'Fungi' AS term,
                           '' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism
            and ptl.project_id in ('FungiDB','MicrosporidiaDB')
            and ptl.taxon_node != 'Oomycetes'
            UNION
            -- add the kingdom for Oomycetes in FungiDB
            SELECT DISTINCT sa.organism,               
                           ptl.taxon_node AS term,
                           'Oomycetes' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism
            and ptl.taxon_node = 'Oomycetes'
            UNION
            SELECT DISTINCT sa.organism,               
                           'Oomycetes' AS term,
                           '' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism
            and ptl.taxon_node = 'Oomycetes'
                        UNION
            -- add the phylum for chomera and vitrella
          SELECT DISTINCT sa.organism,               
                            SUBSTR(sa.organism,0,(INSTR(sa.organism,' ') - 1)) AS term,
                           'Chromerida' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa
           WHERE sa.organism like 'Chromera%'
            or sa.organism like 'Vitrella%'
            UNION
            SELECT DISTINCT sa.organism,               
                           'Chromerida' AS term,
                           '' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa
           WHERE sa.organism like 'Chromera%'
            or sa.organism like 'Vitrella%'           
))
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE OrganismTree&1 NOLOGGING AS
         SELECT organism,term,parentTerm, internal,project_id
         FROM (
               SELECT * from StrainTree
               UNION
               SELECT stn.name as organism,
                      st.term as term,
                      st.parentTerm as parentTerm,
                      st.internal as internal,
                      st.project_id as project_id
               FROM StrainTree st, TaxonSpecies ts, sres.TaxonName tn, sres.TaxonName stn
               WHERE tn.taxon_id = ts.taxon_id
                 AND stn.taxon_id = ts.species_taxon_id
                 AND st.organism = tn.name
                 AND tn.name_class = 'scientific name'
                 AND stn.name_class = 'scientific name'
                 AND st.organism != st.term
          )
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrganismAbbreviationBlast">
    <comment> Each record maps an organism to its BLAST abbreviation. Used by
         BLAST-query parameters. Propagated to portal instances.
      </comment>
    <internalDependency name="OrganismAbbreviationWS"/>
    <internalDependency name="OrganismTree"/>
    <internalDependency name="EstAttributes"/>
    <sql>
      <![CDATA[
       create table OrganismAbbreviationBlast&1 nologging as
       select organism, parent, abbreviation, project_id from OrganismAbbreviationWS
         union
      /* All familes for popsets */
      select distinct family_name_for_files || ' Popset/Genbank Isolates' as organism, '' as parent, family_name_for_files as abbreviation, project_name as project_id
      from apidb.Organism 
       where family_name_for_files is not null
       and family_name_for_files NOT IN ('Culicosporidae', 'Dubosqiidae', 'Ordosporidae')
       union
       select special.organism, special.parent, special.abbreviation, ot.project_id from OrganismTree ot,
       (
  /* All species and speciesAbbreviations from apidb.Organism where we have ests */
  select distinct sp.name as organism,
                  ot.parentTerm as parent,
                  REGEXP_REPLACE(org.name_for_filenames, org.strain_abbrev,'', 1, 1) as abbreviation 
  from sres.TaxonName sp, taxonspecies ts, apidb.Organism org, organismtree ot,
       estattributes ea, sres.TaxonName etn, taxonspecies ets
  where org.taxon_id = ts.taxon_id
  and ts.species_taxon_id = sp.taxon_id
  and sp.name_class = 'scientific name'
  and ot.term = sp.name
  and org.strain_abbrev is not null
  and org.name_for_filenames is not null
  and ets.species_taxon_id = sp.taxon_id
  and (ets.taxon_id = etn.taxon_id OR ets.species_taxon_id = etn.taxon_id)
  and etn.name = ea.organism
  union
  /* TrichDB EST Legacy */
/*  select 'Trichomonas vaginalis' as organism, 'Trichomonas' as parent, 'Tvaginalis' as abbreviation from dual union   */
  /* */
  select 'Cryptosporidiidae SSU_18srRNA Reference Isolates' as organism, 'Cryptosporidium' as parent, 'CryptosporidiidaeReference' as abbreviation from dual
) special
      where special.parent = ot.term
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="BlastTypes">
    <comment> For each project, show which BLAST databases are available for which
         species. Used in BLAST param queries. Propagated to portal instances.
      </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <internalDependency name="EstAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
       create table BlastTypes&1 nologging as
  /* Standard GENES */
  select distinct organism, project_id, type 
  from TranscriptAttributes,
       (select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  where organism not in ('Toxoplasma gondii RH') and gene_type = 'protein coding' 
  UNION
  /* GiardiaDB Deprecated Genes */
  select 'Giardia Assemblage A isolate WB (deprecated)' as organism, 'GiardiaDB' as project_id, type 
  from dual, (select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  UNION
  /* GiardiaDB Scaffolds */
  select 'Giardia Assemblage A isolate WB (scaffolds)' as organism, 'GiardiaDB' as project_id, type 
  from dual, (select 'Genome' as type from dual)
  UNION  
  /* Standard GENOME */
  select distinct organism, project_id, type 
  from GenomicSeqAttributes,
       (select 'ORFs_AA' as type from dual union select 'Genome' as type from dual)
  UNION
  /* Mitochondrial GENES and GENOME */
  select distinct organism || ' mitochondrial', project_id, type 
  from GenomicSeqAttributes,       
  (select 'ORFs_AA' as type from dual union select 'Genome' as type from dual union select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  where so_id = 'SO:0000819'
  and not project_id='PlasmoDB' 
  UNION
  /* Plastid GENES and GENOME */
  select distinct organism || ' plastid' as organism, project_id, type 
  from GenomicSeqAttributes,       
  (select 'ORFs_AA' as type from dual union select 'Genome' as type from dual union select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  where so_id = 'SO:0001259'
  and not project_id='PlasmoDB' 
  UNION
  /* Regular ESTs (all species from estattributes) */
  select distinct sp.name as organism, ea.project_id, 'ESTs' as type
  from EstAttributes ea, sres.TaxonName tn, taxonspecies ts, sres.TaxonName sp
  where ea.organism = tn.name
  and (tn.taxon_id = ts.taxon_id or tn.taxon_id=ts.species_taxon_id)
  and ts.species_taxon_id = sp.taxon_id
  and sp.name_class = 'scientific name'
  UNION
  /* regular Isolates */
  select distinct family_name_for_files || ' Popset/Genbank Isolates' as organism, project_name as project_id, 'PopSet'
  from apidb.Organism 
  where family_name_for_files is not null
  UNION
  /* isolates are hard coded */
  select 'P. falciparum Barcode Isolates' as organism, 'PlasmoDB' as project_id, 'PopSet' as type from dual
  UNION
  select 'P. berghei Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type from dual
  UNION
  select 'P. chabaudi Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type from dual
  UNION
  select 'P. falciparum Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type from dual
  UNION
  select 'P. knowlesi Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type from dual
  UNION
  select 'P. reichenowi Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type from dual
  UNION
  select 'P. vivax Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type from dual
  UNION
  select 'P. yoelii Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'PopSet' as type from dual
  UNION
  select 'All Giardia Isolates' as organism, 'GiardiaDB' as project_id, 'PopSet' as type from dual
  UNION
  select 'Cryptosporidiidae SSU_18srRNA Reference Isolates' as organism, 'CryptoDB' as project_id, 'PopSet' as type from dual
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="CompoundProperties"  prefixEnabled="true" alwaysUpdate="true">
    <comment> Properties table for ChEBI Compounds.
    </comment>
    <!-- externalDependency name="chebi.compounds"/ -->
    <!-- externalDependency name="chebi.names"/ -->
    <!-- externalDependency name="chebi.chemical_data"/ -->
    <sql>
      <![CDATA[
CREATE TABLE CompoundProperties&1 NOLOGGING AS
SELECT c.ID, c.chebi_accession AS source_id, c.parent_id,
    c.name AS compound_name,
    substr(apidb.tab_to_string(set(cast(COLLECT(to_char(cn.name)) AS apidb.varchartab)), ', '), 1, 1000) AS other_names,
    substr(apidb.tab_to_string(set(cast(COLLECT(to_char(ciup.iupac_name)) AS apidb.varchartab)), ', '), 1, 1000) AS iupac_name,
    substr(apidb.tab_to_string(set(cast(COLLECT(to_char(csyn.syn)) AS apidb.varchartab)), ', '), 1, 1000) AS syn,
    c.definition, m.mass,
    apidb.tab_to_string(set(cast(COLLECT(formu.formula order by formu.formula) as apidb.varchartab)), ', ') AS formula,
    apidb.tab_to_string(set(cast(COLLECT(sec.chebi_accession order by sec.chebi_accession) as apidb.varchartab)), ', ') AS secondary_ids
FROM  chebi.compounds c, 
  ( SELECT compound_id,  NAME FROM chebi.names WHERE TYPE='NAME') cn,
  ( SELECT compound_id,  MIN(NAME) AS iupac_name FROM chebi.names WHERE TYPE='IUPAC NAME' GROUP BY compound_id) ciup,
  ( SELECT compound_id,  MIN(NAME) AS syn FROM chebi.names WHERE type='SYNONYM' GROUP BY compound_id) csyn,
  ( SELECT compound_id, chemical_data AS formula FROM chebi.chemical_data WHERE TYPE='FORMULA') formu,
  ( SELECT compound_id, chemical_data AS mass FROM chebi.chemical_data WHERE TYPE='MASS') m,
  ( SELECT parent_id, chebi_accession FROM chebi.compounds) sec
WHERE NOT c.status in ('D', 'F')
AND c.ID = cn.compound_id (+)
AND c.ID = ciup.compound_id (+)
AND c.ID = csyn.compound_id (+)
AND c.ID = formu.compound_id (+)
AND c.ID = m.compound_id (+)
AND c.ID = sec.parent_id (+)
GROUP BY c.ID, c.chebi_accession, c.parent_id, c.name, c.definition, m.mass
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="CompoundAttributes"  prefixEnabled="true" alwaysUpdate="true">
    <comment> The BFMV for the compound WDK record type. Used by the model for the
         compound record and queries, as well as in the creation of the
         PathwayCompounds tuning table. Propagated to portal instances.
         Note: children of ChEBI compounds are excluded, but data of these is gathered in the (parent) entries.
      </comment>
    <internalDependency name="CompoundProperties"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixCompoundAttributes&1 NOLOGGING AS
SELECT p.ID
, p.source_id
, p.compound_name
, apidb.tab_to_string(SET(CAST(COLLECT(childc.other_names ORDER BY childc.other_names) AS apidb.varchartab)), ', ') AS other_names
, apidb.tab_to_string(SET(CAST(COLLECT(childc.iupac_name ORDER BY childc.iupac_name) AS apidb.varchartab)), ', ') AS iupac_name
, apidb.tab_to_string(SET(CAST(COLLECT(childc.syn ORDER BY childc.syn) AS apidb.varchartab)), ', ') AS syn
, p.definition  
, p.secondary_ids
, apidb.tab_to_string(SET(CAST(COLLECT(childc.formula ORDER BY childc.formula) AS apidb.varchartab)), ', ') AS formula
, (avg(childc.mass)) AS mass
FROM CompoundProperties p
, (SELECT id, parent_id, other_names, iupac_name, syn, mass, formula FROM CompoundProperties ) childc
WHERE p.parent_id IS NULL
AND  (p.ID = childc.parent_id OR p.ID =childc.ID )
GROUP BY p.ID, p.source_id, p.compound_name, p.definition, p.secondary_ids
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="CompoundId"  prefixEnabled="true">
    <comment> Alias table for Compounds.
    Compound column is the source_id from CompoundAttributes (chEBI_ID).
    ID can have this same ID, or mapping KEGG ID, or Name, or Synonym.
    </comment>
    <internalDependency name="CompoundAttributes"/>
    <internalDependency name="CompoundProperties"/>
    <!-- externalDependency name="chebi.Compounds"/ -->
    <sql>
      <![CDATA[
        CREATE TABLE &prefixCompoundId&1 NOLOGGING AS
      SELECT source_id AS id, source_id AS compound, 'same ID' AS type, '' as source 
      FROM &prefixCompoundAttributes
      UNION
      SELECT p.source_id AS id, ca.source_id AS compound, 'child ID' AS type, '' as source 
      FROM &prefixCompoundAttributes ca, CompoundProperties p
      WHERE ca.id = p.parent_id
      UNION
      SELECT da.accession_number AS id,  p.source_id AS compound, 'KEGG'  AS type, '' as source 
      FROM chebi.database_accession da, &prefixCompoundAttributes p
      WHERE da.type='KEGG COMPOUND accession' 
      AND  da.compound_id = p.id
      UNION
      SELECT  distinct da.accession_number AS id,  p.chebi_accession AS compound, 'KEGG'  as type, '' as source 
      FROM chebi.database_accession da, chebi.compounds c, chebi.compounds p
      WHERE NOT p.status in ('D', 'F') AND da.type='KEGG COMPOUND accession' 
      AND da.compound_id = c.id AND c.parent_id=p.id
      UNION
      SELECT n.name as id, ca.source_id as compound, 'name' as type, n.source
      FROM &prefixCompoundAttributes ca, chebi.names n
      WHERE ca.id = n.compound_id
      AND n.type = 'NAME' 
      UNION
      SELECT n.name as id, ca.source_id as compound, 'synonym' as type, n.source
      FROM &prefixCompoundAttributes ca, chebi.names n
      WHERE ca.id = n.compound_id
      AND n.type = 'SYNONYM'
      ]]>
    </sql>
    <sql>
      <![CDATA[
      CREATE INDEX &prefixCompoundId_idx&1 ON &prefixCompoundId&1 (id, compound)
      TABLESPACE indx
      ]]>
    </sql>

  </tuningTable>


  <tuningTable name="PathwayCompounds">
    <comment> Each record represents a 5-tuple of (reaction, compound, pathway,
         enzyme, type). Used extensively in the model for pathway-related
         queries, as well as by getImageMap.pl.
      </comment>
    <externalDependency name="sres.Pathway"/>
    <externalDependency name="sres.PathwayNode"/>
    <externalDependency name="sres.PathwayRelationship"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="apidb.PathwayReactionRel"/>
    <externalDependency name="apidb.PathwayReaction"/>
    <!-- externalDependency name="chebi.Compounds"/ -->
    <sql>
      <![CDATA[
    CREATE TABLE PathwayCompounds&1 NOLOGGING AS
    select pathway_id
    , reaction_id
    , ext_db_name
    , ext_db_version
    , compound_node_id
    , compound_source_id
    , c.chebi_accession
    , case when c.chebi_accession is not null then 'https://www.ebi.ac.uk/chebi/searchId.do?chebiId=' || c.chebi_accession else null end as chebi_url
    , type
    from (
        select 
        p.PATHWAY_ID
        , prx.PATHWAY_REACTION_ID as reaction_id
        , ed.NAME as ext_db_name
        , edr.version as ext_db_version
        , pn.pathway_node_id as compound_node_id
        , pn.DISPLAY_LABEL as compound_source_id
        , 'substrate' as type
        , pn.row_id
        from
        APIDB.PATHWAYREACTION prx
        , SRES.PATHWAY p
        , APIDB.PATHWAYREACTIONREL prr
        , SRES.PATHWAYNODE pn
        , SRES.PATHWAYRELATIONSHIP prel
        , SRES.ONTOLOGYTERM ot
        , SRES.EXTERNALDATABASE ed
        , SRES.EXTERNALDATABASERELEASE edr
        where p.PATHWAY_ID = prr.PATHWAY_ID
        and prx.PATHWAY_REACTION_ID = prr.PATHWAY_REACTION_ID
        and prr.PATHWAY_RELATIONSHIP_ID = prel.PATHWAY_RELATIONSHIP_ID
        and prel.NODE_ID = pn.PATHWAY_NODE_ID
        and ot.NAME = 'molecular entity'
        and ot.ONTOLOGY_TERM_ID = pn.PATHWAY_NODE_TYPE_ID
        and p.EXTERNAL_DATABASE_RELEASE_ID = edr.EXTERNAL_DATABASE_RELEASE_ID
        and edr.EXTERNAL_DATABASE_ID = ed.EXTERNAL_DATABASE_ID)
    LEFT OUTER JOIN CHEBI.COMPOUNDS c on row_id = c.ID
    union
    select pathway_id
    , reaction_id
    , ext_db_name
    , ext_db_version
    , compound_node_id
    , compound_source_id
    , c.chebi_accession
    , case when c.chebi_accession is not null then 'https://www.ebi.ac.uk/chebi/searchId.do?chebiId=' || c.chebi_accession else null end as chebi_url
    , type
    from (
        select 
        p.PATHWAY_ID
        , prx.PATHWAY_REACTION_ID as reaction_id
        , ed.NAME as ext_db_name
        , edr.version as ext_db_version
        , pn.pathway_node_id as compound_node_id
        , pn.DISPLAY_LABEL as compound_source_id
        , 'product' as type
        , pn.row_id
        from
        APIDB.PATHWAYREACTION prx
        , SRES.PATHWAY p
        , APIDB.PATHWAYREACTIONREL prr
        , SRES.PATHWAYNODE pn
        , SRES.PATHWAYRELATIONSHIP prel
        , SRES.ONTOLOGYTERM ot
        , SRES.EXTERNALDATABASE ed
        , SRES.EXTERNALDATABASERELEASE edr
        where p.PATHWAY_ID = prr.PATHWAY_ID
        and prx.PATHWAY_REACTION_ID = prr.PATHWAY_REACTION_ID
        and prr.PATHWAY_RELATIONSHIP_ID = prel.PATHWAY_RELATIONSHIP_ID
        and prel.ASSOCIATED_NODE_ID = pn.PATHWAY_NODE_ID
        and ot.NAME = 'molecular entity'
        and ot.ONTOLOGY_TERM_ID = pn.PATHWAY_NODE_TYPE_ID
        and p.EXTERNAL_DATABASE_RELEASE_ID = edr.EXTERNAL_DATABASE_RELEASE_ID
        and edr.EXTERNAL_DATABASE_ID = ed.EXTERNAL_DATABASE_ID)
    LEFT OUTER JOIN CHEBI.COMPOUNDS c on row_id = c.ID
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index PthCmpd_id_ix&1
        on PathwayCompounds&1(pathway_id, reaction_id, ext_db_name)
        tablespace indx
      ]]>
    </sql>

  </tuningTable>

  <tuningTable name="PathwayReactions">
    <comment>Aggregates reactions irrespective of pathway.  Required to determine if BioCyc reactions are reversible.  Used extensively in the model in conjunction with pathwaycompounds for pathway related queries</comment>
    <externalDependency name="sres.Pathway"/>
    <externalDependency name="sres.PathwayNode"/>
    <externalDependency name="sres.PathwayRelationship"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="apidb.PathwayReactionRel"/>
    <externalDependency name="apidb.PathwayReaction"/>
    <internalDependency name="PathwayCompounds"/>

    <sql>
      <![CDATA[
        CREATE TABLE PathwayReactions&1 NOLOGGING AS
        select o.*
        , (case when o.expasy_url is not null then '<a href="' || o.expasy_url || '">' || o.enzyme || '</a>' else o.enzyme end) as expasy_html
        from (
            select i.*
            , (case when i.enzyme like '%.%.%.%' then 'http://enzyme.expasy.org/cgi-bin/enzyme/enzyme-search-ec?field1='
                ||ec.ec_number_1
                ||decode(ec.ec_number_2, null, null,chr(38) || 'field2='||ec.ec_number_2)
                ||decode(ec.ec_number_3, null, null,chr(38) || 'field3='||ec.ec_number_3)
                ||decode(ec.ec_number_4, null, null,chr(38) || 'field4='||ec.ec_number_4) else null end ) as expasy_url
            from (
                select
                reaction_id
                , reaction_source_id
                , reaction_url
                , ext_db_name
                , ext_db_version
                , enzyme
                , substrates_html || ' ' || sign || ' ' || products_html as equation_html
                , substrates_text || ' ' || sign || ' ' || products_text as equation_text
                , case when sign = '<=>' then 1 else 0 end as is_reversible
                , substrates_text
                , products_text
                from (
                    select
                    reaction_id
                    , reaction_source_id
                    , reaction_url
                    , ext_db_name
                    , ext_db_version
                    , enzyme
                    , (case when (listagg (case when type_list like '%substrate%' then compound end, ',') within group (order by compound)) = (listagg (case when type_list like '%product%' then compound end, ',') within group (order by compound)) or is_reversible = 1 then '<=>' else '=>' end) as sign
                    , listagg (case when type like '%substrate%' then compound_url end, ' + ') within group (order by compound_url) as substrates_html
                    , listagg (case when type like '%substrate%' then compound end, ' + ') within group (order by compound) as substrates_text
                    , listagg (case when type like '%product%' then compound_url end, ' + ') within group (order by compound_url) as products_html
                    , listagg (case when type like '%product%' then compound end, ' + ') within group (order by compound) as products_text
                    from (
                      select distinct
                      pr.PATHWAY_REACTION_ID as reaction_id
                      , pr.SOURCE_ID as reaction_source_id
                      , (case (replace (replace (ed.name, 'Pathways_', ''), '_RSRC', ''))
                        when 'KEGG' then 'http://www.genome.jp/dbget-bin/www_bget?rn:' || pr.source_id
                        when 'MetaCyc' then 'http://metacyc.org/META/new-image?type=REACTION' || chr(38) || 'object=' || pr.source_id
                        when 'TrypanoCyc' then 'http://vm-trypanocyc.toulouse.inra.fr/TRYPANO/new-image?type=REACTION' || chr(38) || 'object=' || pr.source_id
                        when 'LeishCyc' then 'http://vm-trypanocyc.toulouse.inra.fr/LEISH/new-image?tyrp=REACTION' || chr(38) || 'object=' || pr.source_id
                        when 'FungiCyc' then null
                        end) as reaction_url
                      , ed.NAME as ext_db_name
                      , edr.VERSION as ext_db_version
                      , pn.DISPLAY_LABEL as enzyme
                      , listagg (pc.type, ',') within group (order by pc.pathway_id) as type_list
                      , max (prel.is_reversible) KEEP (DENSE_RANK LAST ORDER BY prel.is_reversible) over (partition by pr.pathway_reaction_id) as is_reversible
                      , nvl(pc.chebi_accession, pc.compound_source_id) as compound
                      , (case when nvl(pc.CHEBI_ACCESSION, pc.compound_source_id) like 'CHEBI%' then '<a href="/a/app/record/compound/' || nvl(pc.chebi_accession, pc.compound_source_id) || '">' || nvl(pc.chebi_accession, pc.compound_source_id) || '</a>' else nvl(pc.chebi_accession, pc.compound_source_id) end) as compound_url
                      , min(pc.type) KEEP (DENSE_RANK FIRST ORDER BY p.pathway_id) as type
                      from
                      sres.pathway p
                      , apidb.pathwayreaction pr
                      , APIDB.PATHWAYREACTIONREL prr
                      , SRES.PATHWAYNODE pn
                      , SRES.PATHWAYRELATIONSHIP prel
                      , SRES.EXTERNALDATABASE ed
                      , SRES.EXTERNALDATABASERELEASE edr
                      , SRES.ONTOLOGYTERM ot
                      , PathwayCompounds pc
                      where p.PATHWAY_ID = prr.PATHWAY_ID
                      and pr.PATHWAY_REACTION_ID = prr.PATHWAY_REACTION_ID
                      and prr.PATHWAY_RELATIONSHIP_ID = prel.PATHWAY_RELATIONSHIP_ID
                      and prel.NODE_ID = pn.PATHWAY_NODE_ID
                      and ot.name = 'enzyme'
                      and ot.ONTOLOGY_TERM_ID = pn.PATHWAY_NODE_TYPE_ID
                      and pc.EXT_DB_NAME = ed.NAME
                      and pc.EXT_DB_VERSION = edr.VERSION
                      and ed.EXTERNAL_DATABASE_ID = edr.EXTERNAL_DATABASE_ID
                      and pc.PATHWAY_ID = p.PATHWAY_ID
                      and pc.REACTION_id = pr.PATHWAY_REACTION_ID
                      group by pr.pathway_reaction_id, pr.SOURCE_ID, ed.NAME, edr.VERSION, pn.DISPLAY_LABEL, prel.IS_REVERSIBLE, nvl(pc.chebi_accession, pc.compound_source_id), pn.display_label
                      )
                    group by reaction_id, reaction_source_id, reaction_url, ext_db_name, ext_db_version, enzyme, is_reversible
                    )
                ) i
                LEFT OUTER JOIN sres.enzymeclass ec ON i.enzyme = ec.ec_number
            ) o
        ]]>
    </sql>
    <sql>
      <![CDATA[
        create index PathRcts_id_ix&1
        on PathwayReactions&1 (reaction_id, reaction_source_id, enzyme, expasy_url, ext_db_name)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="PathwayEdges">
    <comment>Edges for pathway maps</comment>
    <internalDependency name="PathwayAttributes"/>
    <internalDependency name="PathwayReactions"/>
    <sql>
      <![CDATA[
        CREATE TABLE PathwayEdges&1 NOLOGGING AS
        SELECT pa.source_id
        , pa.pathway_source
        , rel.*
        FROM (
          WITH
            nodes_with_types AS
            (SELECT pn.pathway_id
            , pn.pathway_node_id
            , ot.name AS type
            FROM sres.pathwaynode pn
            , sres.ontologyterm ot
            WHERE pn.pathway_node_type_id = ot.ontology_term_id
            )
            , reactions_with_reversibility AS
            (SELECT DISTINCT spr.pathway_relationship_id
            , max(tpr.is_reversible) as is_reversible
            FROM sres.pathwayrelationship spr
            , apidb.pathwayreactionrel prr
            , PathwayReactions tpr
            WHERE prr.pathway_relationship_id = spr.pathway_relationship_id
            AND tpr.reaction_id = prr.pathway_reaction_id
            group by spr.pathway_relationship_id
            )
            , enzyme_edges as
            (SELECT nodes_with_types.pathway_id AS pathway_id
            , nodes_with_types.pathway_node_id AS e_id
            , nodes_with_types.type
            , i.associated_node_id as m1_id
            , rri.is_reversible AS ir1
            , o.node_id AS m2_id
            , rro.is_reversible as ir2
            FROM sres.pathwayrelationship i
            , sres.pathwayrelationship o
            , nodes_with_types
            , reactions_with_reversibility rri
            , reactions_with_reversibility rro
            WHERE i.node_id = nodes_with_types.pathway_node_id
            AND o.associated_node_id = nodes_with_types.pathway_node_id
            AND i.pathway_relationship_id = rri.pathway_relationship_id
            AND o.pathway_relationship_id = rro.pathway_relationship_id
            AND nodes_with_types.type = 'enzyme'
            )
            , parents AS
            (SELECT m1_id || '_' || ir1 AS incoming
            , m2_id || '_' || ir2 AS outgoing
            , listagg(e_id, '_') WITHIN GROUP (ORDER BY e_id) AS parent
            , pathway_id
            FROM enzyme_edges
            GROUP BY pathway_id
            , m1_id
            , m2_id
            , ir1
            , ir2
            HAVING COUNT (*) > 1
            )
          SELECT DISTINCT enzyme_edges.pathway_id
          , parents.parent AS source
          , to_char(enzyme_edges.m1_id) AS target
          , enzyme_edges.ir1 AS is_reversible
          FROM enzyme_edges
          , parents
          WHERE m1_id || '_' || ir1 = parents.incoming
          UNION
          SELECT DISTINCT enzyme_edges.pathway_id
          , to_char(enzyme_edges.m2_id) AS source
          , parents.parent AS target
          , enzyme_edges.ir2 AS is_reversible
          FROM enzyme_edges
          , parents
          WHERE m2_id || '_' || ir2 = parents.outgoing
          UNION
          SELECT enzyme_edges.pathway_id
          , to_char(e_id) AS source
          , to_char(enzyme_edges.m1_id) AS target
          , enzyme_edges.ir1  AS is_reversible
          FROM enzyme_edges
          , parents
          WHERE m1_id || '_' || ir1 = parents.incoming (+)
          AND parents.outgoing IS NULL
          UNION
          SELECT enzyme_edges.pathway_id
          , to_char(enzyme_edges.m2_id) AS source
          , to_char(e_id) AS target
          , enzyme_edges.ir2 AS is_reversible
          FROM enzyme_edges
          , parents
          WHERE m2_id || '_' || ir2 = parents.outgoing (+)
          AND parents.incoming IS NULL
          UNION
          SELECT pn1.pathway_id
          , to_char(pr.node_id)
          , to_char(pr.associated_node_id)
          , pr.is_reversible
          FROM sres.pathwayrelationship pr
          , sres.pathwaynode pn1
          , sres.pathwaynode pn2
          , sres.ontologyterm ot1
          , sres.ontologyterm ot2
          WHERE pr.node_id = pn1.pathway_node_id
          AND pr.associated_node_id = pn2.pathway_node_id
          AND pn1.pathway_node_type_id = ot1.ontology_term_id
          AND pn2.pathway_node_type_id  = ot2.ontology_term_id
          AND ot1.name != 'enzyme'
          AND ot2.name != 'enzyme'
          ) rel
        , PathwayAttributes pa
        WHERE pa.pathway_id = rel.pathway_id
      ]]>
    </sql>
    <!-- TODO index -->
  </tuningTable>

  <tuningTable name="PathwayNodes">
    <comment>Nodes for pathway maps</comment>
    <internalDependency name="PathwayAttributes"/>
    <internalDependency name="PathwayNodeGene"/>
    <internalDependency name="CompoundId"/>
    <internalDependency name="PathwayReactions"/>
    <sql>
      <![CDATA[
        CREATE TABLE PathwayNodes&1 NOLOGGING AS
        WITH nodes_with_types AS
            (SELECT pn.pathway_id
            , pa.name AS display_label
            , pa.url
            , pa.name AS name
            , pa.source_id as node_identifier
            , to_char(pn.pathway_node_id) AS pathway_node_id
            , pn.x
            , pn.y
            , pn.width
            , pn.height
            , pn.cellular_location
            , ot.name AS type
            , NULL AS gene_count
            , NULL AS default_structure
            FROM sres.pathwaynode pn
            , sres.ontologyterm ot
            , PathwayAttributes pa
            WHERE pn.pathway_node_type_id = ot.ontology_term_id
            AND pn.display_label = pa.source_id
            AND ot.name = 'metabolic process'
            UNION ALL
            SELECT pn.pathway_id
            , pn.display_label
            , NULL as url
            , nvl(ec.description, pn.display_label) AS name
            , ec.ec_number AS node_identifier
            , to_char(pn.pathway_node_id) AS pathway_node_id
            , pn.x
            , pn.y
            , pn.width
            , pn.height
            , pn.cellular_location
            , ot.name AS type
            , count(tp.gene_source_id) AS gene_count
            , NULL AS default_structure
            FROM sres.pathwaynode pn
            , sres.ontologyterm ot
            , sres.enzymeclass ec
            , PathwayNodeGene tp
            WHERE pn.pathway_node_type_id = ot.ontology_term_id
            AND ot.name = 'enzyme'
            AND pn.row_id = ec.enzyme_class_id (+)
            AND pn.pathway_node_id = tp.pathway_node_id (+)
            GROUP BY pn.pathway_id
            , pn.display_label
            , ec.description
            , ec.ec_number
            , to_char(pn.pathway_node_id)
            , pn.x
            , pn.y
            , pn.width
            , pn.height
            , pn.cellular_location
            , ot.name
            UNION ALL
            SELECT pn.pathway_id
            , pn.display_label
            , NULL AS url
            , nvl(c.name, pn.display_label) AS name
            , c.chebi_accession AS node_identifier  
            , to_char(pn.pathway_node_id) AS pathway_node_id
            , pn.x
            , pn.y
            , pn.width
            , pn.height
            , pn.cellular_location
            , ot.name AS type
            , NULL AS gene_count
            , st.default_structure
            FROM sres.pathwaynode pn
            , sres.ontologyterm ot
            , chebi.compounds c
            , (SELECT n.compound
                , s.structure AS default_structure
                FROM chebi.structures s
                , chebi.default_structures ds
                , (SELECT id
                    , compound
                    FROM CompoundId
                    WHERE type IN ('same ID', 'child ID')
                    ) n
                WHERE n.id = 'CHEBI:' || s.compound_id
                AND s.id = ds.structure_id
                AND s.type = 'mol'
                AND s.dimension = '2D'
            ) st
            WHERE pn.pathway_node_type_id = ot.ontology_term_id
            AND ot.name = 'molecular entity'
            AND pn.row_id = c.id (+)
            AND c.chebi_accession = st.compound (+)
            )
        , reactions_with_reversibility AS
            (SELECT DISTINCT spr.pathway_relationship_id
            , tpr.is_reversible
            FROM sres.pathwayrelationship spr
            , apidb.pathwayreactionrel prr
            , PathwayReactions tpr
            WHERE prr.pathway_relationship_id = spr.pathway_relationship_id
            AND tpr.reaction_id = prr.pathway_reaction_id
        )
        , enzyme_edges AS
            (SELECT nodes_with_types.pathway_id AS pathway_id
            , nodes_with_types.pathway_node_id AS e_id
            , nodes_with_types.type
            , i.associated_node_id AS m1_id
            , rri.is_reversible as ir1
            , o.node_id AS m2_id
            , rro.is_reversible AS ir2
            FROM sres.pathwayrelationship i
            , sres.pathwayrelationship o
            , nodes_with_types
            , reactions_with_reversibility rri
            , reactions_with_reversibility rro
            WHERE i.node_id = nodes_with_types.pathway_node_id
            AND o.associated_node_id = nodes_with_types.pathway_node_id
            AND i.pathway_relationship_id = rri.pathway_relationship_id
            AND o.pathway_relationship_id = rro.pathway_relationship_id
            AND nodes_with_types.type = 'enzyme'
        )
        , parents AS
            (SELECT m1_id || '_' || m2_id || '_' || ir1 || '_' || ir2 as io
            , listagg(e_id, '_') WITHIN GROUP (ORDER BY e_id) AS parent
            , pathway_id
            FROM enzyme_edges
            GROUP BY pathway_id
            , m1_id
            , m2_id
            , ir1
            , ir2
            HAVING COUNT (*) > 1
        )
        , node_parents AS
            (SELECT e_id as pathway_node_id
            , parents.parent
            , type as node_type
            , enzyme_edges.pathway_id
            FROM enzyme_edges
            , parents
            WHERE m1_id || '_' || m2_id || '_' || ir1 || '_' || ir2 = parents.io
        )
        , enzyme_reactions AS
            (SELECT DISTINCT pn.PATHWAY_NODE_ID node_id
            , pr.SOURCE_ID AS reaction_source_id
            FROM sres.pathwaynode pn
            , apidb.pathwayreaction pr
            , APIDB.PATHWAYREACTIONREL prr
            , SRES.PATHWAYRELATIONSHIP prel
            , sres.ontologyterm ot
            WHERE (prel.NODE_ID = pn.PATHWAY_NODE_ID OR prel.ASSOCIATED_NODE_ID = pn.PATHWAY_NODE_ID)
            AND prr.PATHWAY_RELATIONSHIP_ID = prel.PATHWAY_RELATIONSHIP_ID
            AND pr.PATHWAY_REACTION_ID = prr.PATHWAY_REACTION_ID
            AND ot.name = 'enzyme'
            AND pn.PATHWAY_NODE_TYPE_ID = ot.ONTOLOGY_TERM_ID
        )
        SELECT pa.source_id
        , pa.pathway_source
        , pn.display_label
        , pn.x
        , pn.y
        , pn.width
        , pn.height
        , pn.cellular_location
        , pn.url
        , pn.name
        , pn.node_identifier
        , nodes_with_parents.pathway_node_id AS id
        , nodes_with_parents.parent
        , reaction_source_id
        , type AS node_type
        --, NULL AS image
        , pn.gene_count
        , pn.default_structure
        FROM
            (SELECT e_id AS pathway_node_id
            , node_parents.parent
            , type AS node_type
            , enzyme_edges.pathway_id
            , enzyme_reactions.reaction_source_id
            FROM enzyme_edges
            , node_parents
            , enzyme_reactions
            WHERE enzyme_edges.e_id = node_parents.pathway_node_id (+)
            AND enzyme_reactions.node_id = enzyme_edges.e_id
            UNION
            SELECT parents.parent
            , NULL 
            , 'nodeOfNodes'
            , pathway_id
            , NULL
            FROM parents
            UNION
            SELECT nodes_with_types.pathway_node_id AS pathway_node_id
            , NULL AS parent
            , nodes_with_types.type
            , nodes_with_types.pathway_id
            , NULL
            FROM nodes_with_types
            WHERE nodes_with_types.type != 'enzyme'
            ) nodes_with_parents
        , nodes_with_types pn
        , PathwayAttributes pa
        WHERE nodes_with_parents.pathway_node_id = pn.pathway_node_id (+)
        AND nodes_with_parents.pathway_id = pa.pathway_id
      ]]>
    </sql>
    <!--TODO index -->
  </tuningTable>
            
          
            


  <tuningTable name="CompoundTypeAheads">
    <comment> for use in GenesByReactionCompounds question </comment>
    <internalDependency name="CompoundAttributes"/>
    <internalDependency name="PathwayCompounds"/>
    <sql>
      <![CDATA[
        CREATE TABLE CompoundTypeAheads&1 NOLOGGING AS
        SELECT ca.source_id AS compound_id,
              TO_CHAR(ca.source_id)  || ' (' || ca.compound_name || ')' AS display
        FROM  CompoundAttributes ca, PathwayCompounds pc
        WHERE  pc.chebi_accession = ca.source_id
        UNION
        SELECT ca.source_id AS compound_id,
              pc.compound_source_id || ' (' || ca.compound_name || ')' AS display
        FROM  CompoundAttributes ca, PathwayCompounds pc
        WHERE  pc.chebi_accession = ca.source_id
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="MSPeptideSummary">
    <comment> Each row stores mass-spec. based expression evidence for one sample of
         one experiment for one gene. Used for mass spec queries in the model,
         GBrowse, and PBrowse, and also in the creation of the MSTranscriptSummary
         tuning table.
      </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="SampleDisplayInfo"/>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="dots.AaFeature"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <intermediateTable name="MSExptTrustedSpectrum"/>
    <sql>
      <![CDATA[
create table MSExptTrustedSpectrum nologging as        
select distinct mss.external_database_release_id, mss.protocol_app_node_id, pan.name
from apidb.massspecsummary mss, dots.massspecfeature msf, study.protocolappnode pan
where mss.mass_spec_summary_id = msf.source_id
and mss.PROTOCOL_APP_NODE_ID = pan.protocol_app_node_id

      ]]>
    </sql>
    <sql>
      <![CDATA[
create table MSPeptideSummary&1 nologging as
select  pep.*, sdi.sample_display_name, sdi.HTML_COLOR, sdi.SORT_ORDER
from (select dbms_lob.SUBSTR(seq.SEQUENCE,
pep.aa_end_max - pep.aa_start_min + 1,
                            pep.aa_start_min) as peptide_sequence,
       pep.*
from dots.aasequence seq, (
select ga.source_id, 
       ga.gene_source_id,
       mss.protocol_app_node_id, 
       dsp.display_name as experiment,
       d.name as external_database_name,
       sum(msf.spectrum_count) as spectrum_count,
       mss.aa_sequence_id,
       l.start_min as aa_start_min,
       l.end_max as aa_end_max,
       good.name as sample
from apidb.massspecsummary mss, dots.massspecfeature msf, dots.aalocation l, 
     transcriptattributes ga, Msexpttrustedspectrum good, sres.externaldatabase d,
     sres.externaldatabaserelease r,  datasetnametaxon dsnt, datasetpresenter dsp
where mss.mass_spec_summary_id = msf.source_id
and msf.aa_feature_id = l.aa_feature_id
and mss.aa_sequence_id = ga.aa_sequence_id (+)
and mss.external_database_release_id = r.external_database_release_id
and r.external_database_id = d.external_database_id
and d.name = dsnt.name (+)
and dsnt.dataset_presenter_id = dsp.dataset_presenter_id (+)
and mss.external_database_release_id = good.external_database_release_id (+)
and mss.protocol_app_node_id = good.protocol_app_node_id (+)
group by d.name, ga.source_id, ga.gene_source_id, mss.protocol_app_node_id, dsp.display_name, 
         mss.aa_sequence_id, mss.spectrum_count, l.start_min, l.end_max, good.external_database_release_id, good.name
) pep
where pep.aa_sequence_id = seq.aa_sequence_id) pep,
sampledisplayinfo sdi
where sdi.dataset_name = pep.external_database_name
and sdi.sample = replace (pep.sample ,' (MS Summary)', '') 
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index sample_ix&1 on  MSPeptideSummary&1 (sample)
      tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="AnnotatedGenomeSummary">
    <comment> Stores summary information from annotated genomes to facilitate overview section of gene page
      </comment>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
create table AnnotatedGenomeSummary&1 nologging as
select dsp.name as external_db_name, ga.organism,ga.taxon_id,o.is_reference_strain,
(select value from datasetproperty 
where dataset_presenter_id = dsp.dataset_presenter_id 
and property = 'isCurated') as is_curated_genome,
(select value from datasetproperty 
where dataset_presenter_id = dsp.dataset_presenter_id 
and property = 'updatedAnnotationText') as updated_link_text,
(select value from datasetproperty 
where dataset_presenter_id = dsp.dataset_presenter_id 
and property = 'specialLinkDisplayText') as special_link_text,
(select rel.id_url from datasetproperty p,  sres.externaldatabase db, sres.externaldatabaserelease rel
where p.dataset_presenter_id = dsp.dataset_presenter_id
and db.name = p.value
and db.external_database_id = rel.external_database_id
and p.property = 'specialLinkExternalDbName') as link_url,
dsp.release_policy
from datasetpresenter dsp, apidb.organism o,
(select distinct external_db_name,taxon_id,organism from geneattributes) ga
where dsp.name like '%_primary_genome_RSRC'
and dsp.name = ga.external_db_name
and o.taxon_id = ga.taxon_id
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="MSTranscriptSummary">
    <comment> Mass-spec experiment results for a transcript. Used in the model for queries
         related to transcripts.
      </comment>
    <internalDependency name="MSPeptideSummary"/>
    <sql>
      <![CDATA[
create table MSTranscriptSummary&1 nologging as
select msps.source_id, msps.gene_source_id, msps.external_database_name, msps.experiment, msps.sample, msps.sample_display_name, protocol_app_node_id, sum(msps.spectrum_count) as spectrum_count, count(*) as sequence_count
from mspeptidesummary msps
where source_id is not null
group by msps.source_id, msps.gene_source_id, msps.external_database_name, msps.experiment, msps.sample, msps.sample_display_name, protocol_app_node_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index msgs_ix&1 on MSTranscriptSummary&1 (source_id, gene_source_id)
      tablespace indx
      ]]>
    </sql>
  </tuningTable>



  <tuningTable name="MSModifiedPeptideSummary">
    <comment> Mass-spec experiment results for a peptide. Used by the model, GBrowse,
         and PBrowse.
      </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="SampleDisplayInfo"/>
    <internalDependency name="DatasetPresenter"/> 
    <externalDependency name="dots.AaFeature"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <sql>
      <![CDATA[
create table MSModifiedPeptideSummary&1 nologging as
select dbms_lob.substr(seq.sequence, pep.aa_end_max - pep.aa_start_min + 1,
              pep.aa_start_min)                                   as
       peptide_sequence,
       dbms_lob.substr(seq.sequence, 1, pep.residue_location + 1) as residue,
       pep.*
from   dots.aasequence seq,
       (select ga.source_id                     as source_id,
               ga.gene_source_id                as gene_source_id,
               so.name                     as modification_type,
               nvl(dsp.display_name, sample)    as experiment,
               ed.name                          as external_database_name,
               mss.external_database_release_id as external_database_release_id,
               mst.sample_display_name          as Sample_display,
               mst.sample                       as sample,
               mss.aa_sequence_id               as aa_sequence_id,
               msf.aa_feature_id                as peptide_aa_feature_id,
               msf.spectrum_count               as spectrum_count,
               mst.html_color                   as html_color,
               aal.start_min                    as residue_location,
               aalp.start_min                   as aa_start_min,
               aalp.end_max                     as aa_end_max,
               pot.description                  as description
        from   dots.posttranslationalmodfeature pot,
               dots.massspecfeature msf,
               apidb.massspecsummary mss,
               dots.aalocation aal,
               dots.aalocation aalp,
               sampledisplayinfo mst,
               sres.ontologyterm so,
               transcriptattributes ga,
               sres.externaldatabase ed,
               sres.externaldatabaserelease edr,
               datasetnametaxon dsnt,
               datasetpresenter dsp, 
               study.protocolappnode pan
        where  pot.parent_id = msf.aa_feature_id
           and pot.aa_feature_id = aal.aa_feature_id
           and msf.aa_feature_id = aalp.aa_feature_id
           and msf.source_id = mss.mass_spec_summary_id
           and mss.aa_sequence_id = ga.aa_sequence_id
           and mss.external_database_release_id =
               edr.external_database_release_id
           and ed.name = dsnt.name (+)
           and dsnt.dataset_presenter_id = dsp.dataset_presenter_id (+)
           and mss.protocol_app_node_id = pan.protocol_app_node_id
           and ed.name = mst.dataset_name
           and mst.sample = replace (pan.name ,' (MS Summary)', '')
           and edr.external_database_id = ed.external_database_id
           and pot.sequence_ontology_id = so.ontology_term_id) pep
where  pep.aa_sequence_id = seq.aa_sequence_id 
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index msmodps_tx_ix&1 on MSModifiedPeptideSummary&1 (source_id, gene_source_id)
      tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index msmodps_gn_ix&1 on MSModifiedPeptideSummary&1 (gene_source_id, source_id)
      tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Ssgcid" alwaysUpdate="true">
    <comment> Data from the Seattle Structural Genomics Center for Infectious Disease,
         populated from their web service. Used in the gene record.
      </comment>
    <program commandLine="buildSsgcidTT"/>
  </tuningTable>


  <tuningTable name="SampleDisplayInfo" alwaysUpdate="true">
    <comment> Used by the model and GBrowse, as well as an input in the creation of
         the tuning tables like MSModifiedPeptideSummary and MSPeptideSummary.
      </comment>
    <program commandLine="buildSampleDisplayInfoTT"/>
  </tuningTable>


  <tuningTable name="SampleAttributes" alwaysUpdate="true">
    <comment>lots of columns for sample meta data. used for sample record
      </comment>
    <program commandLine="buildSampleAttributesTT"/>
  </tuningTable>


  <tuningTable name="ProfileSetDisplayInfo" alwaysUpdate="true">
    <comment> Used by the model when writing profile data
      </comment>
    <program commandLine="buildProfileSetDisplayInfoTT"/>
  </tuningTable>




  <tuningTable name="GbrowseTracksOrganism" alwaysUpdate="true">
    <comment> Associates an organism with the GBrowse and PBrowse tracks available
         for it. Used by the gene record.
      </comment>
    <internalDependency name="GeneAttributes"/>
    <externalDependency name="apidb.Organism"/>
    <program commandLine="buildGbrowseImageUrlTT"/>
  </tuningTable>


  <tuningTable name="SpliceSiteTranscripts">
    <comment> Associates an organism with the GBrowse and PBrowse tracks available
         for it. Used by the gene record.
      </comment>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="apidb.splicesitegenes"/>
    <externalDependency name="apidb.polyagenes"/>
    <program commandLine="buildSpliceSitesTT"/>
  </tuningTable>


  <tuningTable name="DatasetPresenter" alwaysUpdate="true">
    <comment> Data for a dataset. Used widely in the model, and by GBrowse.</comment>
    <internalDependency name="GenomicSeqAttributes"/>
    <ancillaryTable name="DatasetContact"/>
    <ancillaryTable name="DatasetProperty"/>
    <ancillaryTable name="DatasetHyperLink"/>
    <ancillaryTable name="DatasetPublication"/>
    <ancillaryTable name="DatasetModelRef"/>
    <ancillaryTable name="DatasetNameTaxon"/>
    <ancillaryTable name="DatasetHistory"/>
    <program commandLine="buildDatasetPresentersTT"/>
  </tuningTable>


  <tuningTable name="DatasetHyperLinks" alwaysUpdate="true">
    <comment> Each row maps a dataset onto an ID for which the dataset contains data;
         each dataset gets one such row.
         Used in dataset record queries.
      </comment>
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <internalDependency name="DatasetExampleSourceId"/>
    <internalDependency name="DatasetPresenter"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="OrganismAttributes"/>

    <sql>
      <![CDATA[
CREATE TABLE DatasetHyperLinks&1 NOLOGGING AS
with sequences as (
select sa.source_id, 
       sa.taxon_id,
       sa.project_id,
       row_number() over(partition by sa.taxon_id
                         order by sa.chromosome_order_num, sa.length desc) as rn
from GenomicSeqAttributes sa
where sa.is_top_level = 1),
proteomicsgenes as (
select ga.gene_source_id as source_id, 
       d.name, 
       ga.project_id,
       row_number() over(partition by d.name
                         order by mss.aa_seq_percent_covered desc) as rn
from apidb.MassSpecSummary mss, TranscriptAttributes ga,
     sres.ExternalDatabase d, sres.ExternalDatabaseRelease r
where mss.external_database_release_id = r.external_database_release_id
and r.external_database_id = d.external_database_id
and mss.aa_sequence_id = ga.aa_sequence_id
)
-- MAIN QUERY STARTS HERE
 -- first query handles genomes... replace needed macros
select dsp.dataset_presenter_id as dataset_id, dsp.name as dataset_name, 
       nvl(hl.text, hl.url) as text,
       hl.description,
       replace(replace(replace(replace(hl.url, 'DEFAULT_PROJECT', def_seq.project_id), 'DEFAULT_LC_PROJECT', lower(def_seq.project_id)), 'DEFAULT_SEQUENCE', def_seq.source_id), 'ORGANISM_PK', def_seq.organismpk) as url
from (select dsp.dataset_presenter_id, os.source_id, oa.source_id as organismpk, os.project_id
      from DatasetPresenter dsp, DatasetNameTaxon nt, OrganismAttributes oa, sequences os
      where dsp.dataset_presenter_id = nt.dataset_presenter_id
      and nt.taxon_id = os.taxon_id
      and nt.taxon_id = oa.component_taxon_id
      and os.rn = 1 
      ) def_seq,
      DatasetPresenter dsp, DatasetHyperLink hl
where dsp.dataset_presenter_id = def_seq.dataset_presenter_id (+)
and dsp.dataset_presenter_id = hl.dataset_presenter_id (+)
and dsp.type = 'genome'
and hl.url is not null
UNION
 -- this query handles proteomics... replace needed macros
select dsp.dataset_presenter_id as dataset_id, dsp.name as dataset_name, 
       nvl(hl.text, hl.url) as text,
       hl.description,
       replace(replace(replace(replace(hl.url, 'DEFAULT_LC_PROJECT', lower(def_prot.project_id)), 'DEFAULT_PROTEOMICS_GENE', def_prot.source_id),'DEFAULT_DATASET', dsp.name), 'DEFAULT_PROJECT', def_prot.project_id) as url
from (select dsp.dataset_presenter_id, pg.source_id, pg.project_id
      from DatasetPresenter dsp, DatasetNameTaxon dsnt, proteomicsgenes pg
      where pg.name = dsnt.name
      and pg.rn = 1
      and dsnt.dataset_presenter_id = dsp.dataset_presenter_id
      ) def_prot,
      DatasetPresenter dsp, DatasetHyperLink hl
where dsp.dataset_presenter_id = def_prot.dataset_presenter_id (+)
and dsp.dataset_presenter_id = hl.dataset_presenter_id (+)
and dsp.type = 'protein_expression'
and dsp.subtype is null
and hl.url is not null
and ((hl.url like '%DEFAULT_PROTEOMICS_GENE%' and def_prot.source_id is not null)
     or (hl.url not like '%DEFAULT_PROTEOMICS_GENE%'))
UNION
-- Get the RNASeq Ones
select dsp.dataset_presenter_id as dataset_id, dsp.name as dataset_name, 
       nvl(hl.text, hl.url) as text,
       hl.description,
       replace(replace(replace(replace(hl.url, 'DEFAULT_LC_PROJECT', lower(esi.project_id)), 'DEFAULT_RNASEQ_GENE', esi.example_source_id),'DEFAULT_DATASET', dsp.name), 'DEFAULT_PROJECT', esi.project_id) as url
from DatasetExampleSourceId esi,
      DatasetPresenter dsp, DatasetHyperLink hl,
      DatasetNameTaxon dnt
where dsp.dataset_presenter_id = hl.dataset_presenter_id (+)
and dsp.dataset_presenter_id = dnt.dataset_presenter_id (+)
and esi.dataset = dnt.name
and dsp.type = 'transcript_expression'
and dsp.subtype = 'rnaseq'
and hl.url is not null
and ((hl.url like '%DEFAULT_RNASEQ_GENE%' and esi.example_source_id is not null)
     or (hl.url not like '%DEFAULT_RNASEQ_GENE%'))
UNION
 -- Get the remaining ones
select dataset_id, dataset_name, text, description, url 
from (select dsp.dataset_presenter_id as dataset_id, dsp.name as dataset_name, nvl(ln.text, ln.url) as text, ln.url, ln.description
      from DatasetHyperLink ln, DatasetPresenter dsp
      where dsp.dataset_presenter_id = ln.dataset_presenter_id
      minus
      select dsp.dataset_presenter_id as dataset_id, dsp.name as dataset_name, nvl(ln.text, ln.url) as text, ln.url, ln.description
      from DatasetHyperLink ln, DatasetPresenter dsp
      where dsp.dataset_presenter_id = ln.dataset_presenter_id
      and ((dsp.type = 'genome')
        OR (dsp.type = 'protein_expression' and subtype is null)
        OR (dsp.type = 'transcript_expression' and subtype = 'rnaseq')
        )
      )
where url is not null
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EupathBuildDates" alwaysUpdate="true">

    <program commandLine="buildEupathBuildDatesTT"/>
  </tuningTable>


  <tuningTable name="DatasetDetail" alwaysUpdate="true">
    <comment> Stores text associated with each dataset. Used by dataset queries.
      </comment>
    <internalDependency name="DatasetPresenter"/>
    <sql>
      <![CDATA[
      create table DatasetDetail&1 nologging
      as
            select dataset_presenter_id, 
      name||' '||category||' '||usage||' '|| 
      caveat||' '||acknowledgement||' '||type||' '||subtype
      ||' '| |summary||' '||description||' '||contact||' '||
      institution||' '||pubmed_id||' '||citation as search_string
      from (
      select
      sub.dataset_presenter_id as dataset_presenter_id, 
      sub.name as name, 
      sub.category as category,
      sub.usage as usage, 
      sub.caveat as caveat,
      sub.acknowledgement as acknowledgement, 
      sub.type as type, 
      sub.subtype as subtype,
      sub.contact,
      sub.institution,
      sub.pubmed_id,
      sub.citation,
      dp.summary,
      dp.description
      from DatasetPresenter dp,
      (
      select distinct
      dp.dataset_presenter_id as dataset_presenter_id, 
      dp.display_name as name, 
      dp.display_category as category,
      dp.usage as usage, 
      dp.caveat as caveat,
      dp.acknowledgement as acknowledgement, 
      dp.type as type, 
      dp.subtype as subtype, 
      dc.name as contact,
      dc.affiliation as institution,
      LISTAGG(dpub.pmid, ' ') WITHIN GROUP (ORDER BY dpub.pmid) as pubmed_id,
      LISTAGG(dpub.citation, '  ') WITHIN GROUP (ORDER BY dpub.citation) as citation
      from DatasetPresenter dp, DatasetContact dc, 
           DatasetPublication dpub  
      where dp.dataset_presenter_id = dc.dataset_presenter_id
      and   dp.dataset_presenter_id = dpub.dataset_presenter_id
      and   dc.is_primary_contact = 1
      group by dp.dataset_presenter_id, dp.display_name,dp.display_category,
               dp.usage,dp.caveat,dp.acknowledgement,dp.type,dp.subtype,dc.name,
               dc.affiliation
      ) sub
      
      where dp.dataset_presenter_id = sub.dataset_presenter_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
          CREATE INDEX DATASET_DETAIL_IDX&1 ON DATASETDETAIL&1 (search_string)
          INDEXTYPE IS CTXSYS.CONTEXT
      ]]>
    </sql>

  </tuningTable>

<!--


  <tuningTable name="TrackOldAnnotation" alwaysUpdate="true">
    <comment> Stores changes in gene annotation. Used by the model for gene ID and
         table queries.
      </comment>
    <program commandLine="buildTrackOldAnnotationTT"/>
  </tuningTable>
-->

  <tuningTable name="ProteomicsCitation">
    <comment> Citation info for proteomics datasets, used by GBrowse </comment>
    <internalDependency name="DatasetPresenter"/>
    <internalDependency name="MSPeptideSummary"/>
    <sql>
      <![CDATA[
      create table ProteomicsCitation&1 nologging as
      with pubs
           as (select name, id, contact_email,
                      listagg(publication, ',') WITHIN GROUP (order by publication) as pmids
               from (select ds.name as name, ds.dataset_presenter_id as id,
                                    c.email as contact_email, p.pmid as publication
                     from DatasetPresenter ds, DatasetContact c,
                          DatasetPublication p
                     where ds.dataset_presenter_id = c.dataset_presenter_id
                       and ds.dataset_presenter_id = p.dataset_presenter_id
                       and c.is_primary_contact = 1
                       and ds.type = 'protein_expression'
                       and ds.subtype is null)
               group by name, id, contact_email),
           samples
           as (select name, id,
                      listagg(sample_i, chr(10)) WITHIN GROUP (order by sample) as sample_table
               from (select distinct ds.name as name,
                                     ds.dataset_presenter_id as id, sample,
                                     '<p style="color:' || html_color || '">' || sample || '</p>' as sample_i
                     from MSPeptideSummary mps, DatasetPresenter ds
                     -- consider using ApiDBTuing.ExternalDbDatasetPresenter instead of the LIKE below, if its performance is a problem
                     where (ds.name = mps.external_database_name or mps.external_database_name like ds.dataset_name_pattern))
               group by name, id)
      select name,
             dbms_lob.substr(description, 4000, 1) || ' Primary Contact Email: '|| nvl(email, 'unavailable')
             || ' PMID: ' || publications || '<p style="color:black">Samples:</p>'
             || sample_table || chr(10) ||
             ' Please note that subtrack labels will disappear if the selected subtracks number is over 15!' as citation
      from (select ds.name as name, ds.summary as description, pubs.contact_email as email,
                   pubs.pmids as publications, samples.sample_table as sample_table
            from DatasetPresenter ds, pubs, samples
            where ds.dataset_presenter_id = pubs.id
              and ds.dataset_presenter_id = samples.id)
      ]]>
    </sql>
  </tuningTable>



  <tuningTable name="EqtlSpan">
    <externalDependency name="dots.ChromosomeElementFeature"/>
    <externalDependency name="apidb.NaFeatureHaploblock"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="dots.NaLocation"/>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
        create table eqtlSpan&1 nologging as
        select gene_source_id, project_id, haplotype_block_name as hapblock_id, sequence_id,
               start_min, end_max, start_max, end_min,
               max(score) as lod_score, organism
        from (select ga.gene_source_id, ga.project_id, gls.haplotype_block_name,
                     ens.source_id as sequence_id, nl.start_min, nl.end_max, nl.start_max, nl.end_min,
                     to_binary_double(gls.lod_score_mant|| 'e' || gls.lod_score_exp) as score,
                     replace (ga.organism, ' ', '+') as organism
              from dots.ChromosomeElementFeature cef, apidb.NAFeatureHaploblock gls,
                   dots.ExternalNaSequence ens, dots.NaLocation nl, TranscriptAttributes ga
              where gls.na_feature_id = ga.gene_na_feature_id
                and cef.name = gls.haplotype_block_name
                and nl.na_feature_id = cef.na_feature_id
                and cef.na_sequence_id = ens.na_sequence_id
                and to_binary_double(gls.lod_score_mant || 'e' || gls.lod_score_exp) >= 1.5)
        group by gene_source_id, project_id, sequence_id, haplotype_block_name,
                 start_min, end_max, start_max, end_min, organism
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index eqtlSpan_ix&1
        on eqtlSpan&1 (gene_source_id, project_id, hapblock_id, sequence_id, start_min, end_max, start_max, end_min, organism, lod_score)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="Pubmed" alwaysUpdate="true">
    <!-- PubMed info
      -->
    <internalDependency name="ExternalDbDatasetPresenter"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <program commandLine="buildPubmedTT"/>
  </tuningTable>

  <tuningTable name="GenePubmed">
    <!-- PubMed records mapped to genes
      -->
    <internalDependency name="DatasetPresenter"/>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="Pubmed"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
        create table GenePubmed&1 nologging as
        select distinct ta.gene_source_id, ta.source_id, ta.project_id, pm.pubmed_id, pm.doi, pm.title, pm.authors
        from sres.ExternalDatabaseRelease edr, sres.DbRef db, TranscriptAttributes ta,
             dots.DbRefNaFeature dbna, sres.ExternalDatabase ed,
             DatasetPresenter dsa, Pubmed pm
        where edr.external_database_release_id = db.external_database_release_id
          and ed.external_database_id = edr.external_database_id
	  -- consider using ApiDBTuing.ExternalDbDatasetPresenter instead of the LIKE below, if its performance is a problem
          and (ed.name = dsa.name or ed.name like (dsa.dataset_name_pattern))
          and dbna.db_ref_id = db.db_ref_id
          and (ta.na_feature_id= dbna.na_feature_id or ta.gene_na_feature_id = dbna.na_feature_id)
          and lower(dsa.display_name) like '%pubmed%'
          and db.primary_identifier = to_char(pm.pubmed_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gpm_gene_ix&1
          on GenePubmed&1 (gene_source_id, source_id, project_id, pubmed_id, doi, title, authors)
        tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gpm_tx_ix&1
          on GenePubmed&1 (source_id, gene_source_id, project_id, pubmed_id, doi, title, authors)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Profile">
    <!-- One profile for one gene. Used for graphs
      -->
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="CompoundAttributes"/>
    <internalDependency name="ProtocolAppNodeResults"/>
    <externalDependency name="apidb.OntologyTermResult"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="results.NaFeatureDiffResult"/>
    <externalDependency name="results.CompoundMassSpec"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <sql>
      <![CDATA[
      create table Profile&1 nologging as
      SELECT
        ds.name AS dataset_name
      , ds.type AS dataset_type
      , ds.subtype AS dataset_subtype
      , profile.profile_type
      , profile.source_id
      , profile.study_id AS profile_study_id
      , ps.name AS profile_set_name
      , case when regexp_replace(ps.name, '\[.+\]', '') like '% - %' 
                  then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), '.+ - ', '')
                  -- Special Cases for legacy datasets
                  when regexp_replace(ps.name, '\[.+\]', '') like 'DeRisi%' 
                  then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'DeRisi ', '')
                  when regexp_replace(ps.name, '\[.+\]', '') like 'winzeler_cc_%' 
                  then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'winzeler_cc_', '')
                  when regexp_replace(ps.name, '\[.+\]', '') like 'Llinas RT transcription and decay %' 
                  then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), 'Llinas RT transcription and decay ', '')
                  when regexp_replace(ps.name, '\[.+\]', '') like '%Horn aligned with cds coordinates%' 
                  then 'cds coordinates'
                  else null
                  end as profile_set_suffix
      , profile.profile_as_string
      , profile.max_value
      , profile.min_value
      , profile.max_timepoint
      , profile.min_timepoint
      FROM
        apidb.DataSource ds
      , sres.ExternalDatabase d
      , sres.ExternalDatabaseRelease r
      , study.study i
      , study.study ps
      ,(SELECT
          res.source_id
        , res.profile_type
        , sl.study_id
        , res.id
        , listagg(NVL(TO_CHAR(ROUND(res.value, 2)), 'NA'), CHR(9)) within GROUP(ORDER BY pan.node_order_num) AS profile_as_string
        , MAX(res.value) AS max_value
        , min(value) as min_value
        , max(pan.name) keep(dense_rank last order by value) as max_timepoint
        , MAX(pan.name) keep(dense_rank FIRST ORDER BY value) AS min_timepoint
        FROM
          study.StudyLink sl
        , (select distinct sl.study_id
           from study.studylink sl, protocolappnoderesults panr
           where sl.protocol_app_node_id = panr.protocol_app_node_id
           and panr.result_table = 'Results::NAFeatureDiffResult') dr
        , study.ProtocolAppNode pan
        ,(SELECT
            gene_profiles.*
          , ga.source_id
          FROM
            (SELECT
              'values' AS profile_type
            , MAX(value) AS value
            , na_feature_id AS id
            , protocol_app_node_id
            FROM
              results.NaFeatureHostResponse
            GROUP BY
              na_feature_id
            , protocol_app_node_id
            UNION
            SELECT
              'values' AS profile_type
            , mean_phenotype
            , na_feature_id AS id
            , protocol_app_node_id
            FROM
              apidb.crisprphenotype
            UNION
            SELECT
              'values' AS profile_type
            , value
            , na_feature_id AS id
            , protocol_app_node_id
            FROM
              results.NaFeatureExpression
            UNION
            SELECT
              'channel1_percentiles' AS profile_type
            , percentile_channel1 AS value
            , na_feature_id AS id
            , protocol_app_node_id
            FROM
              results.NaFeatureExpression
            UNION
            SELECT
              'channel2_percentiles' AS profile_type
            , percentile_channel2 AS value
            , na_feature_id AS id
            , protocol_app_node_id
            FROM
              results.NaFeatureExpression
            UNION
            SELECT
              'standard_error' AS profile_type
            , standard_error AS value
            , na_feature_id AS id
            , protocol_app_node_id
            FROM
              results.NaFeatureExpression
--            UNION
--          SELECT
--            'value' AS profile_type
--          , value AS value
--          , na_feature_id AS id
--          , protocol_app_node_id
--          FROM
--            apidb.HaplotypeResult
            ) gene_profiles
          , GeneAttributes ga
          WHERE
            gene_profiles.id = ga.na_feature_id
           UNION
            SELECT
              'value' AS profile_type
            , otr.value AS value
            , otr.ontology_term_id AS id
            , otr.protocol_app_node_id
            , ot.name as source_id
            FROM
              apidb.OntologyTermResult otr, sres.ontologyterm ot
            WHERE ot.ontology_term_id = otr.ontology_term_id
          UNION
          SELECT
            compound_profiles.profile_type
          , compound_profiles.value
          , compound_profiles.id
          , compound_profiles.protocol_app_node_id
          , CASE WHEN compound_profiles.isotopomer is null
                        THEN ca.source_id
                        ELSE ca.source_id || '|' || compound_profiles.isotopomer 
            END as source_id
          FROM
            (SELECT
              'values' AS profile_type
            , MAX(value) AS value
            , compound_id AS id
            , protocol_app_node_id
            , isotopomer
            FROM
              results.compoundmassspec
            GROUP BY
              compound_id
            , protocol_app_node_id
           , isotopomer
            ) compound_profiles
          , CompoundAttributes ca
          WHERE
            ca.id = compound_profiles.id
          ) res
        WHERE
          sl.protocol_app_node_id = pan.protocol_app_node_id
         AND pan.protocol_app_node_id = res.protocol_app_node_id
         AND sl.study_id IN (SELECT study_id FROM study.Study WHERE investigation_id IS NOT NULL)
         AND sl.study_id = dr.study_id (+)
         AND dr.study_id is null
        GROUP BY
          res.source_id
        , res.profile_type
        , sl.study_id
        , res.id
        ) profile
      WHERE
        ds.name = d.name
        AND ps.investigation_id = i.study_id
        AND ds.version = r.version
        AND d.external_database_id = r.external_database_id
        AND r.external_database_release_id = i.external_database_release_id
        AND i.investigation_id IS NULL
        AND profile.study_id = ps.study_id
    UNION
      SELECT
        ds.name AS dataset_name
      , ds.type AS dataset_type
      , ds.subtype AS dataset_subtype
      , profile.profile_type
      , profile.source_id
      , profile.study_id AS profile_study_id
      , ps.name AS profile_set_name
      , case when regexp_replace(ps.name, '\[.+\]', '') like '% - %' 
                  then regexp_replace(regexp_replace(ps.name, '\[.+\]', ''), '.+ - ', '')
                  else null
                  end as profile_set_suffix
      , profile.profile_as_string
      , profile.max_value
      , profile.min_value
      , profile.max_timepoint
      , profile.min_timepoint
      FROM
        apidb.DataSource ds
      , sres.ExternalDatabase d
      , sres.ExternalDatabaseRelease r
      , study.study i
      , study.study ps
      ,(SELECT
          res.source_id
        , res.profile_type
        , sl.study_id
        , res.id
        , listagg(NVL(TO_CHAR(ROUND(res.value, 2)), 'NA'), CHR(9)) within GROUP(ORDER BY pan.node_order_num) AS profile_as_string
        , cast (null as number(1)) AS max_value
        , cast (null as number(1)) AS min_value
        , max(pan.name) keep(dense_rank last order by value) as max_timepoint
        , MAX(pan.name) keep(dense_rank FIRST ORDER BY value) AS min_timepoint
        FROM
          study.StudyLink sl
        , (select distinct sl.study_id
           from study.studylink sl, protocolappnoderesults panr
           where sl.protocol_app_node_id = panr.protocol_app_node_id
           and panr.result_table = 'Results::NAFeatureDiffResult') dr

        , study.ProtocolAppNode pan
        ,(SELECT
            gene_profiles.*
          , ga.source_id
          FROM
            (
            SELECT
              'value' AS profile_type
            , value AS value
            , na_feature_id AS id
            , protocol_app_node_id
            FROM
              apidb.HaplotypeResult
            ) gene_profiles
          , GeneAttributes ga
          WHERE
            gene_profiles.id = ga.na_feature_id
) res
        WHERE
          sl.protocol_app_node_id = pan.protocol_app_node_id
          AND pan.protocol_app_node_id = res.protocol_app_node_id
         and sl.study_id = dr.study_id (+)
          and dr.study_id is null
        GROUP BY
          res.source_id
        , res.profile_type
        , sl.study_id
        , res.id
        ) profile
      WHERE
        ds.name = d.name
        AND ps.investigation_id = i.study_id
        AND ds.version = r.version
        AND d.external_database_id = r.external_database_id
        AND r.external_database_release_id = i.external_database_release_id
        AND i.investigation_id IS NULL
        AND profile.study_id = ps.study_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE Profile&1
        SET profile_as_string = NULL 
        WHERE replace(profile_as_string, 'NA' || CHR(9), '') = 'NA'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index exprof_idix&1
          on Profile&1 (source_id, profile_type, profile_set_name)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ProfileType">
    <internalDependency name="Profile"/>
    <sql>
      <![CDATA[
        CREATE TABLE ProfileType&1 nologging AS
	SELECT DISTINCT dataset_name, profile_study_id, profile_set_name, profile_set_suffix, profile_type, 
	       dataset_type, dataset_subtype
	FROM profile
	WHERE profile_as_string IS NOT NULL
	ORDER BY  dataset_name, profile_set_name,  profile_type
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProfileSamples">
    <internalDependency name="ProfileType"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="results.CompoundMassSpec"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <sql>
      <![CDATA[
      CREATE TABLE ProfileSamples&1 nologging AS
	SELECT DISTINCT s.name AS study_name, s.study_id, 
	  REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                         ' \(.+\)', '')AS protocol_app_node_name,
	  pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
	  pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
          pt.profile_set_suffix
	FROM profileType pt, study.study s, study.studyLink sl, 
	  study.protocolAppNode pan, results.nafeatureexpression r
	WHERE pt.profile_set_name =  s.name
	AND sl.study_id = s.study_id
	AND sl.protocol_app_node_id = pan.protocol_app_node_id
	AND  pan.protocol_app_node_id =r.protocol_app_node_id
      UNION
	SELECT DISTINCT s.name AS study_name, s.study_id, 
	  REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                         ' \(.+\)', '')AS protocol_app_node_name,
	  pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
	  pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
          pt.profile_set_suffix
	FROM profileType pt, study.study s, study.studyLink sl, 
	  study.protocolAppNode pan, results.compoundMassSpec r
	WHERE pt.profile_set_name =  s.name
	AND sl.study_id = s.study_id
	AND sl.protocol_app_node_id = pan.protocol_app_node_id
	AND  pan.protocol_app_node_id =r.protocol_app_node_id 
      UNION
	SELECT DISTINCT s.name AS study_name, s.study_id, 
	  REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                         ' \(.+\)', '')AS protocol_app_node_name,
	  pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
	  pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
          pt.profile_set_suffix
	FROM profileType pt, study.study s, study.studyLink sl, 
	  study.protocolAppNode pan, apidb.ontologytermresult r
	WHERE pt.profile_set_name =  s.name
	AND sl.study_id = s.study_id
	AND sl.protocol_app_node_id = pan.protocol_app_node_id
	AND  pan.protocol_app_node_id =r.protocol_app_node_id 
      UNION
	SELECT DISTINCT s.name AS study_name, s.study_id, 
	  REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                         ' \(.+\)', '')AS protocol_app_node_name,
	  pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
	  pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
          pt.profile_set_suffix
	FROM profileType pt, study.study s, study.studyLink sl, 
	  study.protocolAppNode pan, results.nafeaturehostresponse r
	WHERE pt.profile_set_name =  s.name
	AND sl.study_id = s.study_id
	AND sl.protocol_app_node_id = pan.protocol_app_node_id
	AND  pan.protocol_app_node_id =r.protocol_app_node_id 
      UNION
	SELECT DISTINCT s.name AS study_name, s.study_id, 
	  REGEXP_REPLACE(REGEXP_REPLACE (pan.name, ' \[.+\] \(.+\)', ''),
                         ' \(.+\)', '')AS protocol_app_node_name,
	  pan.protocol_app_node_id, pan.node_order_num, pt.profile_type,
	  pt.dataset_name, pt.dataset_type, pt.dataset_subtype,
          pt.profile_set_suffix
	FROM profileType pt, study.study s, study.studyLink sl, 
	  study.protocolAppNode pan, apidb.crisprphenotype r
	WHERE pt.profile_set_name =  s.name
	AND sl.study_id = s.study_id
	AND sl.protocol_app_node_id = pan.protocol_app_node_id
	AND  pan.protocol_app_node_id =r.protocol_app_node_id 
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GeneGroupProfile">
    <comment> For all datasets, list all genes (source_id) of a gene_group where one of them (profile_graph_id) 
              has data for a profile_set. 
    </comment>      
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="Profile"/>
    <externalDependency name="dots.geneinstance"/>
    <sql>
      <![CDATA[
        create table GeneGroupProfile&1 nologging as
        select distinct other_gene.source_id, p.dataset_name,
             this_gene.source_id as profile_graph_id
        from dots.geneinstance this_gi, dots.geneinstance other_gi,
             geneattributes this_gene, geneattributes other_gene,
             profile p
        where this_gi.gene_id = other_gi.gene_id
          and this_gi.na_feature_id = this_gene.na_feature_id
          and other_gi.na_feature_id = other_gene.na_feature_id
          and this_gene.source_id = p.source_id
          and this_gene.orthomcl_name = other_gene.orthomcl_name
        union
	select ga.source_id, p.dataset_name, p.source_id as profile_graph_id
	from profile p, geneattributes ga
	where p.source_id = ga.source_id
    ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ExternalDbDatasetPresenter">
    <comment>
      A materialization of the oft-computed join of sres.externalDatabaseRelease,
      sres.externalDatabase, and DatasetPresenter.
    </comment>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
        CREATE TABLE ExternalDbDatasetPresenter&1 NOLOGGING AS
        SELECT ed.external_database_id, ed.name AS external_database_name,
               edr.external_database_release_id, SUBSTR(edr.version, 1, 40) AS external_database_version,
               dsp.dataset_presenter_id, dsp.name AS dataset_presenter_name,
               dsp.display_name AS dataset_presenter_display_name
        FROM sres.externalDatabaseRelease edr,  sres.externalDatabase ed, DatasetPresenter dsp
        WHERE ed.external_database_id = edr.external_database_id
          AND (ed.name = dsp.name
               OR ed.name LIKE dsp.dataset_name_pattern)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index edd_rlsidix&1
          on ExternalDbDatasetPresenter&1
            (external_database_release_id, external_database_id, external_database_name,
             dataset_presenter_id, dataset_presenter_name, dataset_presenter_display_name)
        tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index edd_dsidix&1
          on ExternalDbDatasetPresenter&1
            (dataset_presenter_id, external_database_id, external_database_release_id, 
             external_database_name, dataset_presenter_name, dataset_presenter_display_name)
        tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index edd_dsnameix&1
          on ExternalDbDatasetPresenter&1
            (dataset_presenter_name, dataset_presenter_id, external_database_id, 
             external_database_release_id, external_database_name, external_database_version, 
             dataset_presenter_display_name)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ExpressionGraphsData">
    <comment>
       for gene-page expression graphs
    </comment>
    <internalDependency name="DatasetPresenter"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="ProfileSamples"/>
    <internalDependency name="ProfileSetDisplayInfo"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.Studylink"/>
    <sql>
      <![CDATA[
        CREATE TABLE ExpressionGraphsData&1 NOLOGGING  as
          -- RNASeq
          select ga.source_id, dnt.dataset_presenter_id as dataset_id,
                     case when ps.profile_set_suffix is null then ps.protocol_app_node_name else ps.protocol_app_node_name || ' - ' || ps.profile_set_suffix end 
                       || '- ' || 
                      case when dp.value in ('0', 'false') and pan.name like '% firststrand %' then 'sense' 
                                when dp.value in ('0', 'false') and pan.name like '% secondstrand %' then 'antisense' 
                                when dp.value in ('1', 'true') and pan.name like '% firststrand %' then 'antisense' 
                                when dp.value in ('1', 'true') and pan.name like '% secondstrand %' then 'sense' 
                                else 'unstranded' 
                      end  AS sample_name,
                 round(nfe.value, 2) as value,
                 round(nfe.standard_error, 2) as standard_error,
                 round(nfe.percentile_channel1, 2) as percentile_channel1,
                 round(nfe.percentile_channel2, 2) as percentile_channel2,
                 ps.node_order_num, 
                 ps.protocol_app_node_id
          from results.NaFeatureExpression nfe, GeneAttributes ga, study.ProtocolAppNode pan,
               ProfileSamples ps, study.Study s, study.Study i,
               sres.ExternalDatabaseRelease r, sres.ExternalDatabase d,
               DatasetNameTaxon dnt, DatasetProperty dp
          where ga.na_feature_id = nfe.na_feature_id
            and nfe.protocol_app_node_id = pan.protocol_app_node_id
            and pan.protocol_app_node_id = ps.protocol_app_node_id
            and ps.study_id = s.study_id
            and s.investigation_id = i.study_id
            and i.external_database_release_id = r.external_database_release_id
            and r.external_database_id = d.external_database_id
            and d.name = dnt.name
            and dnt.dataset_presenter_id = dp.dataset_presenter_id
            and dp.property = 'switchStrandsProfiles'
            and ps.study_name not like '%cuff%'
            and ps.study_name not like '%htseq-intersection-nonempty%'
            and ps.study_name not like '%htseq-intersection-strict%'
        UNION
          -- Splice Site data
          select ga.source_id, dnt.dataset_presenter_id as dataset_id,
                 case when ps.profile_set_suffix is null then ps.protocol_app_node_name else ps.protocol_app_node_name || ' ' || ps.profile_set_suffix end AS sample_name,
                 round(nfe.value, 2) as value,
                 round(nfe.standard_error, 2) as standard_error,
                 round(nfe.percentile_channel1, 2) as percentile_channel1,
                 round(nfe.percentile_channel2, 2) as percentile_channel2,
                 ps.node_order_num, 
                 ps.protocol_app_node_id
          from results.NaFeatureExpression nfe, GeneAttributes ga, study.ProtocolAppNode pan,
               ProfileSamples ps, study.Study s, study.Study i,
               sres.ExternalDatabaseRelease r, sres.ExternalDatabase d,
               DatasetNameTaxon dnt,DatasetProperty dp
          where ga.na_feature_id = nfe.na_feature_id
            and nfe.protocol_app_node_id = pan.protocol_app_node_id
            and pan.protocol_app_node_id = ps.protocol_app_node_id
            and ps.study_id = s.study_id
            and s.investigation_id = i.study_id
            and i.external_database_release_id = r.external_database_release_id
            and r.external_database_id = d.external_database_id
            and d.name = dnt.name
            and dnt.dataset_presenter_id = dp.dataset_presenter_id
            and dp.property ='type' and dp.value='Splice Site'
        UNION
          -- microarray expression, quantitative proteomics, and eQTL
          select ga.source_id, dnt.dataset_presenter_id as dataset_id,
                 case when ps.profile_set_suffix is null then ps.protocol_app_node_name else ps.protocol_app_node_name || ' ' || ps.profile_set_suffix end AS sample_name,
                 round(nfe.value, 2) as value,
                 round(nfe.standard_error, 2) as standard_error,
                 round(nfe.percentile_channel1, 2) as percentile_channel1,
                 round(nfe.percentile_channel2, 2) as percentile_channel2,
                 ps.node_order_num, 
                 ps.protocol_app_node_id
          from results.NaFeatureExpression nfe, GeneAttributes ga, study.ProtocolAppNode pan,
               ProfileSamples ps, study.Study s, study.Study i,
               sres.ExternalDatabaseRelease r, sres.ExternalDatabase d,
               DatasetNameTaxon dnt, DatasetPresenter dsp
          where ga.na_feature_id = nfe.na_feature_id
            and nfe.protocol_app_node_id = pan.protocol_app_node_id
            and pan.protocol_app_node_id = ps.protocol_app_node_id
            and ps.study_id = s.study_id
            and s.investigation_id = i.study_id
            and i.external_database_release_id = r.external_database_release_id
            and r.external_database_id = d.external_database_id
            and d.name = dnt.name
            and dnt.dataset_presenter_id = dsp.dataset_presenter_id
            and dsp.subtype != 'rnaseq'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index edg_ix&1
          on ExpressionGraphsData&1
            (source_id, dataset_id, sample_name, value, standard_error, percentile_channel1, percentile_channel2)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="Taxonomy">
    <comment>
       For each distinct organism in GeneAttributes, all ancestors in the taxon tree. For the gene page.
    </comment>
    <internalDependency name="GeneAttributes"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
        CREATE TABLE Taxonomy&1 NOLOGGING as
          SELECT tax.*, 
                   CONNECT_BY_ROOT name AS organism,
                   rownum orderNum
            FROM (SELECT t.taxon_id, t.parent_id, t.ncbi_tax_id,
                         cast(tn.name as varchar2(80)) as name,
                         cast(t.rank as varchar2(24)) as rank
                  FROM sres.Taxon t, sres.TaxonName tn
                  WHERE t.taxon_id = tn.taxon_id
                    AND tn.name_class = 'scientific name'
                 ) tax
            WHERE tax.name != 'root'
            START WITH name IN (SELECT DISTINCT organism FROM GeneAttributes)
            CONNECT BY prior parent_id = taxon_id
       ]]>
    </sql>
    <sql>
      <![CDATA[
        create index tax_ix&1
          on Taxonomy&1
            (organism, ordernum, taxon_id, parent_id, ncbi_tax_id, name, rank)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

<!--
  <tuningTable name="GeneModelDump">
    <comment>
       Materialization of GeneTables.GeneModelDump.
       THIS WILL NOT BE NEEDED AFTER PENDING CHANGES TO THE WDK ARE COMPLETED.
    </comment>
    <externalDependency name="apidb.FeatureLocation"/>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.ExonFeature"/>
    <sql>
      <![CDATA[
        CREATE TABLE GeneModelDump&1 NOLOGGING as
          SELECT source_id, project_id, sequence_id, gm_start,gm_end, type, is_reversed,
  listagg(transcript_id, ', ') within GROUP(ORDER BY transcript_id) AS transcript_ids
 from ( select ta.source_id as transcript_id, ta.gene_source_id as source_id, '@PROJECT_ID@' as project_id,
                ta.sequence_id,gm.start_min as gm_start, gm.end_max as gm_end,
                gm.type, gl.is_reversed
         from
              apidb.FeatureLocation gl, dots.NaSequence s,
              TranscriptAttributes ta,
              (select  decode(el.feature_type,'ExonFeature','Exon',el.feature_type) as type, el.parent_id as na_feature_id,
                       el.start_min as start_min , el.end_max as end_max
               from apidb.FeatureLocation el
               where el.feature_type in  ('ExonFeature','UTR','CDS','Intron')
               and el.is_top_level = 1
              ) gm
         where gm.na_feature_id = ta.na_feature_id
         and s.na_sequence_id = gl.na_sequence_id
         and ta.na_feature_id = gl.na_feature_id
         and gl.is_top_level = 1
         and ta.gene_type = 'protein coding'
         UNION ALL
         (select ta.source_id as transcript_id, ta.gene_source_id as source_id, '@PROJECT_ID@' as project_id,
                ta.sequence_id,gm.start_min as gm_start, gm.end_max as gm_end,
                gm.type, gl.is_reversed
         from dots.GeneFeature gf, apidb.FeatureLocation gl, dots.NaSequence s,
              TranscriptAttributes ta,
              (select  decode(el.feature_type,'ExonFeature','Exon',el.feature_type) as type, el.parent_id as na_feature_id,
                       el.start_min as start_min , el.end_max as end_max
               from apidb.FeatureLocation el
               where el.feature_type in  ('ExonFeature','UTR','CDS','Intron')
               and el.is_top_level = 1
              union ALL      
               select 'Intron' as type, left.parent_id as na_feature_id,
                      leftLoc.end_max + 1  as start_min, rightLoc.start_min - 1 as end_max
               from dots.ExonFeature left, apidb.FeatureLocation leftLoc,
                    dots.ExonFeature right, apidb.FeatureLocation rightLoc
               where left.parent_id = right.parent_id
                 and (left.order_number = right.order_number - 1
                      or left.order_number = right.order_number + 1)
                 and leftLoc.start_min < rightLoc.start_min
                 and left.na_feature_id = leftLoc.na_feature_id
                 and leftLoc.is_top_level = 1
                 and right.na_feature_id = rightLoc.na_feature_id
                 and rightLoc.is_top_level = 1 ) gm
         where gm.na_feature_id = gf.na_feature_id
         and s.na_sequence_id = gl.na_sequence_id
         and gf.na_feature_id = gl.na_feature_id
         and gl.is_top_level = 1
         and  gf.source_id = ta.gene_source_id 
         and ta.gene_type != 'protein coding')
         )
         group by source_id, project_id, sequence_id,
                 gm_start,  gm_end,
                type, is_reversed
         order by case when is_reversed = 1 then -1 * gm_start else gm_start end
       ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gmd_ix&1
          on GeneModelDump&1
            (source_id, project_id, sequence_id, gm_start, gm_end, is_reversed, type, transcript_ids)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>
-->

  <tuningTable name="RflpGenotypes">
    <comment>
       Ordered list of distinct genotypes for each protocol_app_node_id in apidb.RflpGenotypes
    </comment>
    <externalDependency name="apidb.RflpGenotype"/>
    <internalDependency name="PANProtocolMetadata"/>
    <sql>
      <![CDATA[
        create table RflpGenotypes&1 nologging as
        select sd.protocol_app_node_id, sd.output_protocol_app_node_id,
               cast (listagg(genotype, ', ') within group (order by genotype) as varchar2(80)) as genotypes
        from (select distinct genotype, protocol_app_node_id from apidb.RflpGenotype) rg,
             SampleDownstream sd
        where sd.output_protocol_app_node_id = rg.protocol_app_node_id
        group by sd.protocol_app_node_id, sd.output_protocol_app_node_id
       ]]>
    </sql>
    <sql>
      <![CDATA[
        create index rflpG_ix&1
          on RflpGenotypes&1
            (protocol_app_node_id, output_protocol_app_node_id, genotypes)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="MetadataType">
    <comment>
       Data type and filter method for metadata properties.
    </comment>
    <internalDependency name="PANProtocolMetadata"/>
    <sql>
      <![CDATA[
        CREATE TABLE MetadataType&1 NOLOGGING AS
        WITH override
        AS ( SELECT 'age' AS property, 'number' AS type, 'range' AS filter FROM dual
            UNION
              SELECT 'name' AS property, 'string' AS type, 'membership' AS filter FROM dual
            union   
              SELECT 'studyid' AS property, 'string' AS type, 'membership' AS filter FROM dual
           union   
              SELECT 'taxon_id' AS property, 'number' AS type, 'membership' AS filter FROM dual
          union
             SELECT 'proportion mapped reads' AS property, 'number' AS type, 'range' AS filter FROM dual
           ),
        metadata
        AS (  SELECT term, value
              FROM panProtocolMetadata
              WHERE term NOT IN (SELECT property FROM override)
            UNION
              SELECT term, value
              FROM panCharacteristicMetadata
              WHERE term NOT IN (SELECT property FROM override)
           ),
        term_attributes
        AS (SELECT term,
                   MAX(CASE
                         -- leaving how shon had this... when value is null, treating as numeric
                         WHEN value is null OR LENGTH(TRIM(TRANSLATE(value, ' +-.0123456789', ' '))) is null
                           THEN 0
                         ELSE 1
                       END) AS is_string
            FROM metadata
            GROUP BY term
           )
     SELECT * FROM override
 UNION ALL
   SELECT term AS property,
          CASE is_string
            WHEN 1
              THEN 'string'
            ELSE 'number'
          END AS type,
          CASE is_string
            WHEN 1
              THEN 'membership'
            ELSE 'range' 
          END AS filter
   FROM term_attributes
       ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX mtdprop_ix&1
          ON MetadataType&1 (property)
        TABLESPACE indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX mtdttyp_ix&1
          ON MetadataType&1 (property, type, filter)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="GeneSummaryFilter">
    <comment>
       Distinct filter_name for gene query summary. For the initial version,
       at least, it's (GeneAttriutes.species UNION GeneAttributes.organism).
       Note that the UNION implies set bahavior and therefore distinctness.
    </comment>
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
        CREATE TABLE GeneSummaryFilter&1 NOLOGGING AS
        SELECT CAST(filter_name AS VARCHAR2(80)) AS filter_name
        FROM (SELECT species as filter_name
              FROM GeneAttributes
            UNION
              SELECT organism as filter_name
              FROM GeneAttributes)
       ]]>
    </sql>
  </tuningTable>

  <tuningTable name="AaSequenceInfo">
    <comment>
       Info from dots.ExternalAaSequence records for BLAT alignments
    </comment>
    <externalDependency name="apidb.BlatProteinAlignment"/>
    <sql>
      <![CDATA[
        CREATE TABLE AaSequenceInfo&1 NOLOGGING AS
        SELECT aa_sequence_id, source_id,
               CAST(description AS VARCHAR2(300)) AS description
        FROM dots.ExternalAaSequence
        WHERE aa_sequence_id IN (SELECT query_aa_sequence_id
                                 FROM apidb.BlatProteinAlignment)
        ORDER by aa_sequence_id
       ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX aaSeqInf_ix&1
          ON AaSequenceInfo&1 (aa_sequence_id, source_id, description)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="TaxonRelativeAbundance">
    <comment>for the sample record taxon relative abundance table
     </comment>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="apidb.SequenceTaxon"/>
    <externalDependency name="results.OtuAbundance"/>
    <internalDependency name="PANProtocolMetadata"/>
    <internalDependency name="ExternalSequenceTaxonRank"/>
    <sql>
      <![CDATA[
        create table TaxonRelativeAbundance&1
            (name, protocol_app_node_id, taxon_id, relative_abundance, 
             absolute_abundance, ncbi_tax_id, kingdom, phylum, class, 
             rank_order, family, genus, species,
             constraint taxRelAbund&1_pk primary key(name, taxon_id))
        organization index
        nologging
        as select ta.*, t.ncbi_tax_id,
                  replace(decode(superkingdom, 'N/A', kingdom, superkingdom), 'N/A', '') as kingdom,
                  replace(phylum, 'N/A', '') as phylum,
                  replace(class, 'N/A', '') as class,
                  replace(rank_order, 'N/A', '') as rank_order,
                  replace(family, 'N/A', '') as family,
                  replace(genus, 'N/A', '') as genus,
                  replace(species, 'N/A', '') as species
           from (select ds.name, oa.protocol_app_node_id, taxonAssignment.taxon_id,
                        sum(nvl(oa.relative_abundance, 0)) as relative_abundance,
                        sum(nvl(oa.raw_count, 0)) as absolute_abundance
                 from results.OtuAbundance oa, SampleDownstream ds,
                      (select ens.na_sequence_id,
                              case
                                when st.taxon_id is not null
                                  then st.taxon_id
                                else ens.taxon_id
                              end as taxon_id,
                              case
                                when st.taxon_id is not null
                                  then 'Greengenes'
                                else 'Genbank'
                              end as source
                       from dots.ExternalNaSequence ens, apidb.SequenceTaxon st
                       where ens.na_sequence_id = st.na_sequence_id(+)
                       ) taxonAssignment
                 where oa.protocol_app_node_id = ds.output_protocol_app_node_id
                   and ds.output_isa_type = 'Data'
                   and oa.na_sequence_id = taxonAssignment.na_sequence_id
                 group by ds.name, oa.protocol_app_node_id, taxonAssignment.taxon_id
                ) ta,
                ExternalSequenceTaxonRank estr, sres.Taxon t
           where ta.taxon_id = estr.organism
             and ta.relative_abundance > 0
             and ta.taxon_id = t.taxon_id
      ]]>
    </sql>
  </tuningTable>

<tuningTable name="OrthologousGenes">
    <comment>
       Materialization of the orthology transform. Also useful for GeneTables.Orthologs.
    </comment>
    <internalDependency name="GeneAttributes"/>
    <externalDependency name="apidb.Synteny"/>
    <sql>
      <![CDATA[
        CREATE TABLE OrthologousGenes&1
          (source_id, ortho_source_id, ortho_product, ortho_organism, is_syntenic,
        CONSTRAINT ogenes&1_pk PRIMARY KEY(source_id, is_syntenic, ortho_source_id))
        ORGANIZATION INDEX
        NOLOGGING
        AS
        SELECT gene.source_id, ortho_gene.source_id AS ortho_source_id,
               ortho_gene.product AS ortho_product, ortho_gene.organism AS ortho_organism,
               CASE (SELECT COUNT(*)
                     FROM apidb.Synteny
                     WHERE a_na_sequence_id = gene.na_sequence_id
                       AND a_start < gene.end_max
                       AND a_end > gene.start_min
                       AND b_na_sequence_id = ortho_gene.na_sequence_id
                       AND b_start < ortho_gene.end_max
                       AND b_end > ortho_gene.start_min)
                 WHEN 0 THEN 0
                 ELSE 1
               END AS is_syntenic
        FROM GeneAttributes gene, GeneAttributes ortho_gene
        WHERE gene.orthomcl_name = ortho_gene.orthomcl_name
       ]]>
    </sql>
  </tuningTable>

  <tuningTable name="DatasetGeneList">
    <comment>
    For each RNASeq Dataset, compute the top 500 ratios of max/min gene expression.
    </comment>
    <internalDependency name="Profile"/>
    <internalDependency name="DatasetPresenter"/>
    <internalDependency name="GeneAttributes"/>
    <sql>
      <![CDATA[
        CREATE TABLE DatasetGeneList&1 AS
        SELECT * FROM
          (SELECT source_id, organism, orthomcl_name, profile_study_id, dataset_name, dataset_presenter_id,
            fdiff, min_value, min_timepoint, max_value, max_timepoint,
            row_number() OVER (PARTITION BY dataset_name,profile_study_id order by fdiff DESC) AS myrow
          FROM
            (SELECT p.source_id, ga.organism, ga.orthomcl_name, p.profile_study_id, p.dataset_name
              , dp.dataset_presenter_id 
              , ROUND ( max_value / CASE WHEN min_value < 1 THEN 1 ELSE min_value END,2) AS fdiff
              , ROUND (p.min_value, 2) as min_value 
              , REGEXP_REPLACE (p.min_timepoint, ' \[.+\] \(.+\)', '') as min_timepoint
              , ROUND( p.max_value, 2) as max_value
              , REGEXP_REPLACE (p.max_timepoint, ' \[.+\] \(.+\)', '') as max_timepoint
            FROM Profile p, DatasetPresenter dp, DatasetProperty dprop, GeneAttributes ga
            WHERE p.dataset_type        = 'transcript_expression'
            AND p.dataset_subtype       = 'rnaseq'
            AND p.profile_type          = 'values'
            AND p.dataset_name          = dp.NAME
            AND dp.dataset_presenter_id = dprop.dataset_presenter_id
            AND property                = 'switchStrandsProfiles'
            AND ((dprop.value = 'false' AND p.min_timepoint LIKE '%firststrand%')
              OR (dprop.value = 'true' AND p.min_timepoint LIKE '%secondstrand%')
              OR (p.min_timepoint LIKE '%unstranded%'))
            AND p.source_id = ga.source_id
            )
          WHERE fdiff >= 5.0
          ORDER BY DATASET_NAME, profile_study_id, fdiff DESC
          )
        WHERE myrow<1001
        ORDER BY dataset_name
       ]]>
    </sql>

    <sql>
      <![CDATA[
create index DsGl_source_id_idx&1 ON DatasetGeneList&1 (source_id,organism)
tablespace indx
      ]]>
    </sql>

    <sql>
      <![CDATA[
create index DsGl_omcl_nme_idx&1 ON DatasetGeneList&1 (orthomcl_name,organism)
tablespace indx
      ]]>
    </sql>    
  </tuningTable>

</tuningConfig>
