<?xml version="1.0" encoding="UTF-8"?>
<tuningConfig>

<tuningTable name="SampleId" prefixEnabled="false">
    <comment>Which protocol app nodes for sample record                                                                                                    
    </comment>
    <externalDependency name="study.ProtocolAppNode"/>
    <sql>
      <![CDATA[         
create table SampleId&1 as 
select protocol_app_node_id, name from study.protocolappnode where isa_type = 'Sample'
union
select pan.protocol_app_node_id, pan.name
from study.study s
   , sres.externaldatabase d
   , sres.externaldatabaserelease r
   , study.protocolappnode pan
   , study.studylink sl
where s.external_database_release_id = r.external_database_release_id
and r.external_database_id = d.external_database_id
and s.study_id = sl.study_id
and sl.protocol_app_node_id = pan.protocol_app_node_id
and d.name like '%isolates_genbank_RSRC'
      ]]>
</sql>
</tuningTable>


<tuningTable name="OrganismSelectTaxonRank" prefixEnabled="false">
    <comment>Taxon ranks for organisms                                                                                                     
    </comment>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.Taxon"/>
    <sql>
      <![CDATA[         
create table OrganismSelectTaxonRank&1 as 
with organism_rank as (
select tn1.name as organism, o.public_abbrev, tn2.name as parent_organism, 
case when tn2.name = 'Oomycetes' then 'class' else r.rank end as rank

from (
select CONNECT_BY_ROOT taxon_id as input, taxon_id, rank
from sres.taxon
start with taxon_id in (select taxon_id from apidb.organism where is_annotated_genome = 1)
connect by prior parent_id = taxon_id) r
, sres.taxonname tn1
, sres.taxonname tn2
, apidb.organism o
where r.input = tn1.taxon_id
and r.taxon_id = tn2.taxon_id
and tn1.name_class = 'scientific name'
and tn2.name_class = 'scientific name'
and (r.rank in ('phylum', 'genus', 'species', 'kingdom', 'class') or (r.rank = 'no rank' and tn2.name = 'Oomycetes'))
and tn1.taxon_id = o.taxon_id
)

select organisms.organism, organisms.public_abbrev, nvl (phylum.parent_organism, 'N/A') as phylum, nvl ( genus.parent_organism, 'N/A') as genus, nvl(species.parent_organism, 'N/A') as species , nvl(kingdom.parent_organism, 'N/A') as kingdom, nvl (class.parent_organism, 'N/A') as class
from 
(select distinct organism, public_abbrev from organism_rank) organisms,
(select * from organism_rank where rank= 'phylum') phylum,
(select * from organism_rank where rank= 'genus') genus,
(select * from organism_rank where rank= 'species') species,
(select * from organism_rank where rank= 'kingdom') kingdom,
(select * from organism_rank where rank= 'class') class
where organisms.organism = phylum.organism (+)
and organisms.organism = genus.organism (+)
and organisms.organism = species.organism (+)
and organisms.organism = kingdom.organism (+)
and organisms.organism = class.organism (+)
 ]]>
</sql>
</tuningTable>



<tuningTable name="PathwayAttributes" prefixEnabled="false">
    <comment>Attributes for Metabolic Pathways
    </comment>
    <externalDependency name="sres.Pathway"/>
    <externalDependency name="sres.PathwayNode"/>
    <sql>
      <![CDATA[
create table PathwayAttributes&1 as
SELECT
  p.source_id
, p.pathway_id
, p.name
, enz.total_enzyme_count
, cpd.total_compound_count
, p.url
, replace(replace(ed.name, 'Pathways_', ''), '_RSRC', '') as pathway_source
, ed.name as external_db_name
, edr.version as external_db_version
FROM
  sres.pathway p
, sres.externalDatabase ed
, sres.externalDatabaseRelease edr
,(SELECT
    COUNT( *) AS total_compound_count
  , pathway_id
  FROM
    sres.pathwayNode pn
  , SRES.ontologyterm ot
  WHERE
    pn.pathway_node_type_id = ot.ontology_term_id
    AND ot.name = 'molecular entity'
  GROUP BY
    pathway_id
  ) cpd
,(SELECT
    COUNT( *) AS total_enzyme_count
  , pathway_id
  FROM
    sres.pathwayNode pn
  , SRES.ontologyterm ot
  WHERE
    pn.pathway_node_type_id = ot.ontology_term_id
    AND ot.name = 'enzyme'
  GROUP BY
    pathway_id
  ) enz
WHERE
  ed.external_database_id = edr.external_database_id
  AND edr.external_database_release_id = p.external_database_release_id
  AND cpd.pathway_id = p.pathway_id
  AND enz.pathway_id = p.pathway_id
  AND source_id NOT IN('ec01100', 'ec01110', 'ec01120')
      ]]>
    </sql>
  </tuningTable>



<tuningTable name="ProtocolAppNodesResults" prefixEnabled="false">
    <comment>Table of protocol app node ids and the name of the result table where they are referenced
    </comment>
    <externalDependency name="results.NaFeatureDiffResult"/>
    <externalDependency name="results.ReporterIntensity"/>
    <externalDependency name="results.SegmentResult"/>
    <externalDependency name="results.CompoundMassSpec"/>
    <externalDependency name="results.NaFeatureHostResponse"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="results.EditingEvent"/>
    <externalDependency name="results.FamilyDiffResult"/>
    <externalDependency name="results.FamilyExpression"/>
    <externalDependency name="results.GeneDiffResult"/>
    <externalDependency name="results.GeneExpression"/>
    <externalDependency name="results.GeneSimilarity"/>
    <externalDependency name="results.ReporterDiffResult"/>
    <externalDependency name="results.ReporterExpression"/>
    <externalDependency name="results.RnaDiffResult"/>
    <externalDependency name="results.RnaExpression"/>
    <externalDependency name="results.SegmentDiffResult"/>
    <externalDependency name="results.SeqVariation"/>
    <externalDependency name="apidb.SequenceVariation"/>
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="apidb.ChrCopyNumber"/>
    <externalDependency name="apidb.GeneCopyNumber"/>
    <externalDependency name="apidb.intronjunction"/>
    <sql>
      <![CDATA[
create table ProtocolAppNodesResults&1 as
    select protocol_app_node_id, 'Results::NAFeatureDiffResult' as result_table from Results.NAFeatureDiffResult
    union
    select protocol_app_node_id, 'Results::ReporterIntensity' as result_table from Results.ReporterIntensity
    union
    select protocol_app_node_id, 'Results::SegmentResult' as result_table from Results.SegmentResult
    union
    select protocol_app_node_id, 'Results::CompoundMassSpec' as result_table from Results.CompoundMassSpec
    union
    select protocol_app_node_id, 'Results::NaFeatureHostResponse' as result_table from Results.NaFeatureHostResponse
    union
    select protocol_app_node_id, 'ApiDB::ChrCopyNumber' as result_table from ApiDB.ChrCopyNumber
    union
    select protocol_app_node_id, 'ApiDB::GeneCopyNumber' as result_table from ApiDB.GeneCopyNumber
    union
    select protocol_app_node_id, 'Results::NAFeatureExpression' as result_table from Results.NAFeatureExpression
    union
    select protocol_app_node_id, 'Results::EditingEvent' as result_table from Results.EditingEvent
    union
      select protocol_app_node_id, 'Results::FamilyDiffResult' as result_table from Results.FamilyDiffResult
    union
      select protocol_app_node_id, 'Results::FamilyExpression' as result_table from Results.FamilyExpression
    union
      select protocol_app_node_id, 'Results::GeneDiffResult' as result_table from Results.GeneDiffResult
    union
      select protocol_app_node_id, 'Results::GeneExpression' as result_table from Results.GeneExpression
    union
      select protocol_app_node_id, 'Results::GeneSimilarity' as result_table from Results.GeneSimilarity
    union
      select protocol_app_node_id, 'Results::ReporterDiffResult' as result_table from Results.ReporterDiffResult
    union
      select protocol_app_node_id, 'Results::ReporterExpression' as result_table from Results.ReporterExpression
      union
    select protocol_app_node_id, 'Results::RnaDiffResult' as result_table from Results.RnaDiffResult
      union
    select protocol_app_node_id, 'Results::RnaExpression' as result_table from Results.RnaExpression
      union
    select protocol_app_node_id, 'Results::SegmentDiffResult' as result_table from Results.SegmentDiffResult
    union
      select protocol_app_node_id, 'Results::SeqVariation' as result_table from Results.SeqVariation
    union
    select protocol_app_node_id, 'ApiDB::SequenceVariation' as result_table from apidb.sequencevariation
    union
    select protocol_app_node_id, 'ApiDB::MassSpecSummary' as result_table from apidb.MASSSPECSUMMARY
    union
    select protocol_app_node_id, 'ApiDB::IntronJunction' as result_table from apidb.IntronJunction
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="PANProtocolMetadata" prefixEnabled="false">
    <comment>
    </comment>
    <internalDependency name="ProtocolAppNodesResults"/>
    <internalDependency name="SampleId"/>
    <externalDependency name="study.ProtocolApp"/>
    <externalDependency name="study.Input"/>
    <externalDependency name="study.Output"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Characteristic"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="study.Protocol"/>
    <externalDependency name="study.ProtocolParam"/>
    <externalDependency name="study.ProtocolAppParam"/>
    <ancillaryTable name="ProtocolAppNodeIO"/>
    <ancillaryTable name="PANCharacteristicMetadata"/>
    <ancillaryTable name="SampleCharMetadata"/>
    <ancillaryTable name="SampleProtocolMetadata"/>
    <ancillaryTable name="SampleDownstream"/>
    <sql>
      <![CDATA[
        create table ProtocolAppNodeIO&1 nologging as
        select i.protocol_app_node_ID input_node_id, pa.protocol_app_id, o.protocol_app_node_id output_node_id
        from study.ProtocolApp pa, study.Input i, study.Output o
        where i.protocol_app_id = pa.protocol_app_id
          and o.protocol_app_id = pa.protocol_app_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create table PANProtocolMetadata&1 nologging as
        with node_inputs
        as (select connect_by_root output_node_id as protocol_app_node_id, input_node_id, protocol_app_id
            from ProtocolAppNodeIO&1
            start with output_node_id in (select protocol_app_node_id from ProtocolAppNodesResults)
            connect by prior input_node_id = output_node_id
           )
        select node_inputs.protocol_app_node_id, ds.name as dataset_name,
               case
                  when lower(ds.name) like '%icemr%' then 1
                  else 0
                end as is_icemr,
               p.name as category, pan.name as pan_name, pp.name as term,
               pap.value, pap.protocol_app_param_id, ds.type, ds.subtype, tn.name as organism,
               study_release.study_name, study_release.investigation_name
        from node_inputs, study.ProtocolAppParam pap, study.ProtocolParam pp,
             study.Protocol p, study.StudyLink sl,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
             apidb.Datasource ds, study.ProtocolAppNode pan, sres.TaxonName tn,
             (  select s.study_id, i.external_database_release_id,
                       s.name as study_name, i.name as investigation_name
                from study.Study s, study.Study i
                where s.investigation_id = i.study_id
              union
                select s.study_id, s.external_database_release_id,
                       s.name as study_name, null as investigation_name
                from study.Study s) study_release
        where node_inputs.protocol_app_id = pap.protocol_app_id
          and pap.protocol_param_id = pp.protocol_param_id
          and pp.protocol_id = p.protocol_id
          and node_inputs.protocol_app_node_id = sl.protocol_app_node_id
          and sl.study_id = study_release.study_id
          and study_release.external_database_release_id = edr.external_database_release_id
          and edr.external_database_id = ed.external_database_id
          and ed.name = ds.name
          and node_inputs.protocol_app_node_id = pan.protocol_app_node_id
          and ds.taxon_id = tn.taxon_id(+)
          and (tn.name_class = 'scientific name' or tn.name_class is null)
          and p.name not like '%::%' -- avoid Perl class names
          and p.name not like '%data transformation' -- avoid data transformation protocol parameters
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create table PANCharacteristicMetadata&1 nologging as
        with node_inputs
        as (select connect_by_root output_node_id as protocol_app_node_id, input_node_id, protocol_app_id
            from ProtocolAppNodeIO&1
            start with output_node_id in (select protocol_app_node_id from ProtocolAppNodesResults)
            connect by prior input_node_id = output_node_id
           )
        select sample_pan.protocol_app_node_id, mt.name as category, attribute_term.name as term,
               attribute_term.ontology_term_id as term_id, nvl(c.value, value_term.name) as value, c.characteristic_id,
               ds.name as dataset_name, sample_pan.name as pan_name, ds.type,
               case
                  when lower(ds.name) like '%icemr%' then 1
                  else 0
                end as is_icemr,
               ds.subtype, tn.name as organism,
               study_release.study_name, study_release.investigation_name
        from node_inputs, study.ProtocolAppNode pan, study.Characteristic c, sres.OntologyTerm value_term,
             sres.ontologyTerm mt, study.StudyLink sl,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed, sres.OntologyTerm attribute_term,
             apidb.Datasource ds, sres.TaxonName tn, study.ProtocolAppNode sample_pan,
             (  select s.study_id, i.external_database_release_id,
                       s.name as study_name, i.name as investigation_name
                from study.Study s, study.Study i
                where s.investigation_id = i.study_id
              union
                select s.study_id, s.external_database_release_id,
                       s.name as study_name, null as investigation_name
                from study.Study s) study_release
        where pan.protocol_app_node_id = c.protocol_app_node_id
          and pan.type_id = mt.ontology_term_id
          and c.ontology_term_id = value_term.ontology_term_id(+)
          and c.qualifier_id = attribute_term.ontology_term_id(+)
          and node_inputs.input_node_id = pan.protocol_app_node_id
          and node_inputs.protocol_app_node_id = sl.protocol_app_node_id
          and sl.study_id = study_release.study_id
          and study_release.external_database_release_id = edr.external_database_release_id
          and edr.external_database_id = ed.external_database_id
          and ed.name = ds.name
          and node_inputs.protocol_app_node_id = sample_pan.protocol_app_node_id
          and ds.taxon_id = tn.taxon_id(+)
          and (tn.name_class = 'scientific name' or tn.name_class is null)
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create table SampleCharMetadata&1 nologging as
     with node_inputs
        as (select connect_by_root output_node_id as protocol_app_node_id, input_node_id, protocol_app_id
            from protocolappnodeio&1
            start with output_node_id in (select protocol_app_node_id from sampleid)
            connect by prior input_node_id = output_node_id
           )
        select sample_pan.protocol_app_node_id, mt.name as category, attribute_term.name as term,
               attribute_term.ontology_term_id as term_id, nvl(c.value, value_term.name) as value, c.characteristic_id,
                sample_pan.name as pan_name
        from node_inputs, study.ProtocolAppNode pan, study.Characteristic c, sres.OntologyTerm value_term,
             sres.ontologyterm mt, 
             sres.ontologyterm attribute_term,
             study.ProtocolAppNode sample_pan
        where pan.protocol_app_node_id = c.protocol_app_node_id
          and pan.type_id = mt.ontology_term_id
          and c.ontology_term_id = value_term.ontology_term_id(+)
          and c.qualifier_id = attribute_term.ontology_term_id(+)
          and node_inputs.input_node_id = pan.protocol_app_node_id
          and node_inputs.protocol_app_node_id = sample_pan.protocol_app_node_id
        union
       select pan.protocol_app_node_id, mt.name, ot.name, ot.ontology_term_id, nvl(c.value, vot.name) as value, c.characteristic_id, pan.name
        from study.protocolappnode pan
           , sres.ontologyterm mt
           , study.characteristic c
           , sres.ontologyterm ot
           , sres.ontologyterm vot
        where pan.protocol_app_node_id in  (select protocol_app_node_id from sampleid)
         and pan.protocol_app_node_id = c.protocol_app_node_id
         and c.qualifier_id = ot.ontology_term_id
         and c.ontology_term_id = vot.ontology_term_id (+)
         and pan.type_id = mt.ontology_term_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create table SampleProtocolMetadata&1 nologging as
        with node_inputs
        as (select connect_by_root output_node_id as protocol_app_node_id, input_node_id, protocol_app_id
            from protocolappnodeio&1
            start with output_node_id in (select protocol_app_node_id from sampleid)
            connect by prior input_node_id = output_node_id
           )
        select node_inputs.protocol_app_node_id, 
               p.name as category, 
               pan.name as pan_name, 
               pp.name as term,
               pap.value, 
               pap.protocol_app_param_id
        from node_inputs
           , study.protocolappparam pap
           , study.protocolparam pp
           , study.protocol p
           , study.ProtocolAppNode pan
        where node_inputs.protocol_app_id = pap.protocol_app_id
          and pap.protocol_param_id = pp.protocol_param_id
          and pp.protocol_id = p.protocol_id
          and node_inputs.protocol_app_node_id = pan.protocol_app_node_id
          and p.name not like '%::%' -- avoid Perl class names
          and p.name not like '%data transformation'
      ]]>
    </sql>

    <sql>
      <![CDATA[
create table SampleDownstream&1 nologging as
SELECT
  p1.name
, p1.protocol_app_node_id
, p3.name as input
, p3.protocol_app_node_id as input_protoocl_app_node_id
, case
    WHEN ot3.name LIKE 'data%'
    THEN 'Data'
    else p3.isa_type
  end as input_isa_type
, ot3.name as input_material_type
, p.name AS protocol
, p2.name AS output
, p2.protocol_app_node_id AS output_protocol_app_node_id
, case
    WHEN ot2.name LIKE 'data%'
    THEN 'Data'
    else p2.isa_type
  end as output_isa_type
, ot2.name AS output_material_type
FROM
  (SELECT
    connect_by_root input_node_id AS protocol_app_node_id
  , input_node_id
  , output_node_id
  , protocol_app_id
  from
    protocolappnodeio&1
    start with input_node_id in (SELECT protocol_app_node_id FROM sampleid)
    CONNECT BY prior output_node_id = input_node_id
  ) io
, study.protocolappnode p1
, study.protocolappnode p2
, study.protocolappnode p3
, sres.ontologyterm ot2
, sres.ontologyterm ot3
, study.protocol p
, study.protocolapp pa
WHERE
  io.protocol_app_node_id = p1.protocol_app_node_id
  and io.output_node_id = p2.protocol_app_node_id
  and io.input_node_id = p3.protocol_app_node_id
  and p2.type_id = ot2.ontology_term_id (+)
  and p3.type_id = ot3.ontology_term_id (+)
  and io.protocol_app_id = pa.protocol_app_id
  and pa.protocol_id = p.protocol_id
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="FallbackMetadata">
    <comment>
      For datasets that have results but no metadata, a fallback set of metadata comprising the name of each ProtocolAppNode
    </comment>
    <internalDependency name="ProtocolAppNodesResults"/>
    <internalDependency name="PANProtocolMetadata"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <sql>
      <![CDATA[
        create table FallbackMetadata&1 nologging as
        select ds.name as dataset_name, ds.subtype, tn.name as organism,
               case
                  when lower(ds.name) like '%icemr%' then 1
                  else 0
                end as is_icemr,
               pan.name as pan_name, pan.protocol_app_node_id, 'name' as term_name,
               study_release.study_name, study_release.investigation_name
        from study.ProtocolAppNode pan, apidb.Datasource ds, study.StudyLink sl,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
             sres.TaxonName tn,
             (  select s.study_id, i.external_database_release_id,
                       s.name as study_name, i.name as investigation_name
                from study.Study s, study.Study i
                where s.investigation_id = i.study_id
              union
                select s.study_id, s.external_database_release_id,
                       s.name as study_name, null as investigation_name
                from study.Study s) study_release
        where pan.protocol_app_node_id in (select protocol_app_node_id
                                           from ProtocolAppNodesResults)
          and ds.name not in (select dataset_name from PANProtocolMetadata)
          and ds.name not in (select dataset_name from PANCharacteristicMetadata)
          and pan.protocol_app_node_id = sl.protocol_app_node_id
          and sl.study_id = study_release.study_id
          and study_release.external_database_release_id = edr.external_database_release_id
          and edr.external_database_id = ed.external_database_id
          and ed.name = ds.name
          and ds.taxon_id = tn.taxon_id(+)
          and (tn.name_class = 'scientific name' or tn.name_class is null)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="MetadataSpec">
    <comment>
    </comment>
    <internalDependency name="FallbackMetadata"/>
    <internalDependency name="PANProtocolMetadata"/>
    <sql>
      <![CDATA[
        create table MetadataSpec&1 nologging as
        select * from (
        with icemr_mapping
        as (select dataset_name,
                   case
                     when lower(dataset_name) like '%icemr%' then 1
                     else 0
                   end as is_icemr
            from (  select distinct dataset_name
                    from panCharacteristicMetadata
                  union
                    select distinct dataset_name
                    from panProtocolMetadata)),
        protocol_metadata
        as (select distinct organism, subtype, dataset_name, category, term, value
            from panProtocolMetadata),
        characteristic_metadata
        as (select distinct organism, subtype, dataset_name, category, term, value
            from panCharacteristicMetadata),
        metadata
        as (  select *
              from protocol_metadata
            union
              select *
              from characteristic_metadata),
        ontology_tree_metadata
        as (select distinct term_id, dataset_name, organism, subtype,
                            case
                              when lower(dataset_name) like '%icemr%' then 1
                              else 0
                            end as is_icemr
            from PANCharacteristicMetadata
            where lower(dataset_name) like '%icemr$' or dataset_name like '%Crompton%'
           ),
        leaf_term
        as (select distinct term_id
            from ontology_tree_metadata
           ),
        graph_edge
        as (select subject_term_id as child_term_id, object_term_id as parent_term_id
            from sres.OntologyRelationship
         -- WHERE EXTERNAL_DATABASE_RELEASE_ID IN ( <ICEMR ontology> )
            start with subject_term_id in (select term_id from leaf_term)
            connect by subject_term_id = prior object_term_id),
        unparented_term
        as (select parent_term_id as term_id from graph_edge
            minus
            select child_term_id as term_id from graph_edge),
        distinct_term
        as (select parent_term_id as term_id from graph_edge
            union
            select child_term_id as term_id from graph_edge),
        leaf_ancestor_pair
        as (select ancestor.term_id as ancestor_term_id, descendent.term_id as leaf_term_id
            from distinct_term ancestor, distinct_term descendent
            where descendent.term_id
                  in (select child_term_id
                      from graph_edge
                      start with parent_term_id = ancestor.term_id
                      connect by prior child_term_id = parent_term_id)
              and descendent.term_id in (select term_id from leaf_term)
            ),
        fallback
        as (select distinct dataset_name, subtype, organism, is_icemr, term_name as property
            from FallbackMetadata
           )
        -- END OF WITH CLAUSES (whew!)
        -- parent
          select distinct organism, m.dataset_name, subtype, is_icemr, term as property, 'parent' as spec_property, category as spec_value
          from metadata m, icemr_mapping im
          where m.dataset_name = im.dataset_name
            and (is_icemr = 0 and m.dataset_name not like '%Crompton%')
        -- leaf
        union
          select organism, m.dataset_name, subtype, is_icemr, term as property, 'leaf' as spec_property, 'true' as spec_value
          from metadata m, icemr_mapping im
          where m.dataset_name = im.dataset_name
        -- filter
        union
          select distinct organism, m.dataset_name, subtype, is_icemr, term as property, 'filter' as spec_property,
                 case
                    when term in ('Time To Onset', 'age') then 'range'
                    else 'membership'
                 end as spec_value
          from metadata m, icemr_mapping im
          where m.dataset_name = im.dataset_name
        -- display
        union
          select distinct organism, m.dataset_name, subtype, is_icemr, term as property, 'display' as spec_property, initcap(term) as spec_value
          from metadata m, icemr_mapping im
          where m.dataset_name = im.dataset_name
        -- type
        union
          select organism, m.dataset_name, subtype, is_icemr, term as property, 'type' as spec_property,
                 case
                   when is_string = 1 then 'string'
                   else 'number'
                 end as spec_value
          from (select organism, dataset_name, term, subtype,
                       max(case when regexp_like (nvl(value,0),'^[[:digit:]]*[.]?[[:digit:]]*$') or value is null
                                  then 0
                                else 1
                           end) as is_string
                from metadata
                group by organism, dataset_name, term, subtype
               ) m,
               icemr_mapping im
          where m.dataset_name = im.dataset_name
        -- parents: parent
        union
          select distinct organism, m.dataset_name, subtype, is_icemr, category as property, 'parent' as spec_property, 'protocol' as spec_value
          from protocol_metadata m, icemr_mapping im
          where m.dataset_name = im.dataset_name
            and (is_icemr = 0 and m.dataset_name not like '%Crompton%')
        union
          select distinct organism, m.dataset_name, subtype, is_icemr, category as property, 'parent' as spec_property, 'characteristic' as spec_value
          from characteristic_metadata m, icemr_mapping im
          where m.dataset_name = im.dataset_name
            and (is_icemr = 0 and m.dataset_name not like '%Crompton%')
        -- parents: display
        union
          select distinct organism, m.dataset_name, subtype, is_icemr, category as property, 'display' as spec_property, category as spec_value
          from metadata m, icemr_mapping im
          where m.dataset_name = im.dataset_name
            and (is_icemr = 0 and m.dataset_name not like '%Crompton%')
        -- grandparents: parent
        union
          select distinct organism, m.dataset_name, subtype, is_icemr, 'protocol' as property, 'parent' as spec_property, '' as spec_value
          from protocol_metadata m, icemr_mapping im
          where m.dataset_name = im.dataset_name
            and (is_icemr = 0 and m.dataset_name not like '%Crompton%')
        union
          select distinct organism, m.dataset_name, subtype, is_icemr, 'characteristic' as property, 'parent' as spec_property, '' as spec_value
          from characteristic_metadata m, icemr_mapping im
          where m.dataset_name = im.dataset_name
            and (is_icemr = 0 and m.dataset_name not like '%Crompton%')
        -- grandparents: display
        union
          select distinct organism, m.dataset_name, subtype, is_icemr, 'protocol' as property, 'display' as spec_property, 'Protocol' as spec_value
          from protocol_metadata m, icemr_mapping im
          where m.dataset_name = im.dataset_name
            and (is_icemr = 0 and m.dataset_name not like '%Crompton%')
        union
          select distinct organism, m.dataset_name, subtype, is_icemr, 'characteristic' as property, 'display' as spec_property, 'Characteristic' as spec_value
          from characteristic_metadata m, icemr_mapping im
          where m.dataset_name = im.dataset_name
            and (is_icemr = 0 and m.dataset_name not like '%Crompton%')
        union
          select otm.organism, otm.dataset_name, otm.subtype, otm.is_icemr,
                 child.name as property, 'parent' as spec_property, parent.name as spec_value
          from ontology_tree_metadata otm, leaf_ancestor_pair lap,
               (select child_term_id, parent_term_id from graph_edge
                union
                select term_id as child_term_id, null as parent_term_id from unparented_term) edge,
               sres.OntologyTerm child, sres.OntologyTerm parent
          where edge.child_term_id = lap.ancestor_term_id
            and lap.leaf_term_id = otm.term_id
            and edge.child_term_id = child.ontology_term_id
            and edge.parent_term_id = parent.ontology_term_id(+)
        -- fallback: parent
        union
          select organism, dataset_name, subtype, is_icemr, property, 'parent' as spec_property, '' as spec_value
          from fallback
        -- fallback: display
        union
          select organism, dataset_name, subtype, is_icemr, property, 'display' as spec_property, initcap(property) as spec_value
          from fallback
        -- fallback: filter
        union
          select organism, dataset_name, subtype, is_icemr, property, 'filter' as spec_property, 'membership' as spec_value
          from fallback
        -- fallback: leaf
        union
          select organism, dataset_name, subtype, is_icemr, property, 'leaf' as spec_property, 'true' as spec_value
          from fallback
        -- fallback: type
        union
          select organism, dataset_name, subtype, is_icemr, property, 'type' as spec_property, 'string' as spec_value
          from fallback
        ) order by organism, dataset_name, property, spec_property, spec_value
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index msix1&1
        on MetadataSpec&1 (dataset_name, organism, is_icemr, property, spec_property, spec_value)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="TranscriptPathway">
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="PathwayAttributes"/>
    <externalDependency name="sres.PathwayNode"/>
    <externalDependency name="dots.AaSequenceEnzymeClass"/>
    <externalDependency name="sres.EnzymeClass"/>
    <sql>
      <![CDATA[
       create table TranscriptPathway&1 nologging as
       with WildcardedPathwayNode
             as (select pn.pathway_id, replace(ec.ec_number, '-', '%') as ec_number
                 from sres.PathwayNode pn, sres.ontologyterm ot, SRES.ENZYMECLASS ec
                 where pn.pathway_node_type_id = ot.ontology_term_id
                 and pn.row_id = ec.enzyme_class_id
                 and ot.name = 'enzyme'),
             WildcardedEnzymeClass
             as (select enzyme_class_id, replace(ec_number, '-', '%') as ec_number
                 from sres.EnzymeClass)
       select distinct ga.source_id, ga.gene_source_id, p.source_id as pathway_source_id,
              p.name as pathway_name, replace(ec.ec_number, '%', '-') as ec_number, p.pathway_id
        from PathwayAttributes p, WildcardedPathwaynode pn, WildcardedEnzymeClass ec,
             dots.AaSequenceEnzymeClass asec, TranscriptAttributes ga
        where p.pathway_id = pn.pathway_id
          and (ec.ec_number like pn.ec_number
               or pn.ec_number like ec.ec_number)
          and asec.enzyme_class_id = ec.enzyme_class_id
          and ga.aa_sequence_id  = asec.aa_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index TranscriptPath_ix&1
        on TranscriptPathway&1(gene_source_id, source_id, pathway_source_id, pathway_name)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ProjectTaxon" prefixEnabled="true">
    <comment>map taxon names to project_ids. to be used by the apidb.project_id function</comment>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="apidb.Organism"/>
    <sql>
      <![CDATA[
        create table &prefixProjectTaxon&1 nologging as
        with
          local_taxon /* a taxon found in this instance, either in dots.ExternalNaSequence or in apidb.Organism */
          as (  select distinct tn.name as taxon,
                       substr((tn.name), 1, instr(tn.name||' ', ' ') - 1) as first_word,
                       pi.name as project_id
                from dots.ExternalNaSequence ens, sres.TaxonName tn, core.ProjectInfo pi
                where ens.taxon_id = tn.taxon_id
                  and tn.name_class = 'scientific name' 
                  and ens.row_project_id = pi.project_id
              /* get names from apidb.Organism.family_name_for_files
                 (may not be necessary) */
              union
                select family_name_for_files as taxon,
                       substr((family_name_for_files), 1, instr(family_name_for_files||' ', ' ') - 1) as first_word,
                       project_name as project_id
                from apidb.Organism
                where family_name_for_files in (select name from sres.TaxonName)
                ),
          mononym /* a taxon name that's the first word of a local taxon */
          as (select distinct lower(lt.first_word) as taxon, lt.project_id
              from local_taxon lt, sres.TaxonName tn
              where lt.first_word = tn.name
                and tn.name_class = 'scientific name'),
          full_name /* the full name of a local taxon whose first name is not a taxon */
          as (select distinct lower(lt.taxon) as taxon, lt.project_id
              from local_taxon lt, sres.TaxonName tn
              where lt.taxon = tn.name
                and tn.name_class = 'scientific name'
                and lower(lt.first_word) not in (select taxon from mononym))
          select * from mononym
        union
          select * from full_name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index data_load_prjct_error&1 on &prefixProjectTaxon&1 (taxon)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index projtax_ix&1 on &prefixProjectTaxon&1 (taxon, project_id)
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="OntologyLevels" prefixEnabled="true">
    <comment>the max and min depth of each ontology term in OntologyRelationship. Used by the GoTermSummary tuning table</comment>
    <externalDependency name="sres.OntologyRelationship"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        create table &prefixOntologyLevels&1 nologging as
        with is_a_links -- not closure, just real links
             as (select subject_term_id, object_term_id
                 from sres.OntologyRelationship rel, sres.OntologyTerm pred
                 where rel.predicate_term_id = pred.ontology_term_id
                   and pred.name = 'is_a'),
             roots -- terms with no parents
             as ( select object_term_id from is_a_links
                 minus
                  select subject_term_id from is_a_links),
             levels -- terms and all their depths, unaggregated
             as ( select object_term_id as ontology_term_id, 0 as depth from roots
                 union
                  select subject_term_id as ontology_term_id, level + 1 as depth
                  from is_a_links
                  start with object_term_id in (select object_term_id from roots)
                  connect by object_term_id = prior subject_term_id)
        select ontology_term_id, min(depth) as min_depth, max(depth) as max_depth
        from levels
        group by ontology_term_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index olev_termix&1 on &prefixOntologyLevels&1 (ontology_term_id, min_depth, max_depth)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="GoTermSummary" prefixEnabled="true">
    <comment>GoTermSummary: each row represents one GO term assignment to one gene.
         (Typically, a gene has multiple such assignments.) This is used for
          finding gene-GO mappings, such as for the gene-page GO table.
     </comment>
    <internalDependency name="OntologyLevels"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.GoAssociation"/>
    <externalDependency name="dots.GoAssociationInstance"/>
    <externalDependency name="dots.GoAssociationInstanceLoe"/>
    <externalDependency name="dots.GoAssocInstEvidCode"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="sres.OntologyRelationship"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        create table &prefixGoTermSummary&1 nologging as
        with root_term
             as (select ontology_term_id,
                        substr(decode(name, 'biological_process', 'Biological Process',
                                            'molecular_function', 'Molecular Function',
                                            'cellular_component', 'Cellular Component',
                                            name), 1, 20)
                          as ontology
                 from sres.OntologyTerm
                 where source_id in ('GO:0008150','GO:0003674','GO:0005575')),
             explicit_mapping
             as (select gf.source_id as gene_source_id, t.source_id as transcript_source_id, taf.aa_sequence_id,
                        decode(ga.is_not, 0, '', 1, 'not', ga.is_not) as is_not, substr(gt.source_id, 1, 25) as go_id,
                        gt.ontology_term_id as go_term_id, rt.ontology, substr(gt.name, 1, 250) AS go_term_name,
                        substr(gail.name, 1, 24) AS source, substr(gec.name, 1, 12) as evidence_code,
                        decode(gail.name, 'Interpro', 'InterPro predictions', 'Annotation Center')
                           as displayable_source
                 from dots.GeneFeature gf, dots.Transcript t, dots.TranslatedAaFeature taf, dots.GoAssociation ga,
                      sres.OntologyTerm gt, dots.GoAssociationInstance gai, dots.GoAssociationInstanceLoe gail,
                      dots.GoAssocInstEvidCode gaiec, sres.OntologyTerm gec, root_term rt
                 where t.parent_id = gf.na_feature_id
                   and t.na_feature_id = taf.na_feature_id
                   and taf.aa_sequence_id = ga.row_id
                   and ga.table_id = (select table_id
                                      from core.TableInfo
                                      where name = 'TranslatedAASequence')
                   and ga.go_term_id = gt.ontology_term_id
                   and ga.go_association_id = gai.go_association_id
                   and gai.go_assoc_inst_loe_id = gail.go_assoc_inst_loe_id
                   and gai.go_association_instance_id = gaiec.go_association_instance_id
                   and gaiec.go_evidence_code_id = gec.ontology_term_id
                   and gt.ancestor_term_id = rt.ontology_term_id(+))
        select em.gene_source_id, em.transcript_source_id, em.aa_sequence_id, em.is_not, em.go_id,
               em.go_term_id, em.ontology, em.go_term_name, em.source, em.evidence_code, em.displayable_source,
               cast (1 as number(1)) as is_leaf, ol.min_depth as depth
        from explicit_mapping em, &prefixOntologyLevels ol
             where em.go_term_id = ol.ontology_term_id(+)
        union
        select em.gene_source_id, em.transcript_source_id, em.aa_sequence_id, em.is_not,
               substr(ot.source_id, 1, 25) as go_id, ot.ontology_term_id as go_term_id, em.ontology,
               substr(ot.name, 1,250) as go_term_name, em.source, em.evidence_code, em.displayable_source,
               cast (1 as number(1)) as is_leaf, ol.min_depth as depth
        from explicit_mapping em, sres.OntologyRelationship orel, sres.OntologyTerm ot, &prefixOntologyLevels ol
        where em.go_term_id = orel.subject_term_id
          and orel.object_term_id = ot.ontology_term_id
          and ot.ontology_term_id = ol.ontology_term_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixGoTermSummary&1
        set is_leaf = 0
        where (aa_sequence_id, source, go_term_id)
              in (select gts.aa_sequence_id, gts.source, orel.object_term_id
                  from &prefixGoTermSummary&1 gts, sres.OntologyRelationship orel
                  where gts.go_term_id = orel.subject_term_id
                    and orel.subject_term_id != orel.object_term_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index GoTermSum_aaSeqId_idx&1 ON &prefixGoTermSummary&1 (aa_sequence_id, go_id, source, displayable_source)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="DatasetExampleSourceId">
    <comment> Each row maps a dataset onto an ID for which the dataset contains data;
         each dataset gets one such row.
         Used in dataset record queries.
      </comment>
    <externalDependency name="sres.ExternalDatabase"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="Profile"/>
    <sql>
      <![CDATA[
CREATE TABLE DatasetExampleSourceId&1 NOLOGGING AS
with profiles as (
select p.source_id,
       d.name,
       row_number() over(partition by d.name
                         order by ga.chromosome_order_num, p.profile_as_string desc) as rn
from Profile p, sres.ExternalDatabase d, GeneAttributes ga
where p.dataset_name = d.name
and p.profile_as_string is not null
and p.source_id = ga.source_id (+)
)
select p.source_id as example_source_id,
       p.name as dataset
from profiles p
where p.rn = 1
      ]]>
    </sql>
  </tuningTable>



  <tuningTable name="TranscriptWord">
    <comment> Each row maps a gene source_id to all words found in the gene's product field
         Used in the word enrichment analysis plugin
         The trick sql was cribbed and modified from: nuijten.blogspot.com/2011/08/splitting-comma-delimited-string-regexp.html
      </comment>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
        create table TranscriptWord&1 nologging as
        select source_id, taxon_id,
               /* for each rn (1 - max_words_in_any_product), */
               /*    print the rn-th word. */
               /*    replace leading and trailing parens with empty string, eg (RIFN) becomes RIFN */
               substr(regexp_replace(regexp_substr (gene_product, '[^ ,]+', 1, rn), '[\)\(]', ''), 1, 200) word
        from TranscriptAttributes
        cross
               /* create a table of integers 1 - n where n is the max number of words in any product */
        join (select rownum rn
              from (select max (regexp_count (gene_product, '[ ,]')) + 1 mx
                    from TranscriptAttributes)
              connect by level <= mx
             )
        where regexp_substr (gene_product, '[^, ]+', 1, rn) is not null
        order by source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index TranscripWord_idx&1 ON TranscriptWord&1 (source_id)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>



  <tuningTable name="OrganismAttributes">
    <comment> Stores per-organism information. Used by the organism record, as well
         as by project_id(), the function that maps an organism to a project.
      </comment>
    <internalDependency name="TaxonSpecies"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="GeneId"/>
    <internalDependency name="PopsetAttributes"/>
    <internalDependency name="GoTermSummary"/>
    <internalDependency name="ChIPchipTranscript"/>
    <internalDependency name="TFBSGene"/>
    <internalDependency name="EstAlignmentGeneSummary"/>
    <internalDependency name="EstAttributes"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <internalDependency name="Profile"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.NaLocation"/>
    <externalDependency name="apidb.PhylogeneticProfile"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="dots.SnpFeature"/>
    <intermediateTable name="DataSourceCount"/>
    <intermediateTable name="CommunityCount"/>
    <intermediateTable name="ProfileCount"/>
    <intermediateTable name="PopsetCount"/>
    <intermediateTable name="GeneCount"/>

    <sql>
      <![CDATA[
CREATE TABLE DataSourceCount nologging as ( 
        SELECT ds.taxon_id,
               max(case when ds.type = 'organellar_genome' 
                     then 1 
                     else 0 end) as isOrganellar,
               max(case when ds.type = 'isolates'
                         AND ds.subtype = 'HTS_SNP' 
                     then 1 
                     else 0 end) as hasHTSIsolate,
               max(case when ds.type = 'isolates'
                         AND ds.subtype = 'sequenceing_types' 
                     then 1 
                     else 0 end) as hasPopset,      
               max(case when ds.type = 'epitope'
                     then 1 
                     else 0 end) as hasEpitope,     
               max(case when ds.type = 'transcript_expression'
                         AND ds.subtype = 'array'                       
                     then 1 
                     else 0 end) as hasArray                      
        FROM   apidb.DataSource ds
          group by ds.taxon_id
         )
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create table CommunityCount nologging as
       select taxon_id, count(*) as communityCount
       from GeneAttributes
       where (source_id, project_id)
              in (select distinct stable_id, project_name
                  from userlogins5.mappedComment@prodn.login_comment
                  where is_visible = 1
                    and comment_target_id = 'gene')
       group by taxon_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE ProfileCount nologging as (
        select ga.taxon_id,         
                            count(distinct(case when p.dataset_type = 'transcript_expression'
                                   and p.dataset_subtype like '%rt_pcr%' 
                                   and ga.is_deprecated = 0 
                                  then p.source_id
                                  else ''
                                   end)) as rtPCRCount,     
              count(distinct(case when p.dataset_type = 'transcript_expression'
                                   and p.dataset_subtype = 'rnaseq'
                                   and ga.is_deprecated = 0 
                                  then p.source_id
                                  else ''
                                   end)) as rnaSeqCount,
              count(distinct(case when p.dataset_type = 'transcript_expression'
                                   and p.dataset_subtype = 'array'
                                   and ga.is_deprecated = 0 
                                  then p.source_id
                                  else ''
                                   end)) as geneArrayCount
         from Profile p
              right outer join GeneAttributes ga on ga.source_id = p.source_id
         group by ga.taxon_id
)       
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE PopsetCount nologging as (    
        SELECT count(distinct gene.source_id) as popsetCount, sim.taxon_id
        FROM (
          (SELECT i.source_id, tn.taxon_id, nas.source_id as sequence_source_id
           FROM dots.similarity s,
                PopsetAttributes i,
                core.tableinfo t, dots.nasequence nas, sres.taxonname tn
           WHERE s.query_id = i.na_sequence_id
             AND nas.na_sequence_id = s.subject_id
             AND t.table_id = s.subject_table_id
             AND t.table_id = s.query_table_id
             AND t.name = 'ExternalNASequence'
             AND tn.taxon_id = nas.taxon_id
             AND tn.name_class = 'scientific name'
             AND s.pvalue_exp <= -10
           ) sim left join
           (SELECT i.source_id, seq.source_id as sequence_id
            FROM  dots.similarity s, PopsetAttributes i,
                  GeneAttributes g, 
                  core.tableinfo t, dots.nalocation l, dots.nasequence seq
            WHERE s.query_id = i.na_sequence_id
              AND s.subject_id = g.na_sequence_id
              AND t.table_id = s.subject_table_id
              AND t.table_id = s.query_table_id
              AND s.min_subject_start <=  l.end_max
              AND s.max_subject_end >= l.start_min
              AND l.na_feature_id = g.na_feature_id
              AND g.na_sequence_id = seq.na_sequence_id
              AND t.name = 'ExternalNASequence'
            ) gene
           on gene.source_id = sim.source_id and gene.sequence_id = sim.sequence_source_id)
         GROUP BY sim.taxon_id
)
       
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE GeneCount nologging as (    
select genomestat.taxon_id,
       genomestat.project_id,
       genomestat.database_version,
       genomestat.ncbi_tax_id,
       genomestat.Megabps,
       nvl(snpCount.ct,0) as snpCount,
       nvl(count(distinct ga.source_id),0) as geneCount,
       nvl(count(distinct case when ga.is_pseudo =1  then ga.source_id else '' end),0) as pseudoGeneCount,    
       nvl(count(distinct case when ga.gene_type ='protein coding' then ga.source_id else '' end),0) as codingGeneCount,
       nvl(count(distinct case when ga.gene_type ='protein coding' then '' else ga.source_id end),0) as otherGeneCount, 
       nvl(count (distinct (case when ga.is_deprecated = 0
                  then cct.gene_source_id
                  else NULL 
                  end)),0) ChipChipGeneCount ,
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then pp.source_id
                  else NULL 
                  end)),0) orthologCount, 
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then gts.gene_source_id
                  else NULL 
                  end)),0) goCount, 
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then tfbs.gene_source_id
                  else NULL 
                  end)),0) tfbsCount, 
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then mss.aa_sequence_id
                  else NULL 
                  end)),0) proteomicsCount, 
      nvl(count (distinct (case when ga.is_deprecated = 0
                  then est.source_id
                  else NULL 
                  end)),0) estCount,
      nvl(count (distinct (case when (ga.is_deprecated = 0 and ta.ec_numbers is not null)
                  then ga.source_id 
                  else NULL 
                  end)),0) ecNumberCount
        FROM   GeneAttributes ga
               left outer join apidb.phylogeneticprofile pp on ga.source_id = pp.source_id
               left outer join gotermsummary gts on ga.source_id = gts.gene_source_id
               left outer join TFBSGene tfbs on ga.source_id = tfbs.gene_source_id
               left outer join TranscriptAttributes ta on ta.gene_source_id = ga.source_id
               left outer join apidb.MassSpecSummary mss on ta.aa_sequence_id = mss.aa_sequence_id
               left outer join chipchipTranscript cct on ga.source_id = cct.gene_source_id
               left outer join (SELECT distinct s.gene as source_id 
                                  FROM EstAlignmentGeneSummary s, EstAttributes e 
                                  WHERE s.est_gene_overlap_length >= 100 
                                    AND s.is_best_alignment in (1) 
                                    AND s.percent_est_bases_aligned >= 20  
                                    AND s.percent_identity >= 90  
                                    AND e.best_alignment_count <= 1 
                                    AND e.source_id = s.accession   
                                    GROUP by s.gene HAVING count(*) >= 1) est on ga.source_id = est.source_id
          right outer join
         ( SELECT  project_id, taxon_id,
                 max(database_version) as database_version,
                CASE WHEN ncbi_tax_id > 9000000000 THEN NULL
                     ELSE ncbi_tax_id
                END ncbi_tax_id, 
                to_char(sum(length)/1000000,'9999.99') as megabps 
         FROM   GenomicSeqAttributes 
         WHERE  is_top_level = 1
         GROUP BY project_ID, taxon_id, ncbi_tax_id
       ) genomestat on genomestat.taxon_id = ga.taxon_id
        left outer join       
      (
       SELECT count(distinct ga.source_id) as ct, ga.taxon_id 
       FROM GeneAttributes ga, dots.snpfeature sf  
       WHERE sf.parent_id = ga.na_feature_id 
         AND ga.is_deprecated = 0 
       GROUP BY ga.taxon_id 
      ) snpCount on ga.taxon_id = snpCount.taxon_id
        group by genomestat.taxon_id,
                 genomestat.project_id,
                 genomestat.database_version,
                 genomestat.ncbi_tax_id,
                 genomestat.Megabps,
                 snpCount.ct
)
       
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE OrganismAttributes&1 NOLOGGING AS
SELECT oa.*, tn2.name as species, replace(oa.organism_name, tn2.name) as strain
FROM
(
SELECT o.project_name as project_id,
       o.public_abbrev as source_id,
       o.family_name_for_files,
       tn.name as organism_name,
       o.genome_source,
       /*o.strain_abbrev, */
       o.is_annotated_genome,
       o.is_reference_strain,
       o.is_family_representative,
       o.name_for_filenames,
       o.taxon_id as component_taxon_id,
       gc.database_version,
       gc.megabps as megabps,
       gc.ncbi_tax_id as ncbi_tax_id,
       gc.snpCount as snpCount,
       gc.geneCount as geneCount,
       gc.pseudoGeneCount as pseudoGeneCount,
       gc.codingGeneCount as codingGeneCount,
       gc.otherGeneCount as otherGeneCount,
       gc.ChipChipGeneCount as ChipChipGeneCount,
       gc.orthologCount as orthologCount,
       gc.goCount as goCount,    
       gc.tfbsCount as tfbsCount,
       gc.proteomicsCount as proteomicsCount,
       gc.estCount as estCount,
       gc.ecNumberCount as ecNumberCount,
       nvl(dsc.isOrganellar, 0) as isOrganellar,
       nvl(dsc.hasHTSIsolate, 0) as hasHTSIsolate, 
       nvl(dsc.hasPopset, 0) as hasPopset,
       nvl(dsc.hasEpitope, 0) as hasEpitope,
       nvl(dsc.hasArray, 0) as hasArray,
       nvl(cc.communityCount, 0) as communityCount,
       nvl(psc.popsetCount, 0) as popsetCount,
       nvl(pc.geneArrayCount, 0) as arrayGeneCount,
       nvl(pc.rnaSeqCount, 0) as rnaSeqCount,
       nvl(pc.rtPCRCount, 0) as rtPCRCount
FROM   apidb.Organism o,
       sres.TaxonName tn,
       DataSourceCount dsc,
       CommunityCount cc,
       GeneCount gc,
       popsetCount psc,
       profileCount pc
WHERE tn.taxon_id = o.taxon_id
  AND tn.name_class = 'scientific name' 
  AND o.taxon_id = dsc.taxon_id (+)
  AND o.taxon_id = cc.taxon_id (+)
  AND o.taxon_id = gc.taxon_id (+)
  AND o.taxon_id = psc.taxon_id (+)
  AND o.taxon_id = pc.taxon_id (+)
) oa,
  TaxonSpecies ts,
  sres.taxon t,
  sres.taxonname tn2
where oa.component_taxon_id = ts.taxon_id
and ts.species_taxon_id = t.taxon_id
and ts.species_taxon_id = tn2.taxon_id
and tn2.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Organism_sourceId_idx&1 ON OrganismAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="PdbSimilarity">
    <comment> Each record maps a gene to a PDB structure. Used by the model to find
         genes that have a PDB structure and to find the PDB structures for a
         given gene.
      </comment>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.ExternalAaSequence"/>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE PdbSimilarity&1 NOLOGGING AS
SELECT t.source_id, eas.source_id AS pdb_chain,
       substr(eas.description, 1, 100) AS pdb_title,
       substr(eas.source_id, 1,
              instr(eas.source_id, '_', -1) - 1)
         AS pdb_id,
       s.pvalue_mant, s.pvalue_exp, 
       SUBSTR(tn.name, 1, 100) AS taxon,
       ROUND( (s.number_identical / s.total_match_length) * 100)
         AS percent_identity,
       ROUND( (s.total_match_length / tas.length) * 100)
         AS percent_plasmo_coverage,
       s.score, eas.taxon_id as pdb_taxon_id, tas.taxon_id as gene_taxon_id
FROM dots.TranslatedAaFeature taf,
     dots.TranslatedAaSequence tas, core.TableInfo tas_ti,
     dots.Similarity s, core.TableInfo eas_ti,
     dots.ExternalAaSequence eas,
     sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
     sres.TaxonName tn, dots.transcript t
WHERE taf.aa_sequence_id = tas.aa_sequence_id
  AND tas_ti.name = 'TranslatedAASequence'
  AND tas_ti.table_id = s.query_table_id
  AND s.query_id = tas.aa_sequence_id
  AND eas_ti.name = 'ExternalAASequence'
  AND eas_ti.table_id = s.subject_table_id
  AND s.subject_id = eas.aa_sequence_id
  AND tn.name_class = 'scientific name'
  AND eas.external_database_release_id
      = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ed.name in ('PDBProteinSequences_RSRC','PDB protein sequences')
  AND eas.taxon_id = tn.taxon_id
  AND t.na_feature_id = taf.na_feature_id
ORDER BY taf.source_id, eas.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index PdbSim_sourceId_ix&1
ON PdbSimilarity&1 (source_id, score DESC)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SequencePieceClosure" prefixEnabled="true">
    <comment>Extends dots.SequencePiece to handle multiple levels. Used in
         sequence-record queries and in other tuning tables, including
         GenomicSeqAttributes, FeatureLocation, BlatAlignmentLocation,
         and SimilaritySpanLocation
     </comment>
    <externalDependency name="dots.SequencePiece"/>
    <sql>
      <![CDATA[
        create table &prefixSequencePieceClosure&1 nologging as
        select sp.sequence_piece_id,
               sp.virtual_na_sequence_id,
               sp.piece_na_sequence_id, 
               sp.sequence_order, 
               sp.distance_from_left,
               sp.uncertainty,
               sp.strand_orientation,
               sp.start_position,
               sp.end_position, 
               sp.modification_date,
               1 as edge_level
        from dots.SequencePiece sp, dots.NaSequence ns
        where sp.piece_na_sequence_id = ns.na_sequence_id
          and (ns.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        /* known issue: this should be run not just once, but iteratively
           until it doesn't create new records.  Currently (7/2008),
           SequencePieces aren't nested even once. */
        insert into &prefixSequencePieceClosure&1
                    (edge_level, virtual_na_sequence_id, piece_na_sequence_id,
                     distance_from_left, strand_orientation, modification_date, 
                     start_position, end_position, sequence_order, sequence_piece_id)
        select 2, higher.virtual_na_sequence_id, lower.piece_na_sequence_id,
               higher.distance_from_left,
               case
                 when nvl(higher.strand_orientation, '+') = nvl(lower.strand_orientation, '+')
                 then '+'
                 else '-'
               end as strand_orientation,
               sysdate,
               higher.start_position - lower.distance_from_left, 
               higher.end_position - lower.distance_from_left, 
               higher.sequence_order,
               dots.sequencepiece_sq.nextval
        from &prefixSequencePieceClosure&1 higher, &prefixSequencePieceClosure&1 lower
        where higher.piece_na_sequence_id = lower.virtual_na_sequence_id
         and higher.start_position >= lower.start_position + lower.distance_from_left
         and higher.end_position <= lower.end_position + lower.distance_from_left
      ]]>
    </sql>
  </tuningTable>



  <tuningTable name="FeatureLocation" prefixEnabled="true">
    <comment>Addresses a performance problem with feature location queries, namely
         that the sequence and the location on that sequence are in different
         tables, so it's impossible to create an index on the whole shebang.
         Used by both model and GBrowse queries, as well as inputs to a
         dozen-odd other tuning tables.
     </comment>
    <internalDependency name="SequencePieceClosure"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <internalDependency name="TranscriptLocation"/>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="dots.ExonFeature"/>
    <externalDependency name="dots.NaFeature"/>
    <externalDependency name="dots.NaLocation"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
create table &prefixFeatureLocation&1 NOLOGGING as
    with project_mapping AS
       (select distinct tn.name AS organism,  pi.name as project
        from sres.TaxonName tn, dots.NaSequence na, 
        core.ProjectInfo pi
        where tn.name_class = 'scientific name'
          and tn.taxon_id = na.taxon_id
          and na.row_project_id = pi.project_id
          )
select case
         when nf.subclass_view = 'GeneFeature'
              and nf.is_predicted = 1
           then 'GenePrediction'
         when nf.subclass_view = 'Miscellaneous' 
              and nf.is_predicted = 1
           then 'Prediction'
         else nf.subclass_view
       end as feature_type,
       nf.source_id as feature_source_id, ns.source_id as sequence_source_id,
       nf.na_sequence_id, nf.na_feature_id,
       least(nl.start_min, nl.end_max) as start_min,
       greatest(nl.start_min, nl.end_max) as end_max,
       nl.is_reversed, nf.parent_id, nf.sequence_ontology_id,
       cast (null as number) as is_top_level, -- ef.coding_start, ef.coding_end,
       nf.external_database_release_id,
       (select project from project_mapping where organism = tn.name) as project_id
from dots.NaFeature nf, dots.NaLocation nl, &prefixGenomicSeqAttributes ns,
     dots.ExonFeature ef, sres.TaxonName tn
where nf.na_feature_id = nl.na_feature_id
  and nf.na_sequence_id = ns.na_sequence_id
  and nl.na_feature_id = ef.na_feature_id(+)
  and ns.taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
  and nf.subclass_view not in ('GeneFeature', 'ExonFeature', 'Transcript')
  and (ns.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
union
select /* virtual feature locations mapped through SequencePiece */
       case
         when nf.subclass_view = 'GeneFeature'
              and nf.is_predicted = 1
           then 'GenePrediction'
         else nf.subclass_view
       end as feature_type,
       nf.source_id as feature_source_id, scaffold.source_id as sequence_source_id,
       sp.virtual_na_sequence_id, nf.na_feature_id,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - greatest(nl.start_min, nl.start_max, nl.end_min, nl.end_max)  + 1
           else sp.distance_from_left + least(nl.start_min, nl.start_max, nl.end_min, nl.end_max) - sp.start_position  + 1
       end as start_min,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - least(nl.start_min, nl.start_max, nl.end_min, nl.end_max) + 1
         else sp.distance_from_left + greatest(nl.start_min, nl.start_max, nl.end_min, nl.end_max) - sp.start_position + 1
       end as end_max,
       case
         when sp.strand_orientation in ('-', '-1')
         then decode(nvl(nl.is_reversed, 0),
                     0, 1,  1, 0,  1)
         else nl.is_reversed
       end as is_reversed,
       nf.parent_id, nf.sequence_ontology_id,
       cast (null as number) as is_top_level,
--        case
--          when sp.strand_orientation in ('-', '-1')
--            then sp.distance_from_left + sp.end_position - coding_start + 1
--            else sp.distance_from_left + ef.coding_start - sp.start_position + 1
--        end as coding_start,
--        case
--          when sp.strand_orientation in ('-', '-1')
--            then sp.distance_from_left + sp.end_position - coding_end + 1
--          else sp.distance_from_left + coding_end - sp.start_position + 1
--        end as coding_end,
        nf.external_database_release_id,
       (select project from project_mapping where organism = tn.name) as project_id
from dots.NaFeature nf, dots.NaLocation nl, &prefixGenomicSeqAttributes contig,
     &prefixSequencePieceClosure sp, &prefixGenomicSeqAttributes scaffold, dots.ExonFeature ef,
     sres.TaxonName tn
where nf.na_feature_id = nl.na_feature_id
  and nf.na_sequence_id = contig.na_sequence_id
  and nf.na_sequence_id = sp.piece_na_sequence_id
  and sp.start_position <= nl.start_min
  and sp.end_position >= nl.end_max
  and sp.virtual_na_sequence_id = scaffold.na_sequence_id
  and nl.na_feature_id = ef.na_feature_id(+)
  and contig.taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
  and nf.subclass_view not in ('GeneFeature', 'ExonFeature', 'Transcript')
  and (contig.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
      ]]>
    </sql>
    <sql>
      <![CDATA[
update &prefixFeatureLocation&1
set is_top_level = 1
      ]]>
    </sql>
    <sql>
      <![CDATA[
update &prefixFeatureLocation&1 fl
set is_top_level = 0 
where na_sequence_id in (select distinct piece_na_sequence_id 
                         from &prefixSequencePieceClosure spc
                         where fl.start_min >= spc.start_position
                         and fl.end_max <= spc.end_position)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        insert into &prefixFeatureLocation&1
                    (feature_type, feature_source_id, sequence_source_id,
                     na_sequence_id, na_feature_id, start_min, end_max,
                    is_reversed, is_top_level)
        select 'GeneFeature', feature_source_id, sequence_source_id,
               na_sequence_id, na_feature_id, start_min, end_max,
               is_reversed, is_top_level
        from &prefixGeneLocation
      ]]>
    </sql>
    <sql>
      <![CDATA[
        insert into &prefixFeatureLocation&1
                    (feature_type, feature_source_id, sequence_source_id,
                     na_sequence_id, na_feature_id, start_min, end_max,
                    is_reversed, parent_id, is_top_level)
        select 'Transcript', feature_source_id, sequence_source_id,
               na_sequence_id, na_feature_id, start_min, end_max,
               is_reversed, parent_id, is_top_level
        from &prefixTranscriptLocation
      ]]>
    </sql>
    <sql>
      <![CDATA[
        insert into &prefixFeatureLocation&1
                    (feature_type, sequence_source_id, na_feature_id,
                     na_sequence_id, start_min, end_max,
                     is_reversed, parent_id, is_top_level)
        select 'ExonFeature', sequence_source_id, na_feature_id,
               na_sequence_id, start_min, end_max,
               is_reversed, parent_id, is_top_level
        from &prefixExonLocation
      ]]>
    </sql>
    <sql>
      <![CDATA[
        insert into &prefixFeatureLocation&1
                    (feature_type, sequence_source_id,
                     na_sequence_id, start_min, end_max,
                     is_reversed, parent_id, is_top_level)
        select 'CDS', sequence_source_id,
               na_sequence_id, start_min, end_max,
               is_reversed, parent_id, is_top_level
        from &prefixCdsLocation
      ]]>
    </sql>
    <sql>
      <![CDATA[
        insert into &prefixFeatureLocation&1
                    (feature_type, sequence_source_id,
                     na_sequence_id, start_min, end_max,
                     is_reversed, parent_id, is_top_level)
        select 'UTR', sequence_source_id,
               na_sequence_id, start_min, end_max,
               is_reversed, parent_id, is_top_level
        from &prefixUtrLocation
      ]]>
    </sql>

    <sql>
      <![CDATA[
        insert into &prefixFeatureLocation&1
                    (feature_type, sequence_source_id,
                     na_sequence_id, start_min, end_max,
                     is_reversed, parent_id, is_top_level)
        select 'Intron', sequence_source_id,
               na_sequence_id, start_min, end_max,
               is_reversed, parent_id, is_top_level
        from &prefixIntronLocation
      ]]>
    </sql>

    <sql>
      <![CDATA[
create index featloc_ix&1 on &prefixFeatureLocation&1
             (feature_type, na_sequence_id, start_min, end_max, is_reversed, feature_source_id, na_feature_id,external_database_release_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc2_ix&1 on &prefixFeatureLocation&1
             (na_sequence_id, start_min, end_max, is_reversed, sequence_ontology_id, na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc3_ix&1 on &prefixFeatureLocation&1
             (na_feature_id, na_sequence_id, is_top_level)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc4_ix&1 on &prefixFeatureLocation&1
             (feature_type, is_top_level, sequence_ontology_id, na_feature_id, feature_source_id, na_sequence_id, start_min , end_max)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc5_ix&1
on &prefixFeatureLocation&1 
(na_sequence_id, feature_type, start_min, end_max, parent_id, na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc6_ix&1 on &prefixFeatureLocation&1 (feature_source_id, is_top_level, na_sequence_id, is_reversed)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc7_ix&1 on &prefixFeatureLocation&1
             (feature_type, sequence_source_id, start_min, is_reversed, end_max, feature_source_id, na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index featloc_parent_ix&1 on &prefixFeatureLocation&1
             (parent_id, na_feature_id, is_reversed, na_sequence_id, feature_type)
tablespace indx
      ]]>
    </sql>
  </tuningTable>
  <tuningTable name="GeneId" prefixEnabled="true">
  <comment>GeneId maps any valid ID for a gene onto its official ID. These two quantities
       are stored in the "id" and "gene" columns, respectively. The "unique_mapping"
       column is set to 1 for IDs which map to only one gene.

       Most of the CREATE TABLE statement is made up of the union of nine subqueries,
       each of which looks in a different place for gene IDs. Each subquery populates
       the "union_member" field with a different literal string, to make it easier to
       understand which part (or parts) of the SQL is responsible for each ID-to-gene
       mapping.
   </comment>
    <internalDependency name="FeatureLocation"/>
    <externalDependency name="apidb.GeneFeatureName"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.NaFeatureNaGene"/>
    <externalDependency name="dots.NaGene"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <intermediateTable name="CommentAssignment"/>
    <intermediateTable name="NewCsi"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixGeneId&1 NOLOGGING AS
SELECT substr(mapping.id, 1, 100) as id, mapping.gene, cast (null as NUMBER) as unique_mapping,
       SUBSTR(apidb.tab_to_string(set(CAST(COLLECT(union_member order by union_member) AS apidb.varchartab)),'; '), 1, 100) as union_member, 
       SUBSTR(apidb.tab_to_string(set(CAST(COLLECT(database_name order by database_name) AS apidb.varchartab)),'; '), 1, 200) as database_name
/*   we would use listagg() as follows, but it repeats duplicate values, and doesn't provide a way to aggregate DISTINCT values. (lame!)
         substr(listagg(union_member, '; ') within group (order by union_member), 1, 100) as union_member,
         substr(listagg(database_name, '; ') within group (order by database_name), 1, 200) as database_name */
FROM (SELECT substr(t.protein_id, 1, instr(t.protein_id, '.') - 1) AS id,
             gf.source_id AS gene,
             'Transcript.protein_id before dot' as union_member, ed.name as database_name /* dots.Transcript.protein_id, trimmed at period */
      FROM dots.Transcript t, dots.GeneFeature gf,
           sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      WHERE t.parent_id = gf.na_feature_id
        AND substr(t.protein_id, 1, instr(t.protein_id, '.') - 1) IS NOT NULL
        AND gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT t.protein_id AS id,
             gf.source_id AS gene,
             'Transcript.protein_id' as union_member, ed.name as database_name /* dots.Transcript.protein_id */
      FROM dots.Transcript t, dots.GeneFeature gf,
           sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      WHERE t.parent_id = gf.na_feature_id
        AND t.protein_id IS NOT NULL
        AND gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT dr.primary_identifier AS id, 
             gf.source_id AS gene,
             'DbRef.primary_identifier' as union_member, ed.name as database_name /* sres.DbRef.primary_identifier */
      FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
           sres.ExternalDatabase ed
      WHERE dr.primary_identifier IS NOT NULL
        AND gf.na_feature_id = drnf.na_feature_id
        AND drnf.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
              = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND  NOT (ed.name in ('NRDB_gb_dbXRefBySeqIdentity','NRDB_ref_dbXRefBySeqIdentity')  
                                  AND NOT  REGEXP_LIKE (dr.primary_identifier, '\D') )
        AND  NOT edr.id_type = 'synonym'
     UNION
     SELECT dr.primary_identifier AS id, 
             gf.source_id AS gene,
             'synonym' as union_member, ed.name as database_name
      FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
           sres.ExternalDatabase ed
      WHERE dr.primary_identifier IS NOT NULL
        AND gf.na_feature_id = drnf.na_feature_id
        AND drnf.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND edr.id_type  = 'synonym'
     UNION
      SELECT dr.secondary_identifier AS id, 
             gf.source_id AS gene,
             'DbRef.secondary_identifier' as union_member, ed.name as database_name /* sres.DbRef.secondary_identifier */
      FROM dots.GeneFeature gf, dots.DbRefNaFeature drnf,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
           sres.ExternalDatabase ed
      WHERE dr.secondary_identifier IS NOT NULL
        AND gf.na_feature_id = drnf.na_feature_id
        AND drnf.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
              = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND ed.name IN ('NRDB_gb_dbXRefBySeqIdentity',
                        'NRDB_pdb_dbXRefBySeqIdentity',
                        'NRDB_ref_dbXRefBySeqIdentity',
                        'NRDB_sp_dbXRefBySeqIdentity',
                        'Predicted protein structures','Pf_predictedProteinStructures_RSRC',
                        'GenBank')
     UNION
      SELECT dr.primary_identifier AS id, 
             gf.source_id AS gene,
             'genbank DbRef.primary_identifier' as union_member, ed.name as database_name /* sres.DbRef.primary_identifier for Genbank records */
      FROM dots.GeneFeature gf, dots.Transcript t, dots.DbRefNaSequence drns,
           sres.DbRef dr, sres.ExternalDatabaseRelease edr,
            sres.ExternalDatabase ed
      WHERE gf.na_feature_id = t.parent_id
        AND t.na_sequence_id = drns.na_sequence_id
        AND drns.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
        AND ed.name = 'GenBank'
     UNION
      SELECT pred_loc.feature_source_id AS id,
             gene_loc.feature_source_id AS gene,
             'overlapping predicted gene source_id' as union_member, ed.name as database_name /* dots.GeneFeature.source_id for predicted genes that overlap */
      FROM &prefixFeatureLocation gene_loc, &prefixFeatureLocation pred_loc,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      WHERE pred_loc.feature_type = 'GenePrediction'
        AND gene_loc.feature_type = 'GeneFeature'
        AND pred_loc.na_sequence_id = gene_loc.na_sequence_id
        AND gene_loc.start_min <= pred_loc.end_max
        AND gene_loc.end_max >= pred_loc.start_min
        AND pred_loc.is_reversed = gene_loc.is_reversed
        AND pred_loc.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT ng.name AS id, gf.source_id AS gene,
             'NaGene' as union_member, ed.name as database_name /* dots.NaGene.name */
      FROM dots.GeneFeature gf, dots.NaFeatureNaGene nfng, dots.NaGene ng,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      WHERE gf.na_feature_id = nfng.na_feature_id
        AND ng.na_gene_id = nfng.na_gene_id
        AND gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT source_id AS id, source_id AS gene,
             'same ID' as union_member, ed.name as database_name /* same ID (reflexive mapping) */
      FROM dots.GeneFeature gf,
           sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      WHERE gf.external_database_release_id = edr.external_database_release_id
        AND edr.external_database_id = ed.external_database_id
     UNION
      SELECT n.name AS id, gf.source_id AS gene,
             'gene name' as union_member, d.name as database_name /* apidb.GeneFeatureName.name */
      from apidb.GeneFeatureName n, dots.genefeature gf, sres.ExternalDatabaseRelease r, sres.ExternalDatabase d
      where n.na_feature_id = gf.na_feature_id
        and gf.external_database_release_id =r.external_database_release_id
        and r.external_database_id = d.external_database_id
        and n.is_preferred = 1) mapping,
      dots.GeneFeature gf, dots.NaSequence ns
where mapping.gene = gf.source_id
  and gf.na_sequence_id = ns.na_sequence_id
  and (ns.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
  and (gf.is_predicted != 1 OR gf.is_predicted is null)
group by mapping.id, mapping.gene
      ]]>
    </sql>
    <sql>
      <![CDATA[
update &prefixGeneId&1
set unique_mapping = 1
where lower(id) in (select lower_id
                    from (select distinct lower(id) as lower_id, gene
                          from &prefixGeneId&1) case_independent_mapping
                    group by lower_id
                    having count(*) = 1)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_gene_idx&1 ON &prefixGeneId&1 (gene, id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_id_idx&1 ON &prefixGeneId&1 (id, gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_uniqid_idx&1 ON &prefixGeneId&1 (unique_mapping, id, gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_lowid_idx&1 ON &prefixGeneId&1 (lower(id), gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GeneId_uniqlowid_idx&1 ON &prefixGeneId&1 (unique_mapping, lower(id), gene)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE &prefixCommentAssignment NOLOGGING AS
WITH projects AS
       (SELECT DISTINCT project_id FROM &prefixFeatureLocation), 
     project_comments AS
       (SELECT stable_id, comment_id
        FROM userlogins5.comments@&dblink
        WHERE project_name in (select project_id FROM projects)
          AND comment_target_id = 'gene')
  SELECT stable_id, comment_id
  FROM project_comments
UNION
  SELECT csi.stable_id, csi.comment_id
  FROM project_comments pc, userlogins5.commentStableId@&dblink csi
  WHERE csi.comment_id = pc.comment_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE &prefixNewCsi nologging as
SELECT stable_id, comment_id, userlogins5.CommentStableId_pkseq.nextval@&dblink as comment_stable_id
FROM (  SELECT gi.gene AS stable_id, ca.comment_id
        FROM &prefixGeneId&1 gi, &prefixCommentAssignment ca
        WHERE gi.id = ca.stable_id
          AND gi.id != gi.gene
      MINUS
        SELECT stable_id, comment_id
        FROM &prefixCommentAssignment ca)
      ]]>
    </sql>
    <sql>
      <![CDATA[
INSERT INTO userlogins5.CommentStableId@&dblink
           (stable_id, comment_id, comment_stable_id)
SELECT stable_id, comment_id, comment_stable_id
FROM &prefixNewCsi
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GenomicSequenceId">
  <comment> This table maps IDs for a sequence onto the official ID of the sequence.
       It is analogous to GeneId, which does the same thing for genes. Used by
       genomic-sequence record queries, by the sequence retrieval tool, and by
       the BasketFixer, which updates users' baskets at release time to replace
       old IDs with updated ones.
    </comment>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
CREATE TABLE GenomicSequenceId&1 NOLOGGING AS
SELECT DISTINCT substr(id, 1, 60) as id, substr(sequence, 1, 60) AS sequence
FROM (
  SELECT ns.source_id as id, ns.source_id as sequence
  FROM dots.NaSequence ns, sres.OntologyTerm oterm
  WHERE ns.sequence_ontology_id = oterm.ontology_term_id
    AND oterm.name in ('random_sequence', 'contig', 'supercontig', 'chromosome','mitochondrial_chromosome','plastid_sequence','cloned_genomic','apicoplast_chromosome')
UNION
  SELECT dr.primary_identifier AS id, ns.source_id AS sequence
  FROM dots.NaSequence ns, dots.DbRefNaSequence drnf,
       sres.DbRef dr, sres.ExternalDatabaseRelease edr,
       sres.ExternalDatabase ed
  WHERE dr.primary_identifier IS NOT NULL
    AND ns.na_sequence_id = drnf.na_sequence_id
    AND drnf.db_ref_id = dr.db_ref_id
    AND dr.external_database_release_id
          = edr.external_database_release_id
    AND edr.external_database_id = ed.external_database_id
)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GenSeqId_sequence_idx&1 ON GenomicSequenceId&1 (sequence, id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GenSeqId_id_idx&1 ON GenomicSequenceId&1 (id, sequence)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX GenSeqId_lowid_idx&1 ON GenomicSequenceId&1 (lower(id), sequence)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EpitopeSummary">
    <comment> Used by GeneTables.Epitopes to map a gene to its epitopes.
     </comment>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.EpitopeFeature"/>
    <externalDependency name="dots.MotifAaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE EpitopeSummary&1 NOLOGGING AS
SELECT t.source_id, 
              al.start_min||'-'||al.end_max AS location,
              ef.source_id as iedb_id,
       mas.sequence, 
       SUBSTR(tn.name, 1, 100) AS name,
       DECODE(ef.type, 'Not Full Set Not on Blast Hit', 'Low',
                       'Not Full Set On Blast Hit', 'Medium',
                       'Full Set Not on Blast Hit', 'Medium',
                       'Full Set On Blast Hit', 'High',
                       'unknown epitope type') AS confidence
FROM dots.Transcript t,
     dots.TranslatedAaFeature taf, 
     dots.MotifAaSequence mas,
     dots.TranslatedAaSequence tas, 
     dots.EpitopeFeature ef,
     dots.AaLocation al, 
     sres.TaxonName tn
WHERE taf.na_feature_id = t.na_feature_id
  AND taf.aa_sequence_id = tas.aa_sequence_id
  AND tas.aa_sequence_id = ef.aa_sequence_id
  AND ef.aa_feature_id = al.aa_feature_id
  AND ef.motif_aa_sequence_id = mas.aa_sequence_id
  AND tas.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Epi_srcId_ix&1 ON EpitopeSummary&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TranscriptCenDistance">
    <comment> Stores (transcript, sequence, distance from centromere) 3-tuples for transcripts
         that lie on a sequence for which we have a centomere location.
     </comment>
    <internalDependency name="FeatureLocation"/>
    <internalDependency name="TranscriptLocation"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        CREATE TABLE TranscriptCenDistance&1 NOLOGGING AS
        SELECT tl.feature_source_id AS transcript,
               LEAST(ABS(mfl.start_min - tl.end_max),
                     ABS(mfl.end_max - tl.start_min)) AS centromere_distance,
               tl.sequence_source_id AS genomic_sequence
        FROM TranscriptLocation tl, FeatureLocation mfl,
             sres.OntologyTerm so
        WHERE tl.na_sequence_id = mfl.na_sequence_id
          AND mfl.feature_type = 'Miscellaneous'
          AND mfl.sequence_ontology_id = so.ontology_term_id
          AND so.name = 'centromere'
          AND tl.is_top_level = 1
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GCent_loc_ix&1
       on TranscriptCenDistance&1 (genomic_sequence, centromere_distance)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProteinAttributes" prefixEnabled="true">
    <comment>The BFMV for the gene record. Each gene gets a single record, which
         stores all its attributes. Used widely, in the model and elsewhere, for
         queries involving genes, as well as in the creation of more than a
         dozen other tuning tables.
    </comment>
    <internalDependency name="ProjectTaxon"/>
    <internalDependency name="TranscriptLocation"/>
    <internalDependency name="GoTermSummary"/>
    <externalDependency name="apidb.AaSequenceAttribute"/>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.AaSequence"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.RnaType"/>
    <externalDependency name="dots.SignalPeptideFeature"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="dots.TransmembraneAaFeature"/>
    <intermediateTable name="GoTermList"/>
    <intermediateTable name="ProteinGoAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixGoTermList NOLOGGING AS
SELECT aa_sequence_id, ontology, source,
             apidb.tab_to_string(set(cast(COLLECT(go_term_name order by go_term_name) as apidb.varchartab)), ', ') AS go_terms,
             apidb.tab_to_string(set(cast(COLLECT(go_id order by go_term_name) as apidb.varchartab)), ', ') AS go_ids
      FROM (SELECT aa_sequence_id, ontology, 
                        DECODE(source, 'Interpro', 'predicted', 'annotated') AS source, go_term_name, go_id
                 FROM  &prefixGoTermSummary
                 WHERE is_leaf = 1
                 )
      GROUP BY aa_sequence_id, ontology, source
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE &prefixProteinGoAttributes NOLOGGING AS
SELECT DISTINCT gts.aa_sequence_id,
       substr(annotated_go_component.go_terms, 1, 300) AS annotated_go_component,
       substr(annotated_go_function.go_terms, 1, 300) AS annotated_go_function,
       substr(annotated_go_process.go_terms, 1, 300) AS annotated_go_process,
       substr(predicted_go_component.go_terms, 1, 300) AS predicted_go_component,
       substr(predicted_go_function.go_terms, 1, 300) AS predicted_go_function,
       substr(predicted_go_process.go_terms, 1, 300) AS predicted_go_process,

       substr(annotated_go_component.go_ids, 1, 300) AS annotated_go_id_component,
       substr(annotated_go_function.go_ids, 1, 300) AS annotated_go_id_function,
       substr(annotated_go_process.go_ids, 1, 300) AS annotated_go_id_process,
       substr(predicted_go_component.go_ids, 1, 300) AS predicted_go_id_component,
       substr(predicted_go_function.go_ids, 1, 300) AS predicted_go_id_function,
       substr(predicted_go_process.go_ids, 1, 300) AS predicted_go_id_process
FROM (SELECT DISTINCT aa_sequence_id FROM &prefixGoTermSummary) gts,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'annotated' AND ontology = 'Cellular Component')
       annotated_go_component,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'annotated' AND ontology = 'Molecular Function')
       annotated_go_function,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'annotated' AND ontology = 'Biological Process')
       annotated_go_process,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'predicted' AND ontology = 'Cellular Component')
       predicted_go_component,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'predicted' AND ontology = 'Molecular Function')
       predicted_go_function,
     (SELECT * FROM &prefixGoTermList
      WHERE source = 'predicted' AND ontology = 'Biological Process')
       predicted_go_process
WHERE gts.aa_sequence_id = annotated_go_component.aa_sequence_id(+)
  AND 'annotated' = annotated_go_component.source(+)
  AND 'Cellular Component' = annotated_go_component.ontology(+)
  AND gts.aa_sequence_id = annotated_go_function.aa_sequence_id(+)
  AND 'annotated' = annotated_go_function.source(+)
  AND 'Molecular Function' = annotated_go_function.ontology(+)
  AND gts.aa_sequence_id = annotated_go_process.aa_sequence_id(+)
  AND 'annotated' = annotated_go_process.source(+)
  AND 'Biological Process' = annotated_go_process.ontology(+)
  AND gts.aa_sequence_id = predicted_go_component.aa_sequence_id(+)
  AND 'predicted' = predicted_go_component.source(+)
  AND 'Cellular Component' = predicted_go_component.ontology(+)
  AND gts.aa_sequence_id = predicted_go_function.aa_sequence_id(+)
  AND 'predicted' = predicted_go_function.source(+)
  AND 'Molecular Function' = predicted_go_function.ontology(+)
  AND gts.aa_sequence_id = predicted_go_process.aa_sequence_id(+)
  AND 'predicted' = predicted_go_process.source(+)
  AND 'Biological Process' = predicted_go_process.ontology(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index ProteinGoAttr_aaSequenceId&1 ON &prefixProteinGoAttributes (aa_sequence_id)
tablespace indx
      ]]>
    </sql>

    <sql>
      <![CDATA[
CREATE TABLE &prefixProteinAttributes&1 NOLOGGING AS
SELECT pi.name as project_id,
             tas.source_id, tas.aa_sequence_id,
             t.source_id as transcript_source_id,
             gf.source_id as gene_source_id,
             cdsl.na_sequence_id as na_sequence_id,
             cdsl.is_reversed, 
             cdsl.start_min as cds_start,
             cdsl.end_max as cds_end,
             (taf.translation_stop - taf.translation_start) + 1 AS cds_length,
             tas.length AS protein_length, 
             NVL(transmembrane.tm_domains, 0) AS tm_count,
             tas.molecular_weight,
             asa.min_molecular_weight, asa.max_molecular_weight,
             asa.isoelectric_point, asa.hydropathicity_gravy_score,
             asa.aromaticity_score,             
             sigp.scores as signalp_scores,
             SUBSTR(sigp.pep, 1, 200) as signalp_peptide,
             ec_numbers,
             ec_numbers_derived,
       go.annotated_go_component,
       go.annotated_go_function,
       go.annotated_go_process,
       go.predicted_go_component,
       go.predicted_go_function,
       go.predicted_go_process,
       go.annotated_go_id_component,
       go.annotated_go_id_function,
       go.annotated_go_id_process,
       go.predicted_go_id_component,
       go.predicted_go_id_function,
       go.predicted_go_id_process,
             SUBSTR(NVL(rt1.anticodon, rt2.anticodon), 1, 3) AS anticodon
      FROM  dots.GeneFeature gf, dots.Transcript t, core.ProjectInfo pi,
            dots.TranslatedAaFeature taf,
            dots.TranslatedAaSequence tas,
            apidb.AaSequenceAttribute asa,
            (SELECT protein_source_id, na_sequence_id, is_reversed,
                 MIN(start_min) AS start_min, MAX(end_max) AS end_max  
             FROM &prefixCdsLocation WHERE is_top_level=1
             GROUP BY protein_source_id, na_sequence_id, is_reversed)  cdsl, 
            &prefixProteinGoAttributes go,
            dots.RnaType rt1, dots.RnaType rt2,
            (SELECT aa_sequence_id, max(tm_domains) AS tm_domains
             FROM (SELECT tmaf.aa_sequence_id, COUNT(*) AS tm_domains
                   FROM dots.TransmembraneAaFeature tmaf, dots.AaLocation al
                   WHERE tmaf.aa_feature_id = al.aa_feature_id
                   GROUP BY tmaf.aa_sequence_id) tms
             GROUP BY tms.aa_sequence_id) transmembrane,
             (SELECT spf.aa_sequence_id,'NN Sum: ' || ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) ||
              ', NN D: ' || round(((spf.means_score + spf.maxy_score) / 2),2) || ', HMM Prob: ' || round(spf.signal_probability,2) as scores,
               apidb.tab_to_string(set(cast(COLLECT(decode(spf.algorithm_name,'SignalPhmm','HMM: ','NN: ') || dbms_lob.substr(s.sequence,aal.end_max,1) order by spf.algorithm_name, dbms_lob.substr(s.sequence, aal.end_max, 1)) as apidb.varchartab)), ', ') as pep
              FROM dots.SignalPeptideFeature spf, dots.AaLocation aal, dots.AaSequence s
              WHERE spf.aa_sequence_id = s.aa_sequence_id 
              and  aal.aa_feature_id = spf.aa_feature_id
              and (spf.signal_probability >= .5
              or ((spf.means_score + spf.maxy_score) / 2) >= .5
              or ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) >= 3)
              group by spf.aa_sequence_id,'NN Sum: ' || ( spf.maxy_conclusion + spf.maxc_conclusion + spf.maxs_conclusion + spf.means_conclusion ) ||
              ', NN D: ' || round(((spf.means_score + spf.maxy_score) / 2),2) || ', HMM Prob: ' || round(spf.signal_probability,2)) sigp,
            (SELECT aa_sequence_id,
                    SUBSTR(apidb.tab_to_string(set(cast(COLLECT(ec_number order by ec_number)
                                               as apidb.varchartab)), '; '),
                           1, 300)
                      AS ec_numbers
             FROM (SELECT DISTINCT asec.aa_sequence_id,
                          ec.ec_number || ' (' || ec.description || ')' AS ec_number
                   FROM dots.AaSequenceEnzymeClass asec, sres.EnzymeClass ec
                   WHERE ec.enzyme_class_id = asec.enzyme_class_id
		   AND NOT asec.evidence_code = 'OrthoMCLDerived')
             GROUP BY aa_sequence_id) ec,

            (SELECT aa_sequence_id,
                    SUBSTR(apidb.tab_to_string(set(cast(COLLECT(ec_number order by ec_number)
                                               as apidb.varchartab)), '; '),
                           1, 300)
                      AS ec_numbers_derived
             FROM (SELECT DISTINCT asec.aa_sequence_id,
                          ec.ec_number || ' (' || ec.description || ')' AS ec_number
                   FROM dots.AaSequenceEnzymeClass asec, sres.EnzymeClass ec
                   WHERE ec.enzyme_class_id = asec.enzyme_class_id
		   AND asec.evidence_code = 'OrthoMCLDerived')
             GROUP BY aa_sequence_id) ecDerived
      WHERE gf.na_feature_id = t.parent_id
        AND t.row_project_id = pi.project_id
        AND t.na_feature_id = taf.na_feature_id
        AND taf.aa_sequence_id = tas.aa_sequence_id
        AND taf.aa_sequence_id = asa.aa_sequence_id
        AND tas.aa_sequence_id = sigp.aa_sequence_id(+)
        AND cdsl.protein_source_id =  tas.source_id
        AND t.na_feature_id = rt1.parent_id(+)
        AND gf.na_feature_id = rt2.parent_id(+)
        AND tas.aa_sequence_id = transmembrane.aa_sequence_id(+)
        AND tas.aa_sequence_id = ec.aa_sequence_id(+)
        AND tas.aa_sequence_id = ecDerived.aa_sequence_id(+)
        AND tas.aa_sequence_id = go.aa_sequence_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX PA_sourceId&1 ON &prefixProteinAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE INDEX PA_aaSequenceId&1 ON &prefixProteinAttributes&1 (aa_sequence_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TranscriptAttributes" prefixEnabled="true">
    <comment>The BFMV for the gene record. Each gene gets a single record, which
         stores all its attributes. Used widely, in the model and elsewhere, for
         queries involving genes, as well as in the creation of more than a
         dozen other tuning tables.
    </comment>
    <internalDependency name="GeneId"/>
    <internalDependency name="FeatureLocation"/>
    <internalDependency name="ProjectTaxon"/>
    <internalDependency name="ProteinAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <internalDependency name="TranscriptLocation"/>
    <internalDependency name="SnpAttributes"/>
    <externalDependency name="apidb.GeneFeatureName"/>
    <externalDependency name="apidb.TranscriptProduct"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="dots.AaSequence"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="dots.ExonFeature"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.GeneInstance"/>
    <externalDependency name="dots.NaFeatureComment"/>
    <externalDependency name="dots.RnaFeatureExon"/>
    <externalDependency name="dots.RnaType"/>
    <externalDependency name="dots.SequenceGroup"/>
    <externalDependency name="dots.SequenceSequencegroup"/>
    <externalDependency name="dots.SnpFeature"/>
    <externalDependency name="dots.SplicedNaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TransmembraneAaFeature"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixTranscriptAttributes&1 NOLOGGING AS
SELECT cast(apidb.prefixed_project_id(tn.name, '&prefix') as varchar2(20)) as project_id,
       --source_id : set initially as the transcript_source_id
       t.source_id,
       --first the gene attributes:
       gf.source_id AS gene_source_id, 
       gf.na_feature_id AS gene_na_feature_id,
       LEAST(nl.start_min, nl.end_max) AS gene_start_min,
       GREATEST(nl.start_min, nl.end_max) AS gene_end_max,
       COALESCE(preferred_name.name, any_name.name) AS gene_name,
       cast(null as varchar2(900)) as gene_product,
       REPLACE(so.name, '_', ' ') AS gene_type,
       gi.gene_id,
       transcripts.gene_transcript_count,
       exons.gene_exon_count,
       cast(null as varchar2(80)) as representative_transcript,
       olds.old_ids AS gene_previous_ids,
       nvl(deprecated.is_deprecated, 0) as is_deprecated, 
       0 as gene_paralog_number, 0 as gene_ortholog_number,
       GREATEST(1, least(nl.start_min, nl.end_max) - 15000) AS gene_context_start,
       LEAST(sequence.length, greatest(nl.start_min, nl.end_max) + 15000) AS gene_context_end,
       GREATEST(1, least(nl.start_min, nl.end_max) - 1500) AS gene_zoom_context_start,
       LEAST(sequence.length, greatest(nl.start_min, nl.end_max) + 1500) AS gene_zoom_context_end,
       substr(orthologs.name, 1, 60) AS orthomcl_name,
       nvl(tothtssnps.total_hts_snps,0) AS gene_total_hts_snps, 
       nvl(tothtssnps.hts_nonsynonymous_snps,0) AS gene_hts_nonsynonymous_snps,
       nvl(tothtssnps.hts_stop_codon_snps,0) AS gene_hts_stop_codon_snps,
       nvl(tothtssnps.hts_noncoding_snps,0) AS gene_hts_noncoding_snps, 
       nvl(tothtssnps.hts_synonymous_snps,0) AS gene_hts_synonymous_snps,
       nvl(tothtssnps.hts_nonsyn_syn_ratio,0) AS gene_hts_nonsyn_syn_ratio, 
       SUBSTR(cmnt.comment_string, 1, 300) AS comment_string,
       uniprot.gene_uniprot_id, uniprot.gene_uniprot_id_internal,
       entrez_table.entrez_id AS gene_entrez_id, 
       --next the transcript attributes: 
       t.source_id AS transcript_source_id,
       t.na_feature_id,
       SUBSTR(COALESCE(preferred_product.product, any_product.product, 'unspecified product'), 1, 300) 
            AS transcript_product,
       tl.start_min, tl.end_max,
       tl.start_min as coding_start,
       tl.end_max as coding_end,
       tl.is_reversed,   --CHECK if needed
       DECODE(nvl(tl.is_reversed, 0), 0, 'forward', 1, 'reverse', tl.is_reversed) AS strand,
       DECODE(t.is_pseudo, null, 0, t.is_pseudo) as is_pseudo,
       transcript_exons.exon_count,
       sns.length AS length,
       SUBSTR(sequence.source_id, 1, 50) AS sequence_id,
       SUBSTR(tn.name, 1, 100) AS organism,
       SUBSTR(species_name.name, 1, 100) AS species,
       taxon.ncbi_tax_id,  tn.taxon_id, 
       so.source_id as so_id, SUBSTR(so.name, 1, 150) AS so_term_name,
       SUBSTR(so.definition, 1, 150) AS so_term_definition,
       SUBSTR(soRls.version, 1, 7) AS so_version,
       SUBSTR(NVL(rt1.anticodon, rt2.anticodon), 1, 3) AS anticodon,
       ed.name AS external_db_name,
       SUBSTR(edr.version, 1, 10) AS external_db_version,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.chromosome_order_num, sequence.na_sequence_id,
       --next the protein attributes: 
       pa.source_id AS protein_source_id,
       pa.aa_sequence_id,
       pa.cds_start, pa.cds_end, pa.cds_length, 
       pa.protein_length, pa.tm_count,
       pa.molecular_weight,
       pa.isoelectric_point, 
       pa.signalp_scores, pa.signalp_peptide,
       pa.ec_numbers, pa.ec_numbers_derived,
       pa.annotated_go_component,
       pa.annotated_go_function,
       pa.annotated_go_process,
       pa.predicted_go_component,
       pa.predicted_go_function,
       pa.predicted_go_process,
       pa.annotated_go_id_component,
       pa.annotated_go_id_function,
       pa.annotated_go_id_process,
       pa.predicted_go_id_component,
       pa.predicted_go_id_function,
       pa.predicted_go_id_process,
       relIntronUtrCoords.genomic_relative_coords as gen_rel_intron_utr_coords,
       utr_lengths.five_prime_utr_length, 
       utr_lengths.three_prime_utr_length
FROM dots.GeneFeature gf, &prefixFeatureLocation nl, sres.OntologyTerm so,
     sres.externalDatabaseRelease soRls,
     sres.Taxon, sres.TaxonName tn, dots.RnaType rt1, dots.RnaType rt2,
     dots.Transcript t, sres.ExternalDatabase ed,
     sres.ExternalDatabaseRelease edr, dots.SplicedNaSequence sns,
     (SELECT rna_feature_id, count(*) as exon_count
      FROM dots.RnaFeatureExon 
      GROUP BY rna_feature_id) transcript_exons,
     ( select na_sequence_id, source_id, chromosome, chromosome_order_num, length, taxon_id
       from dots.ExternalNaSequence
      union
       select na_sequence_id, source_id, chromosome, chromosome_order_num, length, taxon_id
       from dots.VirtualSequence) sequence,
     &prefixTranscriptLocation tl, &prefixProteinAttributes pa,
     dots.geneinstance gi, &prefixTaxonSpecies ts, sres.TaxonName species_name,
     (SELECT DISTINCT gene AS source_id FROM &prefixGeneId) gene,
     (SELECT parent_id, count(*) AS gene_transcript_count
      FROM dots.Transcript
      GROUP BY parent_id) transcripts,
     (SELECT parent_id, count(*) AS gene_exon_count
      FROM dots.ExonFeature
      GROUP BY parent_id) exons,
     (SELECT nfc.na_feature_id,
             MAX(DBMS_LOB.SUBSTR(nfc.comment_string, 300, 1))
               AS comment_string
      FROM dots.NaFeatureComment nfc
      GROUP BY nfc.na_feature_id) cmnt,
     (select distinct gf.source_id, 1 as is_deprecated
      from dots.GeneFeature gf, dots.DbRefNaFeature drnf, sres.DbRef dr, sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
      where gf.na_feature_id = drnf.na_feature_id
        and drnf.db_ref_id = dr.db_ref_id
        and dr.external_database_release_id = edr.external_database_release_id
        and edr.external_database_id = ed.external_database_id
        and ed.name = 'gassAWB_dbxref_gene2Deprecated_RSRC') deprecated,
     ( select gene_source_id, total_hts_snps, hts_nonsynonymous_snps, hts_stop_codon_snps,hts_noncoding_snps,hts_synonymous_snps,
        case when (hts_nonsynonymous_snps is null) then 0
              when (hts_synonymous_snps = 0) then 0
                  else round ((hts_nonsynonymous_snps/ hts_synonymous_snps), 2) end as hts_nonsyn_syn_ratio 
      from (
             select gene_source_id,
                    count(*) as total_hts_snps,
                    sum(has_nonsynonymous_allele) as hts_nonsynonymous_snps,
                    sum(has_stop_codon) as hts_stop_codon_snps,
                    sum(is_noncoding_snp) as hts_noncoding_snps,
                    count(*) - sum(has_nonsynonymous_allele) - sum(has_stop_codon) - sum(is_noncoding_snp)  as hts_synonymous_snps
             from &prefixSnpAttributes
             where  gene_source_id is not null
             group by gene_source_id 
      ) ) tothtssnps, 
     (  select gf.na_feature_id, sg.name
        from dots.genefeature gf, dots.SequenceSequenceGroup ssg, 
             dots.SequenceGroup sg, core.TableInfo ti
        where gf.na_feature_id = ssg.sequence_id
          and ssg.sequence_group_id = sg.sequence_group_id
          and ssg.source_table_id = ti.table_id
          and ti.name = 'GeneFeature'
       ) orthologs,
     (select na_feature_id, max(product) as product
      from apidb.TranscriptProduct
      where is_preferred = 1
      group by na_feature_id
     ) preferred_product,
     (select na_feature_id, max(product) as product
      from apidb.TranscriptProduct
      group by na_feature_id
     ) any_product,
     (select na_feature_id, max(name) as name
      from apidb.GeneFeatureName
      where is_preferred = 1
      group by na_feature_id
     ) preferred_name,
     (select na_feature_id, max(name) as name
      from apidb.GeneFeatureName
      group by na_feature_id
     ) any_name,
     (select gene as source_id,
             substr(listagg (id, ',') within group (order by id), 1, 240) as gene_uniprot_id,
             substr(listagg (id, '+or+') within group (order by id), 1, 240) as gene_uniprot_id_internal
      from &prefixGeneId
      where database_name like '%uniprot_dbxref_RSRC'
         or database_name like '%dbxref_gene2Uniprot_RSRC'
         or database_name = 'Links to Uniprot Genes'
      group by gene
     ) uniprot,
     (select dbna.na_feature_id,
             substr(listagg (db.primary_identifier, ',') within group (order by db.primary_identifier), 1, 300) as entrez_id
      from sres.ExternalDatabaseRelease edr, sres.DbRef db,
           dots.DbRefNaFeature dbna, sres.ExternalDatabase ed
      where edr.external_database_release_id = db.external_database_release_id
        and ed.external_database_id = edr.external_database_id
        and dbna.db_ref_id = db.db_ref_id
        and lower(ed.name) like '%entrez%'
        group by dbna.na_feature_id
     ) entrez_table,
     (select drnf.na_feature_id,
                 substr(listagg(dr.primary_identifier, ', ') within group (order by dr.primary_identifier), 1, 900) as old_ids
          from dots.DbRefNaFeature drnf, sres.DbRef dr, sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
          where dr.primary_identifier is not null
            and drnf.db_ref_id = dr.db_ref_id
            and dr.external_database_release_id = edr.external_database_release_id
            and edr.external_database_id = ed.external_database_id
            and edr.id_type = 'previous id'
          group by drnf.na_feature_id
     ) olds, 
    (select
      na_feature_id
    , '[' || listagg('["' || feature_type || '",' || start_min || ',' || end_max || ']', ',') within GROUP (ORDER BY start_min) || ']' AS genomic_relative_coords
    FROM
      (SELECT
        tl.feature_source_id
      , tl.na_feature_id
      , feature_type
      , fl.start_min - tl.start_min + 1 AS start_min
      , fl.end_max - tl.start_min + 1 as end_max
      FROM
        transcriptlocation tl
      , featurelocation fl
      where
        tl.na_feature_id = fl.parent_id 
        and fl.feature_type in('UTR', 'Intron')
        and tl.is_top_level = 1
        and fl.is_top_level = 1
      )
    group by
      na_feature_id
    ) relIntronUtrCoords
  , (select t.na_feature_id as transcript_na_feature_id, five_prime.utr_length as five_prime_utr_length, three_prime.utr_length as three_prime_utr_length
     from dots.transcript t
      ,(select parent_id, sum(end_max-start_min + 1) as utr_length from utrlocation
       where direction = 5
         and is_top_level = 1
       group by parent_id
       ) five_prime
      ,(select parent_id, sum(end_max-start_min + 1) as utr_length from utrlocation
       where direction = 3
         and is_top_level = 1
       group by parent_id
       ) three_prime
     where t.na_feature_id = five_prime.parent_id (+)
     and t.na_feature_id = three_prime.parent_id (+)
  ) utr_lengths
WHERE gf.source_id = gene.source_id
  AND gf.na_feature_id = nl.na_feature_id
  AND nl.is_top_level = 1
  AND nl.feature_type = 'GeneFeature' 
  AND nl.na_sequence_id = sequence.na_sequence_id
  AND (sequence.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
  AND gf.sequence_ontology_id = so.ontology_term_id
  AND so.external_database_release_id = soRls.external_database_release_id
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
  AND tn.taxon_id NOT IN
	 (SELECT o.taxon_id FROM apidb.Organism o WHERE  o.is_annotated_genome=0)
  AND t.na_sequence_id = sns.na_sequence_id(+)
  AND gf.na_feature_id = t.parent_id(+)
  AND tl.feature_source_id =  t.source_id
  AND tl. is_top_level=1
  AND t.na_feature_id = transcript_exons.rna_feature_id
  AND t.na_feature_id = rt1.parent_id(+)
  AND gf.na_feature_id = rt2.parent_id(+)
  AND gf.external_database_release_id
       = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND gf.na_feature_id = transcripts.parent_id(+)
  AND gf.na_feature_id = exons.parent_id(+)
  AND gf.na_feature_id = orthologs.na_feature_id(+)
  AND gf.na_feature_id = cmnt.na_feature_id(+)
  AND gf.source_id = deprecated.source_id(+)
  AND gf.na_feature_id = gi.na_feature_id(+)
  AND gf.source_id = tothtssnps.gene_source_id(+)
  AND sequence.taxon_id = ts.taxon_id(+)
  AND ts.species_taxon_id = species_name.taxon_id
  AND species_name.name_class = 'scientific name'
  AND t.na_feature_id = preferred_product.na_feature_id(+)
  AND t.na_feature_id = any_product.na_feature_id(+)
  AND gf.na_feature_id = preferred_name.na_feature_id(+)
  AND gf.na_feature_id = any_name.na_feature_id(+)
  AND (gf.is_predicted != 1 OR gf.is_predicted is null)
  AND tn.name not in ('Plasmodium gallinaceum','Plasmodium reichenowi')
  AND gf.source_id = uniprot.source_id(+)
  AND gf.na_feature_id = entrez_table.na_feature_id(+)
  AND gf.na_feature_id = olds.na_feature_id(+)
  AND t.source_id = pa.transcript_source_id(+)
  AND t.na_feature_id = relIntronUtrCoords.na_feature_id (+)
 AND t.na_feature_id = utr_lengths.transcript_na_feature_id 
      ]]>
    </sql>
    <!--  source_id:  if source_id is not unique, use protein_source_id -->
    <sql>
      <![CDATA[
update &prefixTranscriptAttributes&1 ta
set ta.source_id = ta.protein_source_id 
where ta.source_id in 
  (select source_id from 
    ( select count(*), source_id from &prefixTranscriptAttributes&1 group by source_id having count(*)>1))
      ]]>
    </sql>
    <sql>
      <![CDATA[
update &prefixTranscriptAttributes&1 ga
set ga.gene_product = 
 (select apidb.tab_to_string(set(cast(COLLECT(transcript_product order by transcript_product) as apidb.varchartab)), ', ') 
 from &prefixTranscriptAttributes&1 gb
                     where gb.gene_source_id = ga.gene_source_id
                     group by ga.gene_source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_sourceId&1
          ON &prefixTranscriptAttributes&1 (source_id)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_srcPrj&1
        ON &prefixTranscriptAttributes&1 (source_id, gene_source_id, project_id)
        TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TranscriptAttr_genesrc&1
        ON &prefixTranscriptAttributes&1 (gene_source_id, source_id, project_id)
        TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX TranscriptAttr_exon_ix&1
          ON &prefixTranscriptAttributes&1 (gene_exon_count, source_id, gene_source_id, project_id)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX TranscriptAttr_loc_ix&1
          ON &prefixTranscriptAttributes&1
               (na_sequence_id, gene_start_min, gene_end_max, is_reversed, na_feature_id,
                is_deprecated, source_id, gene_source_id, project_id)
        TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX TranscriptAttr_feat_ix&1
          ON &prefixTranscriptAttributes&1 (na_feature_id, source_id, gene_source_id, project_id)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX TranscriptAttr_geneid_ix&1
          ON &prefixTranscriptAttributes&1 (gene_id, source_id, gene_source_id, project_id)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX TransAttr_orthoname_ix&1
          ON &prefixTranscriptAttributes&1 (orthomcl_name, source_id, taxon_id, gene_type)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX TransAttr_ortholog_ix&1
          ON &prefixTranscriptAttributes&1
             (source_id, na_sequence_id, gene_start_min, gene_end_max, orthomcl_name, gene_source_id, project_id)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX TransAttr_orgsrc_ix&1
          ON &prefixTranscriptAttributes&1 (organism, source_id, sequence_id, gene_start_min, gene_end_max)
          TABLESPACE INDX
      ]]>
    </sql>
    <sql>
      <![CDATA[
  update &prefixTranscriptAttributes&1
  set gene_exon_count = 1
  where gene_exon_count > 1
   and project_id = 'TriTrypDB' 
   and source_id in (
                select source_id from &prefixTranscriptAttributes&1
              minus
                select source_id
                from (
                  select 'intron' as type, ga.source_id,
                          abs(rightLoc.start_min - leftLoc.end_max) as len
                  from dots.ExonFeature left, &prefixFeatureLocation leftLoc,
                       dots.ExonFeature right, &prefixFeatureLocation rightLoc,
                       &prefixTranscriptAttributes&1 ga
                  where left.parent_id = right.parent_id
                    and left.parent_id = ga.na_feature_id
                    and (left.order_number = right.order_number - 1
                         or left.order_number = right.order_number + 1)
                    and leftLoc.start_min < rightLoc.start_min
                    and left.na_feature_id = leftLoc.na_feature_id
                    and leftLoc.is_top_level = 1
                    and right.na_feature_id = rightLoc.na_feature_id
                    and rightLoc.is_top_level = 1
                   ) 
               group by source_id
               having min(len) > 10
           )
      ]]>
    </sql>
<!--
    <sql>
      <![CDATA[
update &prefixTranscriptAttributes&1 ga
set ga.orthomcl_name = (select distinct gb.orthomcl_name from &prefixTranscriptAttributes&1 gb
                     where gb.gene_id = ga.gene_id
                     and gb.orthomcl_name is not null
                     and gb.source_id != gb.orthomcl_name)
where ga.organism like 'Toxo%' 
and ga.orthomcl_name is null
      ]]>
    </sql>
-->
    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1
        set orthomcl_name = 'ORTH_' || gene_id || '.tmp'
        where orthomcl_name is null
        and gene_id is not null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1
        set orthomcl_name = source_id
        where orthomcl_name is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
       update &prefixTranscriptAttributes&1 gaup
       set gene_paralog_number = (select count(*)
                               from &prefixTranscriptAttributes&1 g1
                               where g1.orthomcl_name = gaup.orthomcl_name
                               and g1.organism = gaup.organism
                               and gaup.source_id != g1.source_id),
           gene_ortholog_number = (select count(*)
                               from &prefixTranscriptAttributes&1 g1
                               where g1.orthomcl_name = gaup.orthomcl_name
                               and g1.organism != gaup.organism)
        where gaup.gene_type = 'protein coding'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1
        set gene_id = gene_na_feature_id + (select nvl(max(gene_id), 0) from dots.gene)
        where gene_id is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1
        set representative_transcript = (select min(source_id)
                                   from &prefixTranscriptAttributes&1 ga
                                   where ga.gene_source_id = &prefixTranscriptAttributes&1.gene_source_id)
        where representative_transcript is null
          and gene_id is not null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update &prefixTranscriptAttributes&1
        set representative_transcript = source_id
        where representative_transcript is null
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="GeneAttributes" prefixEnabled="true">
    <comment>The BFMV for the gene record. Each gene gets a single record, which
         stores all its attributes. 
    </comment>
    <internalDependency name="TranscriptAttributes"/> 
    <sql>
      <![CDATA[
	    CREATE TABLE &prefixGeneAttributes&1 NOLOGGING AS
	    SELECT DISTINCT project_id
	        , ta.gene_source_id AS source_id
		, gene_na_feature_id AS na_feature_id
		, na_sequence_id
		, is_reversed
		, gene_start_min AS start_min
		, gene_end_max AS end_max
                , decode(strand,'forward','+','reverse','-',null) as strand_plus_minus
		, sequence_id
		, gene_name AS name
		, gene_product AS product
		, gene_type
		, aggregates.is_pseudo
		, organism
		, taxon_id
		, species as genus_species
                , ltrim(regexp_replace(organism,species,'')) as strain
		, ncbi_tax_id
		, so_id
		, so_term_name
		, so_term_definition
		, so_version
		, anticodon
		, external_db_name
		, external_db_version
		, chromosome
		, chromosome_order_num
		, gene_transcript_count AS transcript_count
		, gene_exon_count as exon_count
		, gene_previous_ids as previous_ids
		, is_deprecated
		, gene_paralog_number as paralog_number
		, gene_ortholog_number as ortholog_number
		, gene_context_start as context_start
		, gene_context_end as context_end
		, orthomcl_name
		, gene_total_hts_snps as total_hts_snps
		, gene_hts_nonsynonymous_snps as hts_nonsynonymous_snps
		, gene_hts_stop_codon_snps as hts_stop_codon_snps
		, gene_hts_noncoding_snps as hts_noncoding_snps
		, gene_hts_synonymous_snps as hts_synonymous_snps
		, gene_hts_nonsyn_syn_ratio as hts_nonsyn_syn_ratio
		, comment_string
		, gene_uniprot_id as uniprot_id
		, gene_uniprot_id_internal as uniprot_id_internal
		, gene_entrez_id as entrez_id
		, representative_transcript
                , gene_zoom_context_start as zoom_context_start
                , gene_zoom_context_end as zoom_context_end
            FROM TranscriptAttributes ta,
                 (SELECT gene_source_id, MIN(is_pseudo) AS is_pseudo
                  FROM TranscriptAttributes
                  GROUP BY gene_source_id) aggregates
            WHERE ta.gene_source_id = aggregates.gene_source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create /* unique */
 index GeneAttr_srcPrj&1
       ON &prefixGeneAttributes&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_exon_ix&1
       ON &prefixGeneAttributes&1 (exon_count, source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_loc_ix&1
       ON &prefixGeneAttributes&1 (na_sequence_id, start_min, end_max, is_reversed, na_feature_id, is_deprecated)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_feat_ix&1
       ON &prefixGeneAttributes&1 (na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_orthoname_ix&1
       ON &prefixGeneAttributes&1 (orthomcl_name, source_id, taxon_id, gene_type)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_ortholog_ix&1
       ON &prefixGeneAttributes&1 (source_id, na_sequence_id, start_min, end_max, orthomcl_name)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneAttr_orgsrc_ix&1
       ON &prefixGeneAttributes&1 (organism, source_id, na_sequence_id, start_min, end_max)
tablespace indx
      ]]>
    </sql> 
  </tuningTable>


  <tuningTable name="GenomicSeqAttributes" prefixEnabled="true">
    <comment>Each row represents one genomic sequence for which a WDK sequence
         record can be instantiated. Used widely in the workflow, the model,
         and GBrowse, as well as in the creation of a dozen or so other tuning
         tables.
    </comment>
    <internalDependency name="ProjectTaxon"/>
    <internalDependency name="SequencePieceClosure"/>
    <externalDependency name="apidb.Synteny"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixGenomicSeqAttributes&1 NOLOGGING AS
SELECT cast(apidb.prefixed_project_id(tn.name, '&prefix') as varchar2(20)) as project_id,
       SUBSTR(sequence.source_id, 1, 60) AS source_id, sequence.a_count,
       sequence.c_count, sequence.g_count, sequence.t_count,
       (sequence.length
        - (sequence.a_count + sequence.c_count + sequence.g_count + sequence.t_count))
         AS other_count,
       sequence.length,
       to_char((sequence.a_count + sequence.t_count) / sequence.length * 100, '99.99')
         AS at_percent,
       SUBSTR(tn.name, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       taxon.taxon_id,                 
       CASE WHEN sequence.description IS NULL  THEN SUBSTR(tn.name, 1, 100)
            ELSE SUBSTR(sequence.description, 1, 400)
            END AS sequence_description,
       SUBSTR(genbank.genbank_accession, 1, 20) AS genbank_accession,
       SUBSTR(db.database_version, 1, 30) AS database_version, db.database_name,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.external_database_release_id, sequence.sequence_ontology_id,
       sequence.chromosome_order_num, so.source_id as so_id, so.name as sequence_type,
       nvl(virtualization.is_top_level, 1) as is_top_level,
       sequence.na_sequence_id, organism.genome_source,
       organism.name_for_filenames, nvl(msa.has_msa, 0) as has_msa
FROM sres.TaxonName tn, sres.Taxon, sres.OntologyTerm so, apidb.Organism,
     ( select na_sequence_id, source_id, length, chromosome, chromosome_order_num, taxon_id, description,
              a_count, c_count, g_count, t_count, external_database_release_id, sequence_ontology_id
       from dots.ExternalNaSequence
      union
       select na_sequence_id, source_id, length, chromosome, chromosome_order_num, taxon_id, description,
              a_count, c_count, g_count, t_count, external_database_release_id, sequence_ontology_id
       from dots.VirtualSequence) sequence,
     (SELECT drns.na_sequence_id, max(dr.primary_identifier) AS genbank_accession
      FROM dots.dbrefNaSequence drns, sres.DbRef dr,
           sres.ExternalDatabaseRelease gb_edr, sres.ExternalDatabase gb_ed
      WHERE drns.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
            = gb_edr.external_database_release_id
        AND gb_edr.external_database_id = gb_ed.external_database_id
        AND gb_ed.name = 'GenBank'
      GROUP BY drns.na_sequence_id) genbank,
     (SELECT edr.external_database_release_id,
             edr.version AS database_version, ed.name AS database_name
      FROM sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      WHERE edr.external_database_id = ed.external_database_id) db,
     (SELECT distinct piece_na_sequence_id, 0 as is_top_level
      FROM &prefixSequencePieceClosure) virtualization,
     (SELECT a_na_sequence_id as na_sequence_id, 1 as has_msa
      FROM apidb.Synteny syn
      GROUP BY a_na_sequence_id) msa
WHERE sequence.taxon_id = tn.taxon_id(+)
  AND (sequence.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
  AND tn.name_class = 'scientific name'
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.sequence_ontology_id = so.ontology_term_id
  AND so.name IN ('random_sequence', 'chromosome', 'contig', 'supercontig','mitochondrial_chromosome','plastid_sequence','cloned_genomic','apicoplast_chromosome')
  AND sequence.na_sequence_id = genbank.na_sequence_id(+)
  AND sequence.external_database_release_id = db.external_database_release_id(+)
  AND sequence.na_sequence_id = virtualization.piece_na_sequence_id(+)
  AND taxon.taxon_id = organism.taxon_id(+)
  AND sequence.na_sequence_id = msa.na_sequence_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index pk_SeqAttr_&1 ON &prefixGenomicSeqAttributes&1 (lower(source_id), project_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index SeqAttr_source_id&1 ON &prefixGenomicSeqAttributes&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index SeqAttr_naseqid&1 ON &prefixGenomicSeqAttributes&1 (na_sequence_id)
      ]]>
    </sql>
  </tuningTable>


<!--
  <comment> NGS SNP only </comment>
-->
  <tuningTable name="SnpAttributes" prefixEnabled="true">
    <comment>Each record represents one SNP. Widely used in the model, as well as in
         the creation of several other tuning tables,
    </comment>

    <internalDependency name="ProjectTaxon"/>
    <internalDependency name="FeatureLocation"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="apidb.Snp"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixSnpAttributes&1 NOLOGGING AS
SELECT cast(apidb.prefixed_project_id(tn.name, '&prefix') as varchar2(20)) as project_id,
       ed.name as dataset,
       sequence.na_sequence_id,
       sequence.source_id as seq_source_id,
       snp.location,
       snp.source_id,
       snp.reference_strain, 
       snp.reference_na, 
       snp.reference_aa, 
       decode(snp.position_in_cds, null, 0, 1) as is_coding,
       snp.position_in_CDS,
       snp.position_in_protein,
       /* has_nonsynonymous should be false if any products are stops */
       case when stopcodonsnps.total_stop_codon_snps is null then snp.has_nonsynonymous_allele else 0 end as has_nonsynonymous_allele,
       snp.major_allele, 
       snp.minor_allele,
       snp.major_allele_count, 
       snp.minor_allele_count,
       round(snp.major_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as major_allele_frequency,
       round(snp.minor_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as minor_allele_frequency,
       snp.major_product, 
       snp.minor_product,
       snp.distinct_strain_count,
       snp.distinct_allele_count,
       case when stopcodonsnps.total_stop_codon_snps is null then 0 else 1 end as has_stop_codon,
       case when snp.position_in_cds is null then 1 else 0 end as is_noncoding_snp,
       fl.feature_source_id as gene_source_id,
       decode(fl.is_reversed,0,'forward',1,'reverse',null) as gene_strand,
       SUBSTR(sequence.sequence, snp.location - 30, 30) AS lflank,
       SUBSTR(sequence.sequence, snp.location + 1, 30) AS rflank,
       SUBSTR(tn.name, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       SUBSTR(chromosome_info.chromosome, 1, 20) AS chromosome,
       chromosome_info.chromosome_order_num
FROM apidb.Snp snp, 
     sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, sres.Taxon,
     sres.TaxonName tn, dots.NaSequence sequence,
     FeatureLocation fl,
     (
     select snp.source_id, count(*) as total_stop_codon_snps
     from apidb.snp snp, apidb.sequencevariation var 
     where snp.na_sequence_id = var.ref_na_sequence_id
       and snp.location = var.location
         and var.product = '*' 
         group by snp.source_id 
     ) stopcodonsnps, 
     (SELECT na_sequence_id, chromosome, chromosome_order_num
      FROM dots.ExternalNaSequence
     UNION
      SELECT na_sequence_id, chromosome, chromosome_order_num
      FROM dots.VirtualSequence
     UNION
      SELECT na_sequence_id, null as chromosome, null as chromosome_order_num
      FROM dots.NaSequence
      WHERE subclass_view not in ('ExternalNASequence', 'VirtualSequence')
     ) chromosome_info
WHERE edr.external_database_release_id = snp.external_database_release_id
  AND ed.external_database_id = edr.external_database_id
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
  AND sequence.na_sequence_id = snp.na_sequence_id
  AND chromosome_info.na_sequence_id = snp.na_sequence_id
  AND fl.na_feature_id(+) = snp.gene_na_feature_id
  AND fl.is_top_level = 1
  and snp.source_id = stopcodonsnps.source_id(+)
      ]]>
    </sql>

    <sql>
      <![CDATA[
create unique index SnpAttr_source_id&1 ON &prefixSnpAttributes&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Snp_nafeat_dataset_ix&1
       ON &prefixSnpAttributes&1 (dataset)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Snp_Seq_ix&1
       ON &prefixSnpAttributes&1 (na_sequence_id, dataset, location)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Snp_Freq_ix&1
       ON &prefixSnpAttributes&1 (dataset,major_allele_frequency,minor_allele_frequency)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpAttr_ds_org_ix&1 on &prefixSnpAttributes&1 (dataset,organism)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpVariantIx&1 on &prefixSnpAttributes&1 (dataset, source_id, gene_source_id, location, position_in_protein)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="OrfAttributes">
    <comment> Each record represents an ORF. Used by the model and the sequence
         retrieval tool for ORF-related queries.
     </comment>
    <internalDependency name="FeatureLocation"/>
    <internalDependency name="ProjectTaxon"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE OrfAttributes&1 NOLOGGING AS
SELECT cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       SUBSTR(nl.feature_source_id, 1, 60) AS source_id,
       LOWER(SUBSTR(nl.feature_source_id, 1, 60)) AS lowercase_source_id,
       SUBSTR(tn.name, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       SUBSTR(sequence.source_id, 1, 30) AS nas_id,
       (nl.end_max - nl.start_min + 1)/3 as length,
       nl.start_min, nl.end_max, nl.is_reversed,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.chromosome_order_num,
       sequence.na_sequence_id,
       nl.na_feature_id
FROM sres.taxon, sres.TaxonName tn,
     sres.OntologyTerm oterm, FeatureLocation nl,
     ( select source_id, chromosome, chromosome_order_num, na_sequence_id, taxon_id
       from dots.ExternalNaSequence
      union
       select source_id, chromosome, chromosome_order_num, na_sequence_id, taxon_id
       from dots.VirtualSequence) sequence
WHERE sequence.na_sequence_id = nl.na_sequence_id
  AND sequence.taxon_id = tn.taxon_id
  AND sequence.taxon_id = taxon.taxon_id
  AND nl.sequence_ontology_id = oterm.ontology_term_id
  AND nl.is_top_level = 1
  AND oterm.name = 'ORF'
  AND tn.name_class='scientific name'
/*  AND nl.feature_type = 'Miscellaneous' */
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index OrfAttr_source_id&1 ON OrfAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index OrfAttr_location_idx&1 ON OrfAttributes&1 (na_sequence_id, start_min, end_max, is_reversed)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EstAttributes">
    <comment> Each row represents one EST. Used widely in the model, and to make the
         tuning tables BlastTypes, OrganismAbbreviationBlast, and OrganismAttributes.
     </comment>
    <internalDependency name="ProjectTaxon"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.Est"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="dots.Library"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE EstAttributes&1 NOLOGGING AS
SELECT cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ens.source_id,
       e.seq_primer AS primer,
       ens.a_count,
       ens.c_count,
       ens.g_count,
       ens.t_count,
       (ens.length - (ens.a_count + ens.c_count + ens.g_count + ens.t_count))
         AS other_count,
       ens.length,
       l.dbest_name,
       nvl(regexp_replace(l.vector, '^\s+$', null), 'unknown') AS vector,
       nvl(regexp_replace(l.stage, '^\s+$', null), 'unknown') AS stage,
       SUBSTR(CASE
                WHEN tn.name = 'Giardia lamblia' THEN 'Giardia Assemblage A isolate WB' 
                ELSE tn.name
              END, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       ed.name AS external_db_name,
       nvl(best.best_alignment_count, 0) AS best_alignment_count,
       l.library_id, l.dbest_name as library_dbest_name
FROM dots.Est e, dots.ExternalNaSequence ens, dots.Library l, sres.Taxon,
     sres.TaxonName tn, sres.ExternalDatabase ed,
     sres.ExternalDatabaseRelease edr, sres.OntologyTerm oterm,
     (select query_na_sequence_id,max(ct) as best_alignment_count
      from (
            SELECT query_na_sequence_id, COUNT(*) AS ct
             FROM dots.BlatAlignment ba
             WHERE is_best_alignment = 1
             GROUP BY target_external_db_release_id,query_na_sequence_id)
      group by query_na_sequence_id) best
WHERE e.na_sequence_id = ens.na_sequence_id
  AND e.library_id = l.library_id
  AND ens.taxon_id = tn.taxon_id
  AND ens.taxon_id = taxon.taxon_id
  AND tn.name_class='scientific name'
  AND ens.external_database_release_id = edr.external_database_release_id
  AND edr.external_database_id = ed.external_database_id
  AND ens.sequence_ontology_id = oterm.ontology_term_id
  AND oterm.name = 'EST'
  AND best.query_na_sequence_id(+) = ens.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index EstAttr_source_id&1 ON EstAttributes&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="BlatAlignmentLocation">
    <comment> Locations of BLAT alignments, both on the sequences they're annotated
         onto and also transitively through SequencePiece. Used in model and
         GBrowse queries, as well as in the creation of the tuning tables
         EstAlignmentGeneSummary.
     </comment>
    <internalDependency name="SequencePieceClosure"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
      CREATE TABLE BlatAlignmentLocation&1 NOLOGGING AS
      SELECT blat_alignment_id, query_na_sequence_id, target_na_sequence_id,
             query_table_id, query_taxon_id, query_external_db_release_id,
             target_table_id, target_taxon_id, target_external_db_release_id,
             is_consistent, is_genomic_contaminant, unaligned_3p_bases,
             unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
             is_5p_complete, percent_identity, max_query_gap, max_target_gap,
             number_of_spans, query_start, query_end, target_start, target_end,
             is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
             is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
             tstarts, cast('direct' as varchar2(7)) as location_mapping
      FROM dots.BlatAlignment
      ]]>
    </sql>
    <perl>
      <![CDATA[
      use strict;
      use lib "$ENV{GUS_HOME}/lib/perl";

      my $sql = <<SQL;
        select blat_alignment_id, query_na_sequence_id, target_na_sequence_id,
               query_table_id, query_taxon_id, query_external_db_release_id, 
               target_table_id, target_taxon_id, target_external_db_release_id,
               is_consistent, is_genomic_contaminant, unaligned_3p_bases,
               unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
               is_5p_complete, percent_identity, max_query_gap, max_target_gap,
               number_of_spans, query_start, query_end, target_start, target_end,
               is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
               is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
               tstarts, sp.virtual_na_sequence_id, sp.distance_from_left, sp.start_position, sp.end_position,
               sp.strand_orientation, piece.length, vti.table_id as virtual_target_table_id
        from dots.BlatAlignment ba, SequencePieceClosure sp, dots.NaSequence piece,
             dots.NaSequence virtualseq, core.TableInfo vti
        where ba.target_na_sequence_id = sp.piece_na_sequence_id(+)
          and sp.start_position <= target_start
          and sp.end_position >= target_end
          and ba.target_na_sequence_id = piece.na_sequence_id
          and sp.virtual_na_sequence_id = virtualseq.na_sequence_id
          and virtualseq.subclass_view = vti.name
SQL
      
      my $queryHandle = $dbh->prepare($sql) or die $dbh->errstr;
      $queryHandle->execute();

      $sql = <<SQL;
        insert into BlatAlignmentLocation&1(blat_alignment_id,
               query_na_sequence_id, target_na_sequence_id,
               query_table_id, query_taxon_id, query_external_db_release_id, 
               target_table_id, target_taxon_id, target_external_db_release_id,
               is_consistent, is_genomic_contaminant, unaligned_3p_bases,
               unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
               is_5p_complete, percent_identity, max_query_gap, max_target_gap,
               number_of_spans, query_start, query_end, target_start, target_end,
               is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
               is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
               tstarts, location_mapping)
         values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?)
SQL

      my $insertHandle = $dbh->prepare($sql) or die $dbh->errstr;
      my ($virtual_target_start, $virtual_target_end, $virtual_tstarts);

      while (my ($blat_alignment_id, $query_na_sequence_id, $target_na_sequence_id,
               $query_table_id, $query_taxon_id, $query_external_db_release_id,
               $target_table_id, $target_taxon_id, $target_external_db_release_id,
               $is_consistent, $is_genomic_contaminant, $unaligned_3p_bases,
               $unaligned_5p_bases, $has_3p_polya, $has_5p_polya, $is_3p_complete,
               $is_5p_complete, $percent_identity, $max_query_gap, $max_target_gap,
               $number_of_spans, $query_start, $query_end, $target_start, $target_end,
               $is_reversed, $query_bases_aligned, $repeat_bases_aligned, $num_ns, $score,
               $is_best_alignment, $blat_alignment_quality_id, $blocksizes, $qstarts,
               $tstarts, $virtual_na_sequence_id, $distance_from_left, $start_position, $end_position,
               $strand_orientation, $length, $virtual_target_table_id)
             = $queryHandle->fetchrow_array()) {

        if ($virtual_na_sequence_id) {
          if ($strand_orientation eq '-') {
            $virtual_target_start = $distance_from_left + $end_position - $target_end + 1;
            $virtual_target_end = $distance_from_left + $end_position - $target_start + 1;
            $virtual_tstarts = &getReversedTstarts($distance_from_left,$end_position,$tstarts,$blocksizes);
            $blocksizes = join(',', reverse split(',', $blocksizes));
            $is_reversed = $is_reversed == 1 ? 0 : 1;
          } else {
            $virtual_target_start = $target_start + $distance_from_left - $start_position + 1;
            $virtual_target_end = $target_end + $distance_from_left - $start_position + 1;
            $virtual_tstarts = join( ',', map{ $_ + $distance_from_left - $start_position + 1 } split( /,/, $tstarts));
          }

          # insert virtual locations
          $insertHandle->execute($blat_alignment_id,
                 $query_na_sequence_id, $virtual_na_sequence_id,
                 $query_table_id, $query_taxon_id, $query_external_db_release_id,
                 $virtual_target_table_id, $target_taxon_id, $target_external_db_release_id,
                 $is_consistent, $is_genomic_contaminant, $unaligned_3p_bases,
                 $unaligned_5p_bases, $has_3p_polya, $has_5p_polya, $is_3p_complete,
                 $is_5p_complete, $percent_identity, $max_query_gap, $max_target_gap,
                 $number_of_spans, $query_start, $query_end, $virtual_target_start,
                 $virtual_target_end,
                 $is_reversed, $query_bases_aligned, $repeat_bases_aligned, $num_ns, $score,
                 $is_best_alignment, $blat_alignment_quality_id, $blocksizes, $qstarts,
                 $virtual_tstarts, 'virtual');
        }
      }

      $insertHandle->finish();
      $queryHandle->finish();

sub getReversedTstarts {
  my($dfl,$len,$tstart,$blocksizes) = @_;
  my @ts = split(',',$tstart);
  my @bs = split(',',$blocksizes);
  my @new;
  
  for(my $a = scalar(@ts) - 1;$a >= 0;$a--){
    push(@new,($dfl + $len - $ts[$a] - $bs[$a] + 2));
  }
  return join(',',@new);
}
      ]]>
    </perl>
  </tuningTable>


  <tuningTable name="BlatProtAlignLocation">
    <comment> BLAT protein alignments. Used by GBrowse for the track proteinAlignment:BLAT
     </comment>
    <internalDependency name="SequencePieceClosure"/>
    <externalDependency name="apidb.BlatProteinAlignment"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.NaSequence"/>
    <sql>
      <![CDATA[
      CREATE TABLE BlatProtAlignLocation&1 NOLOGGING AS
      SELECT blat_protein_alignment_id, query_aa_sequence_id, target_na_sequence_id,
             query_table_id, query_taxon_id, query_external_db_release_id,
             target_table_id, target_taxon_id, target_external_db_release_id,
             is_consistent, is_genomic_contaminant, unaligned_3p_bases,
             unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
             is_5p_complete, percent_identity, max_query_gap, max_target_gap,
             number_of_spans, query_start, query_end, target_start, target_end,
             is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
             is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
             tstarts, cast('direct' as varchar2(7)) as location_mapping
      FROM apidb.BlatProteinAlignment
      ]]>
    </sql>
    <perl>
      <![CDATA[
      use strict;
      use lib "$ENV{GUS_HOME}/lib/perl";

      my $sql = <<SQL;
        select blat_protein_alignment_id, query_aa_sequence_id, target_na_sequence_id,
               query_table_id, query_taxon_id, query_external_db_release_id, 
               target_table_id, target_taxon_id, target_external_db_release_id,
               is_consistent, is_genomic_contaminant, unaligned_3p_bases,
               unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
               is_5p_complete, percent_identity, max_query_gap, max_target_gap,
               number_of_spans, query_start, query_end, target_start, target_end,
               is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
               is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
               tstarts, sp.virtual_na_sequence_id, sp.distance_from_left, sp.start_position, sp.end_position,
               sp.strand_orientation, piece.length, vti.table_id as virtual_target_table_id
        from apidb.blatproteinalignment ba, SequencePieceClosure sp, dots.NaSequence piece,
             dots.NaSequence virtualseq, core.TableInfo vti
        where ba.target_na_sequence_id = sp.piece_na_sequence_id(+)
          and sp.start_position <= target_start
          and sp.end_position >= target_end
          and ba.target_na_sequence_id = piece.na_sequence_id
          and sp.virtual_na_sequence_id = virtualseq.na_sequence_id
          and virtualseq.subclass_view = vti.name
SQL
      
      my $queryHandle = $dbh->prepare($sql) or die $dbh->errstr;
      $queryHandle->execute();

      $sql = <<SQL;
        insert into BlatProtAlignLocation&1(blat_protein_alignment_id,
               query_aa_sequence_id, target_na_sequence_id,
               query_table_id, query_taxon_id, query_external_db_release_id, 
               target_table_id, target_taxon_id, target_external_db_release_id,
               is_consistent, is_genomic_contaminant, unaligned_3p_bases,
               unaligned_5p_bases, has_3p_polya, has_5p_polya, is_3p_complete,
               is_5p_complete, percent_identity, max_query_gap, max_target_gap,
               number_of_spans, query_start, query_end, target_start, target_end,
               is_reversed, query_bases_aligned, repeat_bases_aligned, num_ns, score,
               is_best_alignment, blat_alignment_quality_id, blocksizes, qstarts,
               tstarts, location_mapping)
         values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
                 ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?)
SQL

      my $insertHandle = $dbh->prepare($sql) or die $dbh->errstr;
      my ($virtual_target_start, $virtual_target_end, $virtual_tstarts);

      while (my ($blat_protein_alignment_id, $query_aa_sequence_id, $target_na_sequence_id,
               $query_table_id, $query_taxon_id, $query_external_db_release_id,
               $target_table_id, $target_taxon_id, $target_external_db_release_id,
               $is_consistent, $is_genomic_contaminant, $unaligned_3p_bases,
               $unaligned_5p_bases, $has_3p_polya, $has_5p_polya, $is_3p_complete,
               $is_5p_complete, $percent_identity, $max_query_gap, $max_target_gap,
               $number_of_spans, $query_start, $query_end, $target_start, $target_end,
               $is_reversed, $query_bases_aligned, $repeat_bases_aligned, $num_ns, $score,
               $is_best_alignment, $blat_alignment_quality_id, $blocksizes, $qstarts,
               $tstarts, $virtual_na_sequence_id, $distance_from_left, $start_position, $end_position,
               $strand_orientation, $length, $virtual_target_table_id)
             = $queryHandle->fetchrow_array()) {

        if ($virtual_na_sequence_id) {
          if ($strand_orientation eq '-') {
            $virtual_target_start = $distance_from_left + $end_position - $target_end + 1;
            $virtual_target_end = $distance_from_left + $end_position - $target_start + 1;
            $virtual_tstarts = &getReversedTstarts($distance_from_left,$end_position,$tstarts,$blocksizes);
            $blocksizes = join(',', reverse split(',', $blocksizes));
            $is_reversed = $is_reversed == 1 ? 0 : 1;
          } else {
            $virtual_target_start = $target_start + $distance_from_left - $start_position + 1;
            $virtual_target_end = $target_end + $distance_from_left - $start_position + 1;
            $virtual_tstarts = join( ',', map{ $_ + $distance_from_left - $start_position + 1 } split( /,/, $tstarts));
          }

          # insert virtual locations
          $insertHandle->execute($blat_protein_alignment_id,
                 $query_aa_sequence_id, $virtual_na_sequence_id,
                 $query_table_id, $query_taxon_id, $query_external_db_release_id,
                 $virtual_target_table_id, $target_taxon_id, $target_external_db_release_id,
                 $is_consistent, $is_genomic_contaminant, $unaligned_3p_bases,
                 $unaligned_5p_bases, $has_3p_polya, $has_5p_polya, $is_3p_complete,
                 $is_5p_complete, $percent_identity, $max_query_gap, $max_target_gap,
                 $number_of_spans, $query_start, $query_end, $virtual_target_start,
                 $virtual_target_end,
                 $is_reversed, $query_bases_aligned, $repeat_bases_aligned, $num_ns, $score,
                 $is_best_alignment, $blat_alignment_quality_id, $blocksizes, $qstarts,
                 $virtual_tstarts, 'virtual');
        }
      }

      $insertHandle->finish();
      $queryHandle->finish();

      # create index
      $dbh->do(<<SQL) or die $dbh->errstr;
        create index bpal&1
          on BlatProtAlignLocation&1
          (target_na_sequence_id, target_start, target_end, blat_protein_alignment_id,
           score, is_reversed, query_aa_sequence_id, percent_identity)
        tablespace indx
SQL

sub getReversedTstarts {
  my($dfl,$len,$tstart,$blocksizes) = @_;
  my @ts = split(',',$tstart);
  my @bs = split(',',$blocksizes);
  my @new;

  for(my $a = scalar(@ts) - 1;$a >= 0;$a--){
    push(@new,($dfl + $len - $ts[$a] - $bs[$a] + 2));
  }
  return join(',',@new);
}
      ]]>
    </perl>
  </tuningTable>


  <tuningTable name="EstAlignmentGeneSummary">
    <comment> Each row represents a colocated EST alignment - gene pair. Used by the
         model, by generateGeneMetrics, and in the creation of the
         OrganismAttributes tuning table
     </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <internalDependency name="BlatAlignmentLocation"/>
    <externalDependency name="dots.AssemblySequence"/>
    <externalDependency name="dots.BlatAlignment"/>
    <externalDependency name="dots.Est"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.OntologyTerm"/>
    <intermediateTable name="EstAlignmentGene"/>
    <intermediateTable name="EstAlignmentNoGene"/>
    <sql>
      <![CDATA[
CREATE TABLE EstAlignmentGene NOLOGGING AS
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, e.accession,
         e.library_id, ba.query_taxon_id, ba.target_na_sequence_id,
         ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
         ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
         sequence.source_id AS target_sequence_source_id,
         least(ba.target_end, ga.gene_end_max)
         - greatest(ba.target_start, ga.gene_start_min) + 1
           AS est_gene_overlap_length,
         ba.query_bases_aligned / (query_sequence.length)
         * 100 AS percent_est_bases_aligned,
         ga.gene_source_id AS gene
  FROM BlatAlignmentLocation ba, dots.Est e, dots.AssemblySequence aseq,
       TranscriptAttributes ga, GenomicSeqAttributes sequence,
       dots.NaSequence query_sequence, sres.OntologyTerm so
  WHERE e.na_sequence_id = ba.query_na_sequence_id
    AND aseq.na_sequence_id = ba.query_na_sequence_id
    AND sequence.na_sequence_id = ba.target_na_sequence_id
    AND ga.sequence_id = sequence.source_id
    AND least(ba.target_end, ga.gene_end_max) - greatest(ba.target_start, ga.gene_start_min) >= 0
    AND query_sequence.na_sequence_id = ba.query_na_sequence_id
    AND query_sequence.sequence_ontology_id = so.ontology_term_id
    AND so.name = 'EST'
    AND ba.target_na_sequence_id = sequence.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE EstAlignmentNoGene NOLOGGING AS
SELECT * from EstAlignmentGene WHERE 1=0 UNION /* define datatype for null column */
SELECT ba.blat_alignment_id, ba.query_na_sequence_id, e.accession,
       e.library_id, ba.query_taxon_id, ba.target_na_sequence_id,
       ba.target_taxon_id, ba.percent_identity, ba.is_consistent,
       ba.is_best_alignment, ba.is_reversed, ba.target_start, ba.target_end,
       sequence.source_id AS target_sequence_source_id,
       NULL AS est_gene_overlap_length,
       ba.query_bases_aligned / (query_sequence.length)
       * 100 AS percent_est_bases_aligned,
       NULL AS gene
FROM dots.BlatAlignment ba, dots.Est e, dots.AssemblySequence aseq,
     dots.NaSequence sequence, dots.NaSequence query_sequence
WHERE e.na_sequence_id = ba.query_na_sequence_id
  AND e.na_sequence_id = query_sequence.na_sequence_id
  AND aseq.na_sequence_id = ba.query_na_sequence_id
  AND ba.target_na_sequence_id = sequence.na_sequence_id
  AND ba.blat_alignment_id IN
   ( /* set of blat_alignment_ids not in in first leg of UNION */
    /* (because they overlap no genes) */
    SELECT ba.blat_alignment_id
    FROM dots.BlatAlignment ba, dots.NaSequence query_sequence,
         sres.OntologyTerm so
    WHERE query_sequence.na_sequence_id = ba.query_na_sequence_id
      AND query_sequence.sequence_ontology_id = so.ontology_term_id
      AND so.name = 'EST'
  MINUS
    SELECT blat_alignment_id FROM EstAlignmentGene)
      ]]>
    </sql>
    <sql>
      <![CDATA[
CREATE TABLE EstAlignmentGeneSummary&1 NOLOGGING AS
SELECT * FROM EstAlignmentNoGene
UNION
SELECT * FROM EstAlignmentGene
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index EstSumm_libOverlap_ix&1
             ON EstAlignmentGeneSummary&1
                (library_id, percent_identity, is_consistent,
                 est_gene_overlap_length, percent_est_bases_aligned)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index EstSumm_estSite_ix&1
             ON EstAlignmentGeneSummary&1
                (target_sequence_source_id, target_start, target_end,
                 library_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SnpStrains">
    <comment> Each record captures info for a strain/protocol app node. Used in the model, including
         gene and SNP queries, as well as the gene record. 
     </comment>
    <externalDependency name="apidb.SequenceVariation"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="dots.NaSequence"/>
    <sql>
      <![CDATA[
CREATE TABLE SnpStrains&1 NOLOGGING AS
select distinct pan.name as protocol_app_node_name, pan.protocol_app_node_id, sv.strain, tn.name as organism
from apidb.sequencevariation sv
   , study.protocolappnode pan
   , dots.nasequence s
   , sres.taxonname tn
where pan.protocol_app_node_id = sv.protocol_app_node_id
and sv.ref_na_sequence_id = s.na_sequence_id
and s.taxon_id = tn.taxon_id
and tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX SnpStrains_ix&1 ON SnpStrains&1(strain,organism)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="SnpChipStrains">
    <comment> Each record captures info for a strain/protocol app node. Used in the model, including
         gene and SNP queries, as well as the gene record.
     </comment>
    <externalDependency name="results.SeqVariation"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
CREATE TABLE SnpChipStrains&1 NOLOGGING AS
select distinct pan.name as protocol_app_node_name, pan.protocol_app_node_id, sv.strain, tn.name as organism, ds.subtype as platform
from study.study s
   , study.studylink sl
   , study.protocolappnode pan
   , apidb.datasource ds
   , SRES.EXTERNALDATABASE d
   , SRES.EXTERNALDATABASERELEASE r
   , sres.taxonname tn
   , results.seqvariation sv
where ds.type = 'isolates'
and ds.subtype != 'HTS_SNP'
and ds.name = d.name
and ds.version = r.version
and d.EXTERNAL_DATABASE_ID = r.EXTERNAL_DATABASE_ID
and r.EXTERNAL_DATABASE_RELEASE_ID = s.EXTERNAL_DATABASE_RELEASE_ID
and s.study_id = sl.study_id
and sl.protocol_app_node_id = pan.PROTOCOL_APP_NODE_ID
and ds.taxon_id = tn.taxon_id
and tn.name_class = 'scientific name'
and pan.PROTOCOL_APP_NODE_ID = sv.PROTOCOL_APP_NODE_ID
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX SnpChipStrains_ix&1 ON SnpChipStrains&1(strain,organism,platform)
tablespace indx
      ]]>
    </sql>
  </tuningTable>




  <tuningTable name="PopsetAttributes">
    <comment> The BFMV for the WDK popset record. Widely used in the model for
         queries related to popsets.
     </comment>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="results.SegmentResult"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.Characteristic"/>
    <externalDependency name="study.ProtocolAppNode"/>

    <sql>
      <![CDATA[
        create table PopsetAttributes&1 nologging as
        select ens.source_id, ens.na_sequence_id, pan.protocol_app_node_id,
               sr.segment_result_id, ens.taxon_id, tn.name as organism,
               pan.description, ens.external_database_release_id,
               ed.name as external_db_name, edr.version as external_db_version,
               isolation_source.value as isolation_source,
               cast (null as varchar2(40)) as curated_isolation_source,
               note.value as note,
               gene_name.value as gene_name,
               product.value as product,
               substr(geographic_location.value, 1, 100) as geographic_location,
               geographic_location.country,
               cast (null as varchar2(40)) as curated_country,
               lat_lon.latitude, lat_lon.longitude,
               lat_lon.value as lat_lon,
               pcr_primers.value as pcr_primers,
               host.value as host,
               host_tax_id.ncbi_tax_id as host_ncbi_tax_id,
               popset.value as popset,
               strain.value as strain,
               ens.length
        from dots.ExternalNaSequence ens, results.SegmentResult sr,
             study.ProtocolAppNode pan, sres.TaxonName tn,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'isolation_source') isolation_source,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'note') note,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'gene') gene_name,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'product') product,
             (select c.protocol_app_node_id, c.value,
              substr(substr(c.value, 1, instr(c.value || ':', ':') - 1), 1, 40)
                 as country
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'country') geographic_location,
             (-- geographic coordinates are loaded as strings, e.g. '12.96 S 38.46 W'
              select c.protocol_app_node_id,
                     case
                       when
                         c.value is null then null
                       else
                         to_number(substr(c.value, 1, instr(c.value, ' ') - 1))
                         * case substr(c.value, instr(c.value, ' ') + 1, 1)
                             when 'S' then -1
                             else 1
                           end
                     end as latitude,
                     case
                       when
                         c.value is null then null
                       else
                         to_number(substr(c.value, instr(c.value, ' ', 1, 2) + 1,
                                          instr(substr(c.value, instr(c.value, ' ', 1, 2) + 1, 99), ' ') - 1))
                         * case substr(c.value, -1, 1)
                             when 'W' then -1
                             else 1
                           end
                     end as longitude,
                     c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'lat_lon') lat_lon,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'PCR_primers') pcr_primers,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'host') host,
             (select c.protocol_app_node_id, min(t.ncbi_tax_id) as ncbi_tax_id
              from study.Characteristic c, sres.OntologyTerm ot,
                   sres.TaxonName tn, sres.Taxon t
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'host'
                and c.value = tn.name
                and tn.taxon_id = t.taxon_id
              group by c.protocol_app_node_id) host_tax_id,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'isolate') popset,
             (select c.protocol_app_node_id, c.value
              from study.Characteristic c, sres.OntologyTerm ot
              where c.qualifier_id =ot.ontology_term_id
                and ot.name = 'strain') strain
        where ens.na_sequence_id = sr.na_sequence_id
          and sr.protocol_app_node_id = pan.protocol_app_node_id
          and pan.name = ens.source_id
          and ens.external_database_release_id = edr.external_database_release_id
          and edr.external_database_id = ed.external_database_id
          and ens.taxon_id = tn.taxon_id(+)
          and tn.name_class = 'scientific name'
          and pan.protocol_app_node_id = isolation_source.protocol_app_node_id(+)
          and pan.protocol_app_node_id = note.protocol_app_node_id(+)
          and pan.protocol_app_node_id = gene_name.protocol_app_node_id(+)
          and pan.protocol_app_node_id = product.protocol_app_node_id(+)
          and pan.protocol_app_node_id = geographic_location.protocol_app_node_id(+)
          and pan.protocol_app_node_id = lat_lon.protocol_app_node_id(+)
          and pan.protocol_app_node_id = pcr_primers.protocol_app_node_id(+)
          and pan.protocol_app_node_id = host.protocol_app_node_id(+)
          and pan.protocol_app_node_id = host_tax_id.protocol_app_node_id(+)
          and pan.protocol_app_node_id = popset.protocol_app_node_id(+)
          and pan.protocol_app_node_id = strain.protocol_app_node_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update PopsetAttributes&1
        set curated_country = country
            where country in (select name from sres.OntologyTerm ot)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update PopsetAttributes&1
        set curated_country = (select max(ot.name)
                               from sres.OntologyTerm ot, sres.OntologySynonym os
                               where os.ontology_synonym = PopsetAttributes&1.country
                                 and os.ontology_term_id = ot.ontology_term_id)
        where curated_country is null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update PopsetAttributes&1
        set curated_isolation_source = isolation_source
            where isolation_source in (select name from sres.OntologyTerm ot)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        update PopsetAttributes&1
        set curated_isolation_source =  (select max(ot.name)
                               from sres.OntologyTerm ot, sres.OntologySynonym os
                               where os.ontology_synonym = PopsetAttributes&1.isolation_source
                                 and os.ontology_term_id = ot.ontology_term_id)
        where curated_isolation_source is null 
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index PopsetAttr_sourceId_idx&1
        on PopsetAttributes&1 (source_id)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

<!--
  <tuningTable name="ChIPProtocolParams">
    <comment> Used by the GenesByChipChip(Plasmo|Toxo) query, as well as by GBrowse.
     </comment>
    <externalDependency name="rad.Analysis"/>
    <externalDependency name="rad.AnalysisParam"/>
    <externalDependency name="rad.ProtocolParam"/>
    <sql>
      <![CDATA[
        create table ChIPProtocolParams&1 NOLOGGING AS
select pp.*, e.experiment_name from
(
select a.analysis_id,
       a.protocol_id,
       antbd.antibody as antibody,
       strn.strain as strain,
       treamnt.treatment as treatment,
       replcte.replicate as replicate,
       gentyp.genotype as genotype,
       celltyp.celltype as celltype,
       CASE
          WHEN lower(p.name) like '%peak%' then 'called_peaks'
       ELSE 'raw'
       END as protocol_type
from   rad.analysis a,rad.protocol p,
      (select ap.analysis_id,ap.value as antibody
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'antibody') antbd,
      (select ap.analysis_id,ap.value as strain
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'strain') strn,
      (select ap.analysis_id,ap.value as treatment
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'treatment') treamnt,
      (select ap.analysis_id,ap.value as replicate
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'replicate') replcte,
      (select ap.analysis_id,ap.value as genotype
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'genotype') gentyp,
      (select ap.analysis_id,ap.value as celltype
       from   rad.analysisparam ap,rad.protocolparam pp
       where  ap.protocol_param_id = pp.protocol_param_id
       and    lower(name) like 'celltype') celltyp
where a.protocol_id = p.protocol_id
and p.name in ('ChIP chip Smoothed',
               'ChIP chip Peak Calls',
                /* legacy ones too */
                'NimbleScan_ChIP_Hakimi_called_peaks',
                'NimbleScan_ChIP_Hakimi',
                'NimbleGen_ChIP_Myler_Lmajor',
                'ChIP_chip_Einstein',
                'ChIP_chip_Einstein_called_peaks',
                'ChIP_chip_Einstein_ME1',
                'ChIP_chip_Einstein_ME1_Peak_Calls')
and   a.analysis_id = antbd.analysis_id (+)
and   a.analysis_id = strn.analysis_id (+)
and   a.analysis_id = treamnt.analysis_id (+)
and   a.analysis_id = replcte.analysis_id (+)
and   a.analysis_id = gentyp.analysis_id (+)
and   a.analysis_id = celltyp.analysis_id (+)
) pp, (
select replace(d.name, '_' || a.name || '_chipChipSample_RSRC', '') as experiment_name, a.analysis_id
from sres.ExternalDatabase d, rad.analysis a
where d.name like '%' || a.name ||'%_chipChipSample_RSRC') e
where pp.analysis_id = e.analysis_id (+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index chp_prtparam_idx&1 ON ChIPProtocolParams&1 (analysis_id,protocol_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>
-->

  <tuningTable name="ChIPchipTranscript">
    <comment> Used by the GenesByChipChip(Plasmo|Toxo) query, as well as by
         generateGeneMetrics. Also an input to OrganismAttributes.
     </comment>
    <internalDependency name="TranscriptAttributes"/>
    <externalDependency name="results.SegmentResult"/>
    <externalDependency name="study.StudyLink"/>
    <externalDependency name="study.Study"/>
    <sql>
      <![CDATA[
      create table ChIPchipTranscript&1 NOLOGGING AS
      select distinct ta.source_id, ta.gene_source_id, sr.protocol_app_node_id,
      CASE 
        WHEN ta.is_reversed = 0 
        THEN round(abs(ta.start_min - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)),0)
        ELSE round(abs(ta.end_max - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)),0) 
      END as distance,
      CASE 
        WHEN /* distance > 0 */
          CASE WHEN ta.is_reversed = 0 
            THEN ta.start_min - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)
            ELSE ta.end_max - (((sr.segment_end - sr.segment_start) / 2) + sr.segment_start)
          END > 0 
        THEN 
          CASE 
            WHEN ta.is_reversed = 0 
            THEN '-' 
            ELSE '+'
          END 
        ELSE 
          CASE 
            WHEN ta.is_reversed = 1 
            THEN '-' 
            ELSE '+'
          END 
        END as direction,
      sr.score1 as score
from  TranscriptAttributes ta,
      Results.segmentresult sr,
      Study.StudyLink sl, 
      Study.Study s
where   sr.na_sequence_id = ta.na_sequence_id
  and   s.study_id = sl.study_id
  and   sl.protocol_app_node_id = sr.protocol_app_node_id
  and   lower(s.name) like '%chip%peaks'
  and   ( (ta.is_reversed = 0 and abs((((sr.segment_end - sr.segment_start) / 2) + sr.segment_start) - ta.start_min) <= 3000)
                  or (ta.is_reversed = 1 and abs((((sr.segment_end - sr.segment_start) / 2) + sr.segment_start) - ta.end_max) <= 3000) )
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index chpgene_geneid_idx&1 ON ChIPchipTranscript&1 (protocol_app_node_id, source_id, gene_source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TFBSGene">
    <comment> Used by gene queries, as well as by generateGeneMetrics. Also an input
         to OrganismAttributes.
     </comment>
    <internalDependency name="FeatureLocation"/>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <sql>
      <![CDATA[
        create table TFBSGene&1 NOLOGGING AS
select distinct
      ga.source_id as gene_source_id,
      ga.organism as organism,
      ga.genus_species as species,
      aef.source_id as probe_id,
      aef.na_feature_id as tfbs_na_feature_id,
      CASE 
        WHEN ga.is_reversed = 0 
        THEN round(abs(ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0)
        ELSE round(abs(ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)),0) 
      END as distance,
      CASE 
        WHEN /* distance > 0 */
          CASE WHEN ga.is_reversed = 0 
            THEN ga.start_min - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)
            ELSE ga.end_max - (((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min)
          END > 0 
        THEN 
          CASE 
            WHEN ga.is_reversed = 0 
            THEN '-' 
            ELSE '+'
          END 
        ELSE 
          CASE 
            WHEN ga.is_reversed = 1 
            THEN '-' 
            ELSE '+'
          END 
        END as direction,
        aef.*
from  dots.BindingSiteFeature aef,
      FeatureLocation arrloc,
      GeneAttributes ga
where aef.na_feature_id = arrloc.na_feature_id
and   arrloc.na_sequence_id = ga.na_sequence_id
and   ( (ga.is_reversed = 0 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.start_min) <= 3000)
                  or (ga.is_reversed = 1 and abs((((arrloc.end_max - arrloc.start_min) / 2) + arrloc.start_min) - ga.end_max) <= 3000) )
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index tfbs_geneid_idx&1 ON TFBSGene&1 (gene_source_id, tfbs_na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
       create index geneid_tfbs_idx&1 ON TFBSGene&1 (tfbs_na_feature_id,gene_source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Subcellular">
    <comment> Each record maps a gene onto a subcellular location. Used by
         GenesBySubcellularLocalization.
     </comment>
    <internalDependency name="GeneId"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="dots.PredictedAaFeature"/>
    <sql>
      <![CDATA[
CREATE TABLE Subcellular&1 NOLOGGING AS
select distinct gi.gene as source_id, targetting_domain
from (
select paf.source_id, 'ht' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf
where ed.name in ('subcellular motif from Haldar','pfal3D7_cellularLocation_Haldar_RSRC')
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
union
select paf.source_id, 'pexel' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf
where ed.name in ('subcellular motif from Cowman','pfal3D7_cellularLocation_Cowman_RSRC')
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
union
select paf.source_id, 'apicoplast' as targetting_domain
from sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, dots.PredictedAaFeature paf
where ed.name in ('apicoplast targeting data from 4.4','pfal3D7_cellularLocation_ApicoplastTargeting_RSRC')
  and ed.external_database_id = edr.external_database_id
  and edr.external_database_release_id = paf.external_database_release_id
) sc, GeneId gi
where gi.id = sc.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index subc_ix&1 ON Subcellular&1(source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>




  <tuningTable name="SimilaritySpanLocation">
    <comment> Like dots.SimilaritySpan, except that for sequences that are mapped by
         SequencePiece into parts of other sequences, both locations are stored.
         Used by GBrowse, and also in the creation of the Blastx tuning table.
     </comment>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.SimilaritySpan"/>
    <externalDependency name="core.TableInfo"/>
    <externalDependency name="dots.NaSequence"/>
    <internalDependency name="SequencePieceClosure"/>
    <sql>
      <![CDATA[
create table SimilaritySpanLocation&1 NOLOGGING as
select sim.similarity_id, sim.query_id, sim.subject_id, sim.query_table_id,
       sim.subject_table_id, sim.score as similarity_score, sim.min_query_start,
       sim.max_query_end, sim.is_reversed as similarity_is_reversed,
       sim.pvalue_mant, sim.pvalue_exp,
       round(100 * sim.number_identical / sim.total_match_length,1) as percent_identical,
       round(100 * sim.number_positive / sim.total_match_length,1) as percent_positive,
       sim.min_subject_start, sim.max_subject_end, sim.total_match_length,
       simp.similarity_span_id, simp.score as span_score, simp.query_start, simp.query_end,
       simp.subject_start, simp.subject_end,
       simp.is_reversed as span_is_reversed,
       'direct' as location_mapping
from dots.similarity sim, dots.similarityspan simp, core.TableInfo ti
where sim.similarity_id = simp.similarity_id
  and sim.query_table_id = ti.table_id
  and ti.name = 'ExternalNASequence'
union
select sim.similarity_id, scaffold.na_sequence_id as query_id, sim.subject_id,
       sim.query_table_id,
       sim.subject_table_id, sim.score as similarity_score,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - greatest(sim.min_query_start, sim.max_query_end) + 1
           else sp.distance_from_left + least(sim.min_query_start, sim.max_query_end) - sp.start_position + 1
       end as min_query_start,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - least(sim.min_query_start, sim.max_query_end) + 1
           else sp.distance_from_left + greatest(sim.min_query_start, sim.max_query_end) - sp.start_position + 1
       end as max_query_end,
       sim.is_reversed, sim.pvalue_mant, sim.pvalue_exp,
       round(100 * sim.number_identical / sim.total_match_length,1) as percent_identical,
       round(100 * sim.number_positive / sim.total_match_length,1) as percent_positive,
       sim.min_subject_start, sim.max_subject_end, sim.total_match_length, 
       simp.similarity_span_id, simp.score as span_score,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - greatest(simp.query_start, simp.query_end) + 1
           else sp.distance_from_left + least(simp.query_start, simp.query_end) - sp.start_position + 1
       end as query_start,
       case
         when sp.strand_orientation in ('-', '-1')
           then sp.distance_from_left + sp.end_position - least(simp.query_start, simp.query_end) + 1
           else sp.distance_from_left + greatest(simp.query_start, simp.query_end) - sp.start_position + 1
       end as query_end,
       simp.subject_start, simp.subject_end,
       simp.is_reversed as span_is_reversed,
       'virtual' as location_mapping
from dots.similarity sim, dots.similarityspan simp, core.TableInfo ti,
     dots.NaSequence contig, &prefixSequencePieceClosure sp, dots.NaSequence scaffold
where sim.similarity_id = simp.similarity_id
  and sim.query_table_id = ti.table_id
  and ti.name = 'ExternalNASequence'
  and sim.query_id = sp.piece_na_sequence_id
  and sp.start_position <= sim.min_query_start
  and sp.end_position >= sim.max_query_end
  and sim.query_id = contig.na_sequence_id
  and sp.virtual_na_sequence_id = scaffold.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
update SimilaritySpanLocation&1
set pvalue_exp = (select min(pvalue_exp) from SimilaritySpanLocation&1)
where pvalue_mant = 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index spanloc_query_ix&1
        on SimilaritySpanLocation&1 (query_id, min_query_start, max_query_end, query_table_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SnpAttributesDoTS">
    <comment>
         SNP Chip only, such as Plasmo barcode, 3k_chp and hd_array

         Each record represents one SNP. Widely used in the model, as well as in
         the creation of several other tuning tables
     </comment>
    <internalDependency name="FeatureLocation"/>
    <internalDependency name="ProjectTaxon"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.SnpFeature"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
CREATE TABLE SnpAttributesDoTS&1 NOLOGGING AS
SELECT cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       snp.source_id,
       snp.na_feature_id,
       ed.name AS dataset,
       snp.name as type,
       ds.subtype as platform,
       sequence.na_sequence_id,
       sequence.source_id AS seq_source_id,
       snp_loc.start_min,
       SUBSTR(snp.reference_strain, 1, 200) AS reference_strain,
       SUBSTR(snp.reference_na, 1, 200) AS reference_na,
       snp.is_coding,
       snp.position_in_CDS,
       snp.position_in_protein,
       SUBSTR(snp.reference_aa, 1, 200) AS reference_aa,
       DECODE(snp.has_nonsynonymous_allele, 0, 'no', 1, 'yes')
         AS has_nonsynonymous_allele,
       SUBSTR(snp.major_allele, 1, 40) AS major_allele,
       SUBSTR(snp.major_product, 1, 40) AS major_product,
       snp.major_allele_count, 
       round(snp.major_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as major_allele_frequency,
       SUBSTR(snp.minor_allele, 1, 40) AS minor_allele,
       SUBSTR(snp.minor_product, 1, 40) AS minor_product,
       snp.minor_allele_count,
       round(snp.minor_allele_count / (snp.major_allele_count + snp.minor_allele_count),2) as minor_allele_frequency,
       gene_info.source_id AS gene_source_id,
       DECODE(gene_info.is_reversed, 0, 'forward', 1, 'reverse')
         AS gene_strand,
       to_char(SUBSTR(sequence.sequence, snp_loc.start_min - 30, 30)) AS lflank,
       to_char(SUBSTR(sequence.sequence, snp_loc.start_min + 1, 30)) AS rflank,
       SUBSTR(tn.name, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       SUBSTR(chromosome_info.chromosome, 1, 20) AS chromosome,
       chromosome_info.chromosome_order_num
FROM dots.SnpFeature snp, sres.ontologyterm so, FeatureLocation snp_loc,
     sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr, sres.Taxon,
     sres.TaxonName tn, dots.NaSequence sequence, apidb.datasource ds,
     (SELECT gene.source_id, gene_loc.is_reversed, gene.na_feature_id,
             gene_loc.na_sequence_id
      FROM dots.GeneFeature gene, &prefixFeatureLocation gene_loc
      WHERE gene.na_feature_id = gene_loc.na_feature_id
            and gene_loc.is_top_level = 1) gene_info,
     (SELECT na_sequence_id, chromosome, chromosome_order_num
      FROM dots.ExternalNaSequence
     UNION
      SELECT na_sequence_id, chromosome, chromosome_order_num
      FROM dots.VirtualSequence
     UNION
      SELECT na_sequence_id, null as chromosome, null as chromosome_order_num
      FROM dots.NaSequence
      WHERE subclass_view not in ('ExternalNASequence', 'VirtualSequence')
     ) chromosome_info
WHERE edr.external_database_release_id = snp.external_database_release_id
  AND ed.external_database_id = edr.external_database_id
  AND ed.name = ds.name
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
  AND snp_loc.na_feature_id = snp.na_feature_id
  AND snp_loc.is_top_level = 1
  AND sequence.na_sequence_id = snp_loc.na_sequence_id
  AND chromosome_info.na_sequence_id = snp_loc.na_sequence_id
  AND gene_info.na_feature_id(+) = snp.parent_id
  AND snp.sequence_ontology_id = so.ontology_term_id
  AND so.name != 'indel'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index SnpAttrDots_source_id&1 ON SnpAttributesDoTS&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpDots_nafeat_dataset_ix&1
       ON SnpAttributesDoTS&1 (na_feature_id, dataset)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpDoTS_Seq_ix&1
       ON SnpAttributesDoTS&1 (na_sequence_id, dataset, start_min, na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpDoTS_Freq_ix&1
       ON SnpAttributesDoTS&1 (dataset,major_allele_frequency,minor_allele_frequency)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpAttrdots_ds_org_ix&1 on snpattributesdots&1 (dataset,organism,na_feature_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index SnpDotsVariantIx&1 on SnpAttributesDoTS&1 (type, dataset, na_feature_id, source_id, gene_source_id, start_min, position_in_protein)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
 create or replace view snpchipattributes as
  select * from snpattributesdots&1
  where platform in ('Broad_3k_array','Broad_75K_array','NIH_10k','Broad_barcode')
      ]]>
    </sql>
    <sql>
      <![CDATA[
   GRANT SELECT ON snpchipattributes TO gus_r
      ]]>
    </sql>


  </tuningTable>



  <tuningTable name="Blastp">
    <comment> Each record stores a Blastp similarity of a gene. Used by the gene-page
         Blastp table. 
     </comment>
    <externalDependency name="dots.Similarity"/>
    <externalDependency name="dots.ExternalAaSequence"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="core.TableInfo"/>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <sql>
      <![CDATA[
create table Blastp&1 nologging as
select rownum as blastp_id, ga.source_id, ga.gene_source_id, ga.project_id, sim.similarity_id,
       subject.source_id as subject_source_id, sim.score score, sim.query_id, 
       sim.min_query_start, sim.max_query_end, sim.pvalue_mant, sim.pvalue_exp,
       sim.number_identical, sim.total_match_length,
       substr(replace(subject.description, chr(1), ''), 1, 300) as description,
       sim.number_positive, ed.name as external_database_name,
       substr(tn.name, 1, 50) AS query_organism, ns.taxon_id as query_taxon_id
from dots.Similarity sim, core.TableInfo qti, core.TableInfo sti, dots.ExternalAaSequence subject,
     dots.Transcript t, dots.TranslatedAaFeature taf,
     sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
     dots.NaSequence ns, /* TaxonSpecies st, */
     sres.TaxonName tn, TranscriptAttributes ga
where qti.table_id = sim.query_table_id
  and qti.name = 'TranslatedAASequence'
  and sti.table_id = sim.subject_table_id
  and sti.name = 'ExternalAASequence'
  and subject.aa_sequence_id = sim.subject_id
  and ga.na_feature_id = t.na_feature_id
  and t.na_feature_id = taf.na_feature_id
  and taf.aa_sequence_id = sim.query_id
  and subject.external_database_release_id = edr.external_database_release_id
  and edr.external_database_id = ed.external_database_id
  and ga.na_sequence_id = ns.na_sequence_id
  and ns.taxon_id =
/*    st.taxon_id and st.species_taxon_id = # TaxonSpecies mapping commented out */
                     tn.taxon_id
  and tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
update Blastp&1
set pvalue_exp = (select min(pvalue_exp) from Blastp&1)
where pvalue_mant = 0
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Blastp_src_ix&1 on Blastp&1 (source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Blastp_query_ix&1 on Blastp&1 (query_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index Blastp_text_ix&1 on Blastp&1(description) indextype is ctxsys.context
             parameters('DATASTORE CTXSYS.DEFAULT_DATASTORE')
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GenePopsetOverlap">
    <comment> Each record stores a colocated (gene, popset) 2-tuple. Used by the
         gene page as well as the PopsetByOverlap query.
     </comment>
    <internalDependency name="PopsetAttributes"/>
    <internalDependency name="FeatureLocation"/>
    <externalDependency name="dots.Similarity"/>
    <sql>
      <![CDATA[
create table GenePopsetOverlap&1 nologging as
select substr(ia.source_id, 1, 30) as popset_source_id,
       fl.feature_source_id as gene_source_id,
       min(pvalue_exp) as min_pvalue_exp
from PopsetAttributes ia, dots.Similarity sim, FeatureLocation fl
where fl.feature_type = 'GeneFeature'
  and fl.na_sequence_id = sim.subject_id
  and fl.start_min < sim.max_subject_end
  and fl.end_max > sim.min_subject_start
  and sim.query_id = ia.na_sequence_id
group by ia.source_id, fl.feature_source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index gi_i_ix&1 on GenePopsetOverlap&1 (popset_source_id)
tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index gi_g_ix&1 on GenePopsetOverlap&1 (gene_source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>



  <tuningTable name="TaxonSpecies" prefixEnabled="true">
    <comment>Each record maps a taxon_id of interest onto the taxon_id that taxon's
         taxon-tree ancestor whose rank is "species". Used by
         buildAnnotationChangeTT and by gene queries, as well as an input in the
         creation of several tuning tables, including GeneAttributes and
         OrganismTree.
    </comment>
    <internalDependency name="GenomicSeqAttributes"/>
    <externalDependency name="sres.Taxon"/>
    <sql>
      <![CDATA[
create table &prefixTaxonSpecies&1 nologging as
select t.taxon_id, species.taxon_id as species_taxon_id
from sres.Taxon species, (select distinct sa.taxon_id
      from &prefixGenomicSeqAttributes sa) t
where species.taxon_id in (select taxon_id from sres.Taxon
                           connect by taxon_id = prior parent_id and prior rank != 'species'
                           start with taxon_id = t.taxon_id)
  and species.rank = 'species'
      ]]>
    </sql>
  </tuningTable>



  <tuningTable name="Blastx">
    <comment> Each record stores a Blastx similarity. Used by GBrowse for the
         match:WU_BLASTX track.
     </comment>
    <externalDependency name="dots.ExternalAaSequence"/>
    <externalDependency name="dots.NaSequence"/>
    <internalDependency name="SimilaritySpanLocation"/>
    <sql>
      <![CDATA[
create table Blastx&1
      (similarity_id, name, score, pvalue, na_sequence_id, startm, end, strand, atts,
       constraint blastx&1_pk primary key(na_sequence_id, startm, pvalue, end, similarity_id))
organization index
nologging
as
select distinct sim.similarity_id,
       extt.source_id name, 
       substr(sim.similarity_score || '', 1, 6) score, 
       to_number(sim.pvalue_mant || 'e' || sim.pvalue_exp) pvalue,
       extq.na_sequence_id,
       sim.min_query_start startm, 
       sim.max_query_end end, 
       decode (sim.similarity_is_reversed, 0, '+1', 1, '-1', '.') strand, 
       substr('Score=' || sim.similarity_score || ';;' || 
              'Expect=' || (sim.pvalue_mant || 'e' ||sim.pvalue_exp)||';;'|| 
              'Defline=' || extt.description || ';;' || 
              'PercentIdentity=' || sim.percent_identical || ';;' ||
              'PercentPositive=' || sim.percent_positive || ';;' ||
              'TStart=' || sim.min_query_start || ';;' || 
              'TStop=' || sim.max_query_end, 1, 400) atts 
from SimilaritySpanLocation sim, dots.ExternalAaSequence extt, 
     dots.NaSequence extq
where sim.query_id = extq.na_sequence_id
  and sim.subject_id = extt.aa_sequence_id
  and (sim.max_query_end - sim.min_query_start) < 5000
  and sim.pvalue_exp < -10
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TranscriptSequence" prefixEnabled="true">
    <comment> Each record stores the transcript sequence of one gene. Used by the
         gene record and the sequence retrieval tool. Propagated to the portal.
     </comment>
    <externalDependency name="dots.SplicedNaSequence"/>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixTranscriptSequence&1 NOLOGGING AS
SELECT ta.transcript_source_id AS source_id, ta.project_id, sns.sequence
FROM &prefixTranscriptAttributes ta, dots.SplicedNaSequence sns
WHERE ta.transcript_source_id = sns.source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index XScriptSeq_ix&1 on &prefixTranscriptSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="CodingSequence">
    <comment> Each record stores the coding sequence of one gene. Used by the
         gene record and the sequence retrieval tool. Propagated to the portal.
     </comment>
    <externalDependency name="dots.SplicedNaSequence"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE CodingSequence&1 NOLOGGING AS
SELECT ta.transcript_source_id  AS source_id, ta.project_id,
       SUBSTR(sns.sequence, tf.translation_start,                            
              tf.translation_stop - tf.translation_start + 1) as sequence
FROM TranscriptAttributes ta, dots.SplicedNaSequence sns, dots.TranslatedAaFeature tf
WHERE ta.transcript_source_id = sns.source_id
 AND ta.na_feature_id = tf.na_feature_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index CodSeq_ix&1 on CodingSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProteinSequence">
    <comment> Each record stores the coding sequence of one gene. Used by the
         gene record and the sequence retrieval tool, as well as by
         buildTrackOldAnnotationTT. Propagated to the portal.
     </comment>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <internalDependency name="ProteinAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE ProteinSequence&1 NOLOGGING AS
WITH pAttr AS (
   SELECT distinct source_id, aa_sequence_id
   FROM ProteinAttributes)
SELECT pa.source_id, pi.name AS project_id, tas.sequence
FROM pAttr pa, dots.TranslatedAaSequence tas, core.Projectinfo pi
WHERE pa.aa_sequence_id = tas.aa_sequence_id
  AND pi.project_id = tas.row_project_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index ProtSeq_ix&1 on ProteinSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GenomicSequenceSequence">
    <comment> Each record stores the nucleotide sequence for one genomic sequence
         that is "official" (in the sense that it can be instantiated as a WDK
         sequence record. Used by generatePathoLogicFile and the sequence
         retrieval tool Propagated to portal instances.
     </comment>
    <internalDependency name="ProjectTaxon"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE GenomicSequenceSequence&1 NOLOGGING AS
SELECT sa.source_id, cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ns.sequence
FROM GenomicSeqAttributes sa, dots.NaSequence ns, sres.TaxonName tn
WHERE sa.na_sequence_id = ns.na_sequence_id
  AND ns.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GenomicSeq_ix&1 on GenomicSequenceSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrfSequence">
    <comment> Each record stores the amino-acid sequence of an ORF. Used by the
         relevant attribute query of the WDK ORF record, as well as by the
         sequence retrieval tool. Propagated to portal instances.
     </comment>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <internalDependency name="OrfAttributes"/>
    <sql>
      <![CDATA[
CREATE TABLE OrfSequence&1 NOLOGGING AS
SELECT oa.source_id,
       oa.project_id,
       ts.sequence
FROM dots.TranslatedAaSequence ts
            , dots.TranslatedAaFeature tf
            , OrfAttributes oa
 WHERE oa.na_feature_id = tf.na_feature_id
   AND tf.aa_sequence_id = ts.aa_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index OrfSeq_ix&1 on OrfSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="EstSequence">
    <comment> Each record stores the nucleotide sequence of an EST, for use by the
         relevant attribute query in the WDK EST record. Propagated to portal
         instances.
     </comment>
    <internalDependency name="ProjectTaxon"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE EstSequence&1 NOLOGGING AS
SELECT ens.source_id,
       cast(apidb.project_id(tn.name) as varchar2(20)) as project_id,
       ens.sequence
FROM dots.ExternalNaSequence ens, sres.OntologyTerm oterm, sres.TaxonName tn
WHERE oterm.name = 'EST'
  AND oterm.ontology_term_id = ens.sequence_ontology_id
  AND ens.taxon_id = tn.taxon_id
  AND tn.name_class = 'scientific name'
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index EstSeq_ix&1 on EstSequence&1 (source_id, project_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  
  <tuningTable name="GeneIntronPercent">
    <comment>Contained introns from Gsnap with percentages of max intron score
    </comment>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="ProfileSamples"/>
    <externalDependency name="apidb.IntronJunction"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <sql>
      <![CDATA[
create table &prefixGeneIntronPercent&1 NOLOGGING AS
select na_sequence_id,mapping_start,mapping_end,max(score) as score,min(gene_percentage) as intron_percent,
  max(total_exp) as total_fpkm, CASE WHEN max(total_exp) = 0 THEN 0 ELSE max(score) /  max(total_exp) END as score_exp_ratio
from (
with core as 
(select ga.na_feature_id,rif.na_sequence_id,rif.segment_start as mapping_start,rif.segment_end as mapping_end,sum(rif.unique_reads) as score
    FROM   apidb.IntronJunction rif, 
         apidbtuning.geneattributes ga
  WHERE ga.na_sequence_id = rif.na_sequence_id
     and rif.segment_start <= ga.end_max
     and rif.segment_end >= ga.start_min
     and rif.segment_end - rif.segment_start < 10000
  GROUP BY ga.na_feature_id,rif.na_sequence_id, rif.segment_end, rif.segment_start
  having sum(rif.unique_reads) > 1)
  select o.na_sequence_id,o.mapping_start,o.mapping_end,o.score,round(100 * o.score / mscore.max_score,1) as gene_percentage,sum_score as gene_sum_score,
  avg_score as gene_avg_score,exp.total_exp
from
  (select nafe.na_feature_id,round(sum(nafe.value),1) as total_exp
    from study.protocolappnode pan, results.nafeatureexpression nafe, apidbtuning.ProfileSamples ps
    where (pan.name like '%htseq-union - firststrand - fpkm%'
    or pan.name like '%htseq-union - unstranded - fpkm%')
    and Pan.Protocol_App_Node_Id = Ps.Protocol_App_Node_Id
    and ps.profile_type = 'values'
    and Pan.Protocol_App_Node_Id = nafe.Protocol_App_Node_Id
   group by nafe.na_feature_id) exp,
  (select na_feature_id,max(score) as max_score,sum(score) as sum_score,round(avg(score),1) as avg_score 
   from core 
   group by na_feature_id) mscore,
   core o
   where o.na_feature_id = mscore.na_feature_id
   and exp.na_feature_id = o.na_feature_id)
   group by na_sequence_id,mapping_start,mapping_end
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneIntronPerc_ix&1 on GeneIntronPercent&1 (na_sequence_id,mapping_start,mapping_end)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="GeneIntronPercCont">
    <comment>Contained introns from Gsnap with percentages of max intron score
    </comment>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="ProfileSamples"/>
    <externalDependency name="apidb.IntronJunction"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <sql>
      <![CDATA[
create table &prefixGeneIntronPercCont&1 NOLOGGING AS
select na_sequence_id,mapping_start,mapping_end,max(score) as score,min(gene_percentage) as intron_percent,
  max(unique_reads) as unique_reads,min(unique_percent) as unique_percent,
  max(total_exp) as total_fpkm, CASE WHEN max(total_exp) = 0 THEN 0 ELSE round(max(score) /  max(total_exp),6) END as score_exp_ratio
from (
with core as 
(select ga.na_feature_id,rif.na_sequence_id,rif.segment_start as mapping_start,rif.segment_end as mapping_end,sum(rif.unique_reads) as score,sum(rif.unique_reads) as unique_reads
    FROM   apidb.IntronJunction rif, 
         apidbtuning.geneattributes ga
  WHERE ga.na_sequence_id = rif.na_sequence_id
     and rif.segment_start >= ga.start_min - 50
     and rif.segment_end <= ga.end_max + 50
     and rif.segment_end - rif.segment_start < 10000
  GROUP BY ga.na_feature_id,rif.na_sequence_id, rif.segment_end, rif.segment_start
  having sum(rif.unique_reads) > 1)
  select o.na_sequence_id,o.mapping_start,o.mapping_end,o.score,round(100 * o.score / mscore.max_score,1) as gene_percentage,sum_score as gene_sum_score,
  o.unique_reads,CASE WHEN mscore.max_unique = 0 THEN 0 ELSE round(100 * o.unique_reads / mscore.max_unique,1) END as unique_percent,
  avg_score as gene_avg_score,exp.total_exp
from
  (select nafe.na_feature_id,round(sum(nafe.value),1) as total_exp
    from study.protocolappnode pan, results.nafeatureexpression nafe, apidbtuning.ProfileSamples ps
    where (pan.name like '%htseq-union - firststrand - fpkm%'
    or pan.name like '%htseq-union - unstranded - fpkm%')
    and Pan.Protocol_App_Node_Id = Ps.Protocol_App_Node_Id
    and ps.profile_type = 'values'
    and Pan.Protocol_App_Node_Id = nafe.Protocol_App_Node_Id
   group by nafe.na_feature_id) exp,
  (select na_feature_id,max(score) as max_score,sum(score) as sum_score,sum(unique_reads) as unique_reads,
      max(unique_reads) as max_unique, round(avg(score),1) as avg_score 
   from core 
   group by na_feature_id) mscore,
   core o
   where o.na_feature_id = mscore.na_feature_id
   and exp.na_feature_id = o.na_feature_id)
   group by na_sequence_id,mapping_start,mapping_end
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index GeneIntronPercCont_ix&1 on GeneIntronPercCont&1 (na_sequence_id,mapping_start,mapping_end)
tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="TranscriptLocation" prefixEnabled="true">
    <comment>Genomic locations of transcripts
    </comment>
    <externalDependency name="dots.AaFeatureExon"/>
    <externalDependency name="dots.ExonFeature"/>
    <externalDependency name="dots.GeneFeature"/>
    <externalDependency name="dots.NaLocation"/>
    <externalDependency name="dots.NaSequence"/>
    <externalDependency name="dots.RnaFeatureExon"/>
    <externalDependency name="dots.SequencePiece"/>
    <externalDependency name="dots.Transcript"/>
    <externalDependency name="dots.TranslatedAaFeature"/>
    <externalDependency name="dots.TranslatedAaSequence"/>
    <ancillaryTable name="CdsLocation"/>
    <ancillaryTable name="GeneLocation"/>
    <ancillaryTable name="ExonLocation"/>
    <ancillaryTable name="UtrLocation"/>
    <ancillaryTable name="IntronLocation"/>
    <sql>
      <![CDATA[
        create table &prefixGeneLocation&1 (
          feature_source_id            varchar2(80),
          sequence_source_id           varchar2(50),
          na_sequence_id               number(10),
          na_feature_id                number(10),
          start_min                    number,
          end_max                      number,
          is_reversed                  number(1),
          sequence_ontology_id         number(10),
          external_database_release_id number(10),
          is_top_level                 number
        )
      ]]>
    </sql>

    <sql>
      <![CDATA[
        create table &prefixTranscriptLocation&1 (
          feature_source_id            varchar2(80),
          sequence_source_id           varchar2(50),
          na_sequence_id               number(10),
          na_feature_id                number(10),
          start_min                    number,
          end_max                      number,
          is_reversed                  number(1),
          parent_id                    number(10),
          external_database_release_id number(10),
          is_top_level                 number
        )
      ]]>
    </sql>

    <sql>
      <![CDATA[
        create table &prefixExonLocation&1 (
          feature_source_id            varchar2(80),
          sequence_source_id           varchar2(50),
          na_sequence_id               number(10),
          na_feature_id                number(10),
          start_min                    number,
          end_max                      number,
          is_reversed                  number(1),
          parent_id                    number(10),
          external_database_release_id number(10),
          is_top_level                 number
        )
      ]]>
    </sql>

    <sql>
      <![CDATA[
        create table &prefixCdsLocation&1 (
          protein_source_id            varchar2(80),
          transcript_source_id         varchar2(80),
          sequence_source_id           varchar2(50),
          na_sequence_id               number(10),
          start_min                    number,
          end_max                      number,
          is_reversed                  number(1),
          parent_id                    number(10),
          external_database_release_id number(10),
          is_top_level                 number
        )
      ]]>
    </sql>

    <sql>
      <![CDATA[
        create table &prefixUtrLocation&1 (
          sequence_source_id           varchar2(50),
          na_sequence_id               number(10),
          start_min                    number,
          end_max                      number,
          is_reversed                  number(1),
          direction                    number(1),
          parent_id                    number(10),
          external_database_release_id number(10),
          is_top_level                 number
        )
      ]]>
    </sql>

    <sql>
      <![CDATA[
        create table &prefixIntronLocation&1 (
          sequence_source_id           varchar2(50),
          na_sequence_id               number(10),
          start_min                    number,
          end_max                      number,
          is_reversed                  number(1),
          parent_id                    number(10),
          external_database_release_id number(10),
          is_top_level                 number
        )
      ]]>
    </sql>

    <perl>
      <![CDATA[
      use strict;
      use lib "$ENV{GUS_HOME}/lib/perl";
      use GUS::Community::GeneModelLocations;

      my $geneInsert = $dbh->prepare(<<SQL) or die $dbh->errstr;
        insert into &prefixGeneLocation&1
            (feature_source_id, sequence_source_id, na_sequence_id, na_feature_id,
             start_min, end_max, is_reversed, is_top_level,
             sequence_ontology_id, external_database_release_id)
        values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
SQL

      my $transcriptInsert = $dbh->prepare(<<SQL) or die $dbh->errstr;
        insert into &prefixTranscriptLocation&1
            (feature_source_id, sequence_source_id, na_sequence_id, na_feature_id,
             start_min, end_max, is_reversed, parent_id, is_top_level, external_database_release_id)
        values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
SQL

      my $exonInsert = $dbh->prepare(<<SQL) or die $dbh->errstr;
        insert into &prefixExonLocation&1
            (feature_source_id, sequence_source_id, na_sequence_id, na_feature_id, 
             start_min, end_max, is_reversed, parent_id,
             external_database_release_id, is_top_level)
        values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
SQL

      my $cdsInsert = $dbh->prepare(<<SQL) or die $dbh->errstr;
        insert into &prefixCdsLocation&1
            (transcript_source_id, protein_source_id, sequence_source_id, na_sequence_id,
             start_min, end_max, is_reversed, parent_id, is_top_level, external_database_release_id)
        values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
SQL

      my $utrInsert = $dbh->prepare(<<SQL) or die $dbh->errstr;
        insert into &prefixUtrLocation&1
            (sequence_source_id, na_sequence_id,
             start_min, end_max, is_reversed, direction, parent_id,
             external_database_release_id, is_top_level)
        values (?, ?, ?, ?, ?, ?, ?, ?, ?)
SQL


      my $intronInsert = $dbh->prepare(<<SQL) or die $dbh->errstr;
        insert into &prefixIntronLocation&1
            (sequence_source_id, na_sequence_id,
             start_min, end_max, is_reversed, parent_id,
             external_database_release_id, is_top_level)
        values (?, ?, ?, ?, ?, ?, ?, ?)
SQL

      my $soQuery = $dbh->prepare(<<SQL) or die $dbh->errstr;
      select na_feature_id, sequence_ontology_id from dots.GeneFeature
SQL

    my $edrQuery = $dbh->prepare(<<SQL) or die $dbh->errstr;
select distinct gf.external_database_release_id, gf.is_predicted from dots.geneFeature gf
SQL

      $soQuery->execute();
      my %geneSoMap;
      while(my ($featureId, $so) = $soQuery->fetchrow_array()) {
        $geneSoMap{$featureId} = $so;
      }
      $soQuery->finish();
 
      $edrQuery->execute();

      while (my ($genomeExtDbRlsId, $isPredicted) = $edrQuery->fetchrow_array()) {
        foreach my $isTopLevel ((0, 1)) {
          my $geneModelLocations = GUS::Community::GeneModelLocations->new($dbh, $genomeExtDbRlsId, $isTopLevel);

          my $geneList = $geneModelLocations->getAllGeneIds();
          foreach my $geneId (@$geneList) {

            # still use this for the sequence_is_piece
            my $gmh = $geneModelLocations->getGeneModelHashFromGeneSourceId($geneId);

            my $bioperlFeatures = $geneModelLocations->bioperlFeaturesFromGeneSourceId($geneId);

            next if $isTopLevel == 0 && $gmh->{sequence_is_piece} == 0;


            foreach my $feature (@$bioperlFeatures) {
              if($feature->primary_tag eq 'gene') {

                my ($geneNaFeatureId) = $feature->get_tag_values("NA_FEATURE_ID");
                my $seqOntId = $geneSoMap{$geneNaFeatureId};

                $geneInsert->execute(
                  ($feature->get_tag_values("ID"))[0], # feature_source_id
                  $feature->seq_id(), # sequence_source_id
                  ($feature->get_tag_values("NA_SEQUENCE_ID"))[0], # na_sequence_id
                  ($feature->get_tag_values("NA_FEATURE_ID"))[0], # na_feature_id
                  $feature->start(),
                  $feature->end(),
                  $feature->strand() == -1 ? 1 : 0, #is_reversed
                  $isTopLevel, # is_top_level
                  $seqOntId, # sequence_ontology_id
                  $genomeExtDbRlsId # external_database_release_id
                    )
                    or die $dbh->errstr;
              }

              if($feature->primary_tag() eq 'CDS') {
                $cdsInsert->execute(
                  ($feature->get_tag_values("PARENT"))[0], # transcript_source_id
                  ($feature->get_tag_values("ID"))[0], # protein_source_id
                  $feature->seq_id(), # sequence_source_id
                  ($feature->get_tag_values("NA_SEQUENCE_ID"))[0], # na_sequence_id
                  $feature->start(),
                  $feature->end(),
                  $feature->strand() == -1 ? 1 : 0, #is_reversed
                  ($feature->get_tag_values("PARENT_NA_FEATURE_ID"))[0], # parent_id
                  $isTopLevel, # is_top_level
                  $genomeExtDbRlsId, # external_database_release_id
                    )
                    or die $dbh->errstr;
              }


              if($feature->primary_tag() =~ /utr(3|5)prime/) {
                my $utrDirection = $1;
                $utrInsert->execute(
                  $feature->seq_id(), # sequence_source_id
                  ($feature->get_tag_values("NA_SEQUENCE_ID"))[0], # na_sequence_id
                  $feature->start(),
                  $feature->end(),
                  $feature->strand() == -1 ? 1 : 0, #is_reversed
                  $utrDirection,
                  ($feature->get_tag_values("PARENT_NA_FEATURE_ID"))[0], # parent_id
                  $genomeExtDbRlsId, # external_database_release_id
                  $isTopLevel, # is_top_level
                    )
                    or die $dbh->errstr;
              }

              if($feature->primary_tag() eq 'transcript') {

                $transcriptInsert->execute(
                  ($feature->get_tag_values("ID"))[0], # feature_source_id
                  $feature->seq_id(), # sequence_source_id
                  ($feature->get_tag_values("NA_SEQUENCE_ID"))[0], # na_sequence_id
                  ($feature->get_tag_values("NA_FEATURE_ID"))[0], # na_feature_id
                  $feature->start(),
                  $feature->end(),
                  $feature->strand() == -1 ? 1 : 0, #is_reversed
                  ($feature->get_tag_values("PARENT_NA_FEATURE_ID"))[0], # parent_id
                  $isTopLevel, # is_top_level
                  $genomeExtDbRlsId, # external_database_release_id
                    )
                    or die $dbh->errstr;

                # have bioperl calculate the intron coords for the transcript
                # NOTE:  the parent of the intron will be the transcript not the gene (may be some redundancy)

                unless($isPredicted) {
                  foreach my $intron ($feature->introns()) {
                    my $intronLocation = $intron->location();

                    $intronInsert->execute(
                    $feature->seq_id(), # sequence_source_id
                    ($feature->get_tag_values("NA_SEQUENCE_ID"))[0], # na_sequence_id
                    $intronLocation->start(),
                    $intronLocation->end(),
                    $feature->strand() == -1 ? 1 : 0, #is_reversed
                    ($feature->get_tag_values("NA_FEATURE_ID"))[0], # parent_id
                    $genomeExtDbRlsId, # external_database_release_id
                    $isTopLevel, # is_top_level
                      )
                      or die $dbh->errstr;
                  }
                }
              }

              if($feature->primary_tag() eq 'exon') {
                $exonInsert->execute(
                  ($feature->get_tag_values("ID"))[0], # feature_source_id
                  $feature->seq_id(), # sequence_source_id
                  ($feature->get_tag_values("NA_SEQUENCE_ID"))[0], # na_sequence_id
                  ($feature->get_tag_values("NA_FEATURE_ID"))[0], # na_feature_id
                  $feature->start(),
                  $feature->end(),
                  $feature->strand() == -1 ? 1 : 0, #is_reversed
                  ($feature->get_tag_values("GENE_NA_FEATURE_ID"))[0], # parent
                  $genomeExtDbRlsId, # external_database_release_id
                  $isTopLevel, # is_top_level
                    )
                    or die $dbh->errstr;
              } 
            }
          }
        }
      }
      ]]>
    </perl>
  </tuningTable>


  <tuningTable name="PopsetSequence">
    <comment> Each record stores the nucleotide sequence of one popset. Used in the
         relevant attribute query of the WDK popset record, as well as by
         PopsetClustalw. Propagated to portal instances.
     </comment>
    <internalDependency name="PopsetAttributes"/>
    <externalDependency name="dots.NaSequence"/>
    <sql>
      <![CDATA[
CREATE TABLE PopsetSequence&1 NOLOGGING AS
SELECT ia.source_id,
       ns.sequence
FROM PopsetAttributes ia, dots.NaSequence ns
WHERE ia.na_sequence_id = ns.na_sequence_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create index PopsetSeq_ix&1 on PopsetSequence&1 (source_id)
tablespace indx
      ]]>
    </sql>
  </tuningTable>





  <tuningTable name="OrthologousPair">
    <comment> Each record contains a pair of genes that are orthologous to each other.
         Used in the creation of the tuning table OrthologGeneTable.
     </comment>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
       create table OrthologousPair&1 nologging as
       select /*+ ordered_predicates */
       ga2.gene_source_id AS ortho_gene_source_id, min(ga2.source_id) as ortho_transcript_source_id,
       ga2.na_sequence_id as ortho_na_sequence_id,
       ga2.gene_start_min as ortho_start_min,
       ga2.organism, ga2.gene_product, ga1.gene_source_id, ga1.project_id, ga1.na_sequence_id,
       ga1.gene_start_min as start_min, nvl(comments.has_comment, 'no') as has_comment
       from TranscriptAttributes ga1, TranscriptAttributes ga2,
       (select distinct 'yes' as has_comment, stable_id as source_id, project_name
       from userlogins5.comments@&dblink
       where comment_target_id = 'gene'
       and review_status_id != 'rejected'
       and is_visible = 1) comments
       where ga2.gene_source_id = comments.source_id(+)
       and ga2.project_id = ga1.project_id
       and ga1.orthomcl_name = ga2.orthomcl_name
       and ga2.gene_source_id != ga1.gene_source_id
       group by ga2.gene_source_id, ga2.na_sequence_id, ga2.gene_start_min,
       ga2.organism, ga2.gene_product, ga1.gene_source_id, ga1.project_id, ga1.na_sequence_id,
       ga1.gene_start_min, has_comment
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index orth_ix&1
      on OrthologousPair&1 (gene_source_id, project_id)
      tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrthologGeneTable">
    <comment> Each record contains a record from OrthologousPair, augmented by the
         IS_SYNTENIC column. Used by the relevant table query of the WDK gene
         record.
      </comment>
    <internalDependency name="OrthologousPair"/>
    <externalDependency name="apidb.Synteny"/>
    <sql>
      <![CDATA[
      create table OrthologGeneTable&1 nologging as
      select
       op.gene_source_id, op.ortho_gene_source_id, op.ortho_transcript_source_id,
       op.organism,
       op.gene_product,
       nvl(synteny.is_syntenic, 'no') as is_syntenic,
       op.has_comment,
       op.project_id
      from OrthologousPair op,
       (select distinct
               'yes' as is_syntenic,
               a_na_sequence_id, b_na_sequence_id, a_start, a_end, b_start, b_end
        from apidb.synteny s) synteny
        where synteny.a_na_sequence_id(+) = op.na_sequence_id
          AND synteny.b_na_sequence_id(+) = op.ortho_na_sequence_id
          AND synteny.a_start(+) <= op.start_min
          AND synteny.a_end(+) >= op.start_min
          AND synteny.b_start(+) <= op.ortho_start_min
          AND synteny.b_end(+) >= op.ortho_start_min
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index ogt_ix&1
      on OrthologGeneTable&1 (gene_source_id, project_id)
      tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrganismAbbreviation">
    <comment> Each record maps an organism name onto an abbreviation, getting the
         pair either from apidb.Organism or (in the case of Tvag), hardwired
         into the below SQL. This table will eventually be replaced by workflow.
      </comment>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
       CREATE TABLE OrganismAbbreviation&1 NOLOGGING AS
       select organism, abbreviation
       From (
  select tn.name as organism, o.name_for_filenames as abbreviation
  from apidb.Organism o, sres.TaxonName tn
  where o.taxon_id = tn.taxon_id
  and tn.name_class = 'scientific name'
       )
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="OrganismAbbreviationWS">
    <comment> Stores special webservice abbreviations which are not standard organism
         names. Each record maps an organism name onto this abbreviation, as
         well as the species name and project ID. Used by the model and as an
         input in the creation of the OrganismAbbreviationBlast tuning table.
         Propagated to portal instances.
      </comment>
    <internalDependency name="OrganismAbbreviation"/>
    <internalDependency name="OrganismTree"/>
    <sql>
      <![CDATA[
       create table OrganismAbbreviationWS&1 nologging as
       select oa.organism, ot.parentTerm as parent, oa.abbreviation, ot.project_id
       from OrganismAbbreviation oa, OrganismTree ot
       where ot.term = oa.organism
       union
       select special.organism, special.parent,special.abbreviation, ot.project_id from OrganismTree ot,(
  /* TrichDB Repeat Genes */
  select 'Trichomonas vaginalis G3 (Repeated Genes)' as organism, 'Trichomonas vaginalis' as parent, 'TvaginalisRG' as abbreviation from dual
) special
          where special.parent = ot.term
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ProjectIdTaxonLevel">
    <comment> Groups projects by higher level taxonomy. Used in the creation of the
         OrganismTree tuning table.
      </comment>
    <internalDependency name="GenomicSeqAttributes"/>
    <sql>
      <![CDATA[
       CREATE TABLE ProjectIdTaxonLevel&1 NOLOGGING AS
       SELECT p.project_id, taxon_node, organism
          FROM (SELECT 'PlasmoDB' AS project_id,
		       'Apicomplexa' AS  taxon_node 
		FROM dual 
		UNION
		SELECT 'CryptoDB' AS project_id,
			   'Apicomplexa' AS  taxon_node 
		FROM dual 
		UNION
		SELECT 'ToxoDB' AS project_id,
		           'Apicomplexa' AS  taxon_node 
		FROM dual 
		UNION
		SELECT 'PiroplasmaDB' AS project_id,
		           'Apicomplexa' AS  taxon_node 
		FROM dual
		UNION
		SELECT 'TriTrypDB' AS project_id,
			   'Kinetoplastida' AS  taxon_node 
		FROM dual 
		UNION
		SELECT 'AmoebaDB' AS project_id,
			   'Amoebozoa' AS  taxon_node 
		FROM dual
		UNION 
		SELECT 'MicrosporidiaDB' AS project_id,
		           'Microsporidia' AS  taxon_node 
		FROM dual
		UNION
		SELECT 'GiardiaDB' AS project_id, 
		           'Diplomonadida' AS taxon_node 
		FROM dual
		UNION
		SELECT 'TrichDB' AS project_id,
		           'Trichomonadida' AS taxon_node
		FROM dual
        ) p,
        (select distinct project_id, organism from GenomicSeqAttributes) s
        where p.project_id = s.project_id
        union 
        SELECT distinct s.project_id as project_id, 
          CASE
            when (s.organism like 'Coprinopsis%' or
                  s.organism like 'Phanerochaete%')
            then 'Agaricomycetes'
            when (s.organism like 'Allomyces%')
            then 'Blastocladiomycetes'
            when (s.organism like 'Batrachochytrium%' or
                  s.organism like 'Spizellomyces%') 
            then 'Chytridiomycetes'
            when (s.organism like 'Aspergillus%' or
                  s.organism like 'Emericella%' or
                  s.organism like 'Coccidioides%' or
                  s.organism like 'Histoplasma%' or
                  s.organism like 'Talaromyces%' or
                  s.organism like 'Penicillium%' or
                  s.organism like 'Neosartorya%' or
                  s.organism like 'Ajellomyces%')
            then 'Eurotiomycetes'
            when (s.organism like 'Sclerotinia%' or
                  s.organism like 'Botrytis%' or 
                  s.organism like 'Botryotinia%')
            then 'Leotiomycetes'
            when (s.organism like 'Hyaloperonospora%' or
                  s.organism like 'Phytophthora%' or
                  s.organism like 'Saprolegnia%' or
                  s.organism like 'Albugo%' or
                  s.organism like 'Aphanomyces%' or
                  s.organism like 'Pythium%')
            then 'Oomycetes'
            when (s.organism like 'Pneumocystis%')
            then 'Pneumocystidomycetes'
            when (s.organism like 'Puccinia%' or
                  s.organism like 'Melampsora%')
            then 'Pucciniomycetes'
            when (s.organism like 'Saccharomyces%' or
                  s.organism like 'Yarrowia%' or
                  s.organism like 'Candida%')
            then 'Saccharomycetes'
            when (s.organism like 'Schizosaccharomyces%')
            then 'Schizosaccharomycetes' 
            when (s.organism like 'Neurospora%' or 
                  s.organism like 'Magnaporthe%' or 
                  s.organism like 'Fusarium%' or 
                  s.organism like 'Gibberella%' or
                  s.organism like 'Trichoderma%' or
                  s.organism like 'Sordaria%')
            then 'Sordariomycetes'
            when (s.organism like 'Tremella%' or
                  s.organism like 'Cryptococcus%')
            then 'Tremellomycetes'
            when (s.organism like 'Ustilago%' or
                  s.organism like 'Malassezia%' or 
                  s.organism like 'Sporisorium%') 
            then 'Ustilaginomycetes'
            when (s.organism like 'Rhizopus%' or
                  s.organism like 'Mucor%' or
                  s.organism like 'Phycomyces%')
            then 'Zygomycetes'
            else 'Missing ProjectIdTaxonLevel'
          end as taxon_node,
          s.organism as organism
        from GenomicSeqAttributes s
        where s.project_id = 'FungiDB'
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="OrganismTree">
    <comment> Group species by higher level taxonomy. Each row associates a taxon of
         interest with one of its ancestors in the taxon tree. Used in parameter
         queries that have to know about the taxon tree, as well as
         apidb.project_id(), the function that maps an organism name to a
         project. Propagated to portal instances.
      </comment>
    <internalDependency name="ProjectIdTaxonLevel"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.Taxon"/>
    <intermediateTable name="StrainTree"/>
    <sql>
      <![CDATA[
CREATE TABLE StrainTree NOLOGGING AS
SELECT *
FROM (         SELECT organism,term,parentTerm, internal,project_id
         FROM (
           /* all organisms from GenomicSeqAttributes as organism, organism as term, parentterm is species            */
           SELECT DISTINCT sa.organism AS organism,
                           sa.organism AS term,
                           sn.name AS parentTerm,
                           t.taxon_id AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, sres.TaxonName tn,
                sres.Taxon t, sres.TaxonName sn, TaxonSpecies ts
           WHERE tn.name = sa.organism
           AND  ts.taxon_id = tn.taxon_id
           AND  sn.taxon_id = ts.species_taxon_id
           AND t.taxon_id = ts.taxon_id
           AND sn.name_class = 'scientific name'
           AND t.rank != 'species'
           UNION
           /* all organisms from GenomicSeqAttributes as organism, species as term, parentterm is genus   */
           /* we are getting a row for species level AND for children here */
           SELECT DISTINCT sa.organism,  
                          sn.name AS term,
                          SUBSTR(sa.organism,0,(INSTR(sa.organism,' ') - 1)) AS parentTerm,
                          tn.taxon_id AS internal,
                          sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, sres.Taxon t, 
                sres.TaxonName tn, sres.TaxonName sn,
                TaxonSpecies ts
           WHERE tn.name = sa.organism
           AND  ts.taxon_id = tn.taxon_id
           AND  sn.taxon_id = ts.species_taxon_id
           AND t.taxon_id = ts.taxon_id
           AND sn.name_class = 'scientific name'
           UNION 
           SELECT DISTINCT sa.organism,
                          sn.name AS term,
                          SUBSTR(sa.organism,0,(INSTR(sa.organism,' ') - 1)) AS parentTerm,
                          sn.taxon_id AS internal,
                          sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, sres.Taxon t, 
                sres.TaxonName tn, sres.TaxonName sn,
                TaxonSpecies ts
           WHERE tn.name = sa.organism
           AND  ts.taxon_id = tn.taxon_id
           AND  sn.taxon_id = ts.species_taxon_id
           AND t.taxon_id = ts.taxon_id
           AND sn.name_class = 'scientific name'
           UNION
           /* all organisms from GenomicSeqAttributes as organism, genus as term, parentterm from taxonlevel */
           SELECT DISTINCT sa.organism,      
                           SUBSTR(sa.organism,0,(INSTR(sa.organism,' ') - 1)) AS term,
                           ptl.taxon_node AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
           AND ptl.organism = sa.organism
           and ptl.organism not like 'Chromera%'
           and ptl.organism not like 'Vitrella%' 
           UNION
           /* all organisms from GenomicSeqAttributes as organism, taxon_node as term, parentterm is null */
           SELECT DISTINCT sa.organism,               
                           ptl.taxon_node AS term,
                           '' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism
            and ptl.project_id not in ('FungiDB','MicrosporidiaDB')
            and ptl.organism not like 'Chromera%'
            and ptl.organism not like 'Vitrella%' 
            UNION
            -- add the kingdom for Fungi organism (this includes MicrosporidiaDB organisms)
            SELECT DISTINCT sa.organism,               
                           ptl.taxon_node AS term,
                           'Fungi' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism
            and ptl.project_id in ('FungiDB','MicrosporidiaDB')
            and ptl.taxon_node != 'Oomycetes'
            UNION
            SELECT DISTINCT sa.organism,               
                           'Fungi' AS term,
                           '' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism
            and ptl.project_id in ('FungiDB','MicrosporidiaDB')
            and ptl.taxon_node != 'Oomycetes'
            UNION
            -- add the kingdom for Oomycetes in FungiDB
            SELECT DISTINCT sa.organism,               
                           ptl.taxon_node AS term,
                           'Oomycetes' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism
            and ptl.taxon_node = 'Oomycetes'
            UNION
            SELECT DISTINCT sa.organism,               
                           'Oomycetes' AS term,
                           '' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa, ProjectIdTaxonLevel ptl
           WHERE ptl.project_id = sa.project_id
            AND ptl.organism = sa.organism
            and ptl.taxon_node = 'Oomycetes'
                        UNION
            -- add the phylum for chomera and vitrella
          SELECT DISTINCT sa.organism,               
                            SUBSTR(sa.organism,0,(INSTR(sa.organism,' ') - 1)) AS term,
                           'Chromerida' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa
           WHERE sa.organism like 'Chromera%'
            or sa.organism like 'Vitrella%'
            UNION
            SELECT DISTINCT sa.organism,               
                           'Chromerida' AS term,
                           '' AS parentTerm,
                           -1 AS internal,
                           sa.project_id AS project_id
           FROM GenomicSeqAttributes sa
           WHERE sa.organism like 'Chromera%'
            or sa.organism like 'Vitrella%'           
))
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE OrganismTree&1 NOLOGGING AS
         SELECT organism,term,parentTerm, internal,project_id
         FROM (
               SELECT * from StrainTree
               UNION
               SELECT stn.name as organism,
                      st.term as term,
                      st.parentTerm as parentTerm,
                      st.internal as internal,
                      st.project_id as project_id
               FROM StrainTree st, TaxonSpecies ts, sres.TaxonName tn, sres.TaxonName stn
               WHERE tn.taxon_id = ts.taxon_id
                 AND stn.taxon_id = ts.species_taxon_id
                 AND st.organism = tn.name
                 AND tn.name_class = 'scientific name'
                 AND stn.name_class = 'scientific name'
                 AND st.organism != st.term
          )
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="OrganismAbbreviationBlast">
    <comment> Each record maps an organism to its BLAST abbreviation. Used by
         BLAST-query parameters. Propagated to portal instances.
      </comment>
    <internalDependency name="OrganismAbbreviationWS"/>
    <internalDependency name="OrganismTree"/>
    <internalDependency name="EstAttributes"/>
    <sql>
      <![CDATA[
       create table OrganismAbbreviationBlast&1 nologging as
       select organism, parent, abbreviation, project_id from OrganismAbbreviationWS
         union
      /* All familes for popsets */
      select distinct family_name_for_files || ' Popset/Genbank Isolates' as organism, '' as parent, family_name_for_files as abbreviation, project_name as project_id
      from apidb.Organism 
       where family_name_for_files is not null
       and family_name_for_files NOT IN ('Culicosporidae', 'Dubosqiidae', 'Ordosporidae')
       union
       select special.organism, special.parent, special.abbreviation, ot.project_id from OrganismTree ot,
       (
  /* All species and speciesAbbreviations from apidb.Organism where we have ests */
  select distinct sp.name as organism,
                  ot.parentTerm as parent,
                  REGEXP_REPLACE(org.name_for_filenames, org.strain_abbrev,'', 1, 1) as abbreviation 
  from sres.TaxonName sp, taxonspecies ts, apidb.Organism org, organismtree ot,
       estattributes ea, sres.TaxonName etn, taxonspecies ets
  where org.taxon_id = ts.taxon_id
  and ts.species_taxon_id = sp.taxon_id
  and sp.name_class = 'scientific name'
  and ot.term = sp.name
  and org.strain_abbrev is not null
  and org.name_for_filenames is not null
  and ets.species_taxon_id = sp.taxon_id
  and (ets.taxon_id = etn.taxon_id OR ets.species_taxon_id = etn.taxon_id)
  and etn.name = ea.organism
  union
  /* TrichDB EST Legacy */
/*  select 'Trichomonas vaginalis' as organism, 'Trichomonas' as parent, 'Tvaginalis' as abbreviation from dual union   */
  /* */
  select 'Cryptosporidiidae SSU_18srRNA Reference Isolates' as organism, 'Cryptosporidium' as parent, 'CryptosporidiidaeReference' as abbreviation from dual
) special
      where special.parent = ot.term
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="BlastTypes">
    <comment> For each project, show which BLAST databases are available for which
         species. Used in BLAST param queries. Propagated to portal instances.
      </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="GenomicSeqAttributes"/>
    <internalDependency name="EstAttributes"/>
    <internalDependency name="TaxonSpecies"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
       create table BlastTypes&1 nologging as
  /* Standard GENES */
  select distinct organism, project_id, type 
  from TranscriptAttributes,
       (select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  where organism not in ('Toxoplasma gondii RH') and gene_type = 'protein coding' 
  UNION
  /* TrichDB Repeat Genes */
  select distinct organism || ' (Repeated Genes)', project_id, type 
  from TranscriptAttributes,
       (select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  where project_id = 'TrichDB'
  UNION
  /* GiardiaDB Deprecated Genes */
  select 'Giardia Assemblage A isolate WB (deprecated)' as organism, 'GiardiaDB' as project_id, type 
  from dual, (select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  UNION
  /* GiardiaDB Scaffolds */
  select 'Giardia Assemblage A isolate WB (scaffolds)' as organism, 'GiardiaDB' as project_id, type 
  from dual, (select 'Genome' as type from dual)
  UNION  
  /* Standard GENOME */
  select distinct organism, project_id, type 
  from GenomicSeqAttributes,
       (select 'ORFs_AA' as type from dual union select 'Genome' as type from dual)
  UNION
  /* Mitochondrial GENES and GENOME */
  select distinct organism || ' mitochondrial', project_id, type 
  from GenomicSeqAttributes,       
  (select 'ORFs_AA' as type from dual union select 'Genome' as type from dual union select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  where so_id = 'SO:0000819'
  and not project_id='PlasmoDB' 
  UNION
  /* Plastid GENES and GENOME */
  select distinct organism || ' plastid' as organism, project_id, type 
  from GenomicSeqAttributes,       
  (select 'ORFs_AA' as type from dual union select 'Genome' as type from dual union select 'AnnotatedTranscripts' as type from dual union select 'AnnotatedProteins' as type from dual)
  where so_id = 'SO:0001259'
  and not project_id='PlasmoDB' 
  UNION
  /* Regular ESTs (all species from estattributes) */
  select distinct sp.name as organism, ea.project_id, 'ESTs' as type
  from EstAttributes ea, sres.TaxonName tn, taxonspecies ts, sres.TaxonName sp
  where ea.organism = tn.name
  and (tn.taxon_id = ts.taxon_id or tn.taxon_id=ts.species_taxon_id)
  and ts.species_taxon_id = sp.taxon_id
  and sp.name_class = 'scientific name'
  UNION
  /* regular Isolates */
  select distinct family_name_for_files || ' Popset/Genbank Isolates' as organism, project_name as project_id, 'Isolates'
  from apidb.Organism 
  where family_name_for_files is not null
  UNION
  /* isolates are hard coded */
  select 'P. falciparum Barcode Isolates' as organism, 'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'P. berghei Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'P. chabaudi Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'P. falciparum Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'P. knowlesi Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'P. reichenowi Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'P. vivax Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'P. yoelii Popset/Genbank Isolates' as organism,'PlasmoDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'All Giardia Isolates' as organism, 'GiardiaDB' as project_id, 'Isolates' as type from dual
  UNION
  select 'Cryptosporidiidae SSU_18srRNA Reference Isolates' as organism, 'CryptoDB' as project_id, 'Isolates' as type from dual
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="CompoundAttributes"  prefixEnabled="true">
    <comment> The BFMV for the compound WDK record type. Used by the model for the
         compound record and queries, as well as in the creation of the
         PathwayCompounds tuning table. Propagated to portal instances.
      </comment>
    <!-- externalDependency name="chebi.Compounds"/ -->
    <sql>
      <![CDATA[
CREATE TABLE &prefixCompoundAttributes&1 NOLOGGING AS
SELECT c.ID, c.chebi_accession AS source_id,
    c.name AS compound_name,
    substr(apidb.tab_to_string(set(cast(COLLECT(to_char(cn.name)) AS apidb.varchartab)), ', '), 1, 1000) AS other_names,
    substr(apidb.tab_to_string(set(cast(COLLECT(to_char(ciup.iupac_name)) AS apidb.varchartab)), ', '), 1, 1000) AS iupac_name,
    substr(apidb.tab_to_string(set(cast(COLLECT(to_char(csyn.syn)) AS apidb.varchartab)), ', '), 1, 1000) AS syn,
    c.definition, m.mass,
    apidb.tab_to_string(set(cast(COLLECT(formu.formula order by formu.formula) as apidb.varchartab)), ', ') AS formula,
    apidb.tab_to_string(set(cast(COLLECT(sec.chebi_accession order by sec.chebi_accession) as apidb.varchartab)), ', ') AS secondary_ids
FROM  chebi.compounds c, 
  ( SELECT compound_id,  NAME FROM chebi.names WHERE TYPE='NAME') cn,
  ( SELECT compound_id,  MIN(NAME) AS iupac_name FROM chebi.names WHERE TYPE='IUPAC NAME' GROUP BY compound_id) ciup,
  ( SELECT compound_id,  MIN(NAME) AS syn FROM chebi.names WHERE type='SYNONYM' GROUP BY compound_id) csyn,
  ( SELECT compound_id, chemical_data AS formula FROM chebi.chemical_data WHERE TYPE='FORMULA') formu,
  ( SELECT compound_id, chemical_data AS mass FROM chebi.chemical_data WHERE TYPE='MASS') m,
  ( SELECT parent_id, chebi_accession FROM chebi.compounds) sec
WHERE c.status ='C'
AND c.ID = cn.compound_id (+)
AND c.ID = ciup.compound_id (+)
AND c.ID = csyn.compound_id (+)
AND c.ID = formu.compound_id (+)
AND c.ID = m.compound_id (+)
AND c.ID = sec.parent_id (+)
GROUP BY c.ID, c.chebi_accession, c.parent_id, c.name, c.definition, m.mass
      ]]>
    </sql>
    <sql>
      <![CDATA[
update &prefixCompoundAttributes&1
set compound_name = iupac_name
where compound_name is NULL
      ]]>
    </sql>
    <sql>
      <![CDATA[
update &prefixCompoundAttributes&1
set compound_name = syn
where compound_name is NULL
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="CompoundId"  prefixEnabled="true">
    <comment> Alias table for Compounds.
    Compound column is the source_id from CompoundAttributes (chEBI_ID).
    ID can have this same ID, or mapping KEGG ID, or Name, or Synonym.
    </comment>
    <internalDependency name="CompoundAttributes"/>
    <!-- externalDependency name="chebi.Compounds"/ -->
    <sql>
      <![CDATA[
        CREATE TABLE CompoundId&1 NOLOGGING AS
      SELECT source_id AS id, source_id AS compound, 'same ID' AS type 
      FROM compoundAttributes
      UNION
      SELECT da.accession_number AS id,  p.source_id AS compound, 'KEGG'  AS type 
      FROM chebi.database_accession da, compoundAttributes p
      WHERE da.type='KEGG COMPOUND accession' 
      AND  da.compound_id = p.id
      UNION
      SELECT  distinct da.accession_number AS id,  p.chebi_accession AS compound, 'KEGG'  as type 
      FROM chebi.database_accession da, chebi.compounds c, chebi.compounds p
      WHERE p.status='C' AND da.type='KEGG COMPOUND accession' 
      AND da.compound_id = c.id AND c.parent_id=p.id
      UNION
      SELECT n.name as id, ca.source_id as compound, 'name' as type
      FROM compoundAttributes ca, chebi.names n
      WHERE ca.id = n.compound_id
      AND n.type = 'NAME' 
      UNION
      SELECT n.name as id, ca.source_id as compound, 'synonym' as type
      FROM compoundAttributes ca, chebi.names n
      WHERE ca.id = n.compound_id
      AND n.type = 'SYNONYM'
      ]]>
    </sql>
    <sql>
      <![CDATA[
      CREATE INDEX CompoundId_idx&1 ON CompoundId&1 (id, compound)
      TABLESPACE indx
      ]]>
    </sql>

  </tuningTable>


  <tuningTable name="PathwayCompounds">
    <comment> Each record represents a 5-tuple of (reaction, compound, pathway,
         enzyme, type). Used extensively in the model for pathway-related
         queries, as well as by getImageMap.pl.
      </comment>
    <externalDependency name="sres.Pathway"/>
    <externalDependency name="sres.PathwayNode"/>
    <externalDependency name="sres.PathwayRelationship"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="apidb.PathwayReactionRel"/>
    <externalDependency name="apidb.PathwayReaction"/>
    <!--externalDependency name="chebi.Compounds"/-->
    <sql>
      <![CDATA[
    CREATE TABLE PathwayCompounds&1 NOLOGGING AS
    select pathway_id
    , reaction_id
    , ext_db_name
    , ext_db_version
    , compound_node_id
    , compound_source_id
    , c.chebi_accession
    , case when c.chebi_accession is not null then 'https://www.ebi.ac.uk/chebi/searchId.do?chebiId=' || c.chebi_accession else null end as chebi_url
    , type
    from (
        select 
        p.PATHWAY_ID
        , prx.PATHWAY_REACTION_ID as reaction_id
        , ed.NAME as ext_db_name
        , edr.version as ext_db_version
        , pn.pathway_node_id as compound_node_id
        , pn.DISPLAY_LABEL as compound_source_id
        , 'substrate' as type
        , pn.row_id
        from
        APIDB.PATHWAYREACTION prx
        , SRES.PATHWAY p
        , APIDB.PATHWAYREACTIONREL prr
        , SRES.PATHWAYNODE pn
        , SRES.PATHWAYRELATIONSHIP prel
        , SRES.ONTOLOGYTERM ot
        , SRES.EXTERNALDATABASE ed
        , SRES.EXTERNALDATABASERELEASE edr
        where p.PATHWAY_ID = prr.PATHWAY_ID
        and prx.PATHWAY_REACTION_ID = prr.PATHWAY_REACTION_ID
        and prr.PATHWAY_RELATIONSHIP_ID = prel.PATHWAY_RELATIONSHIP_ID
        and prel.NODE_ID = pn.PATHWAY_NODE_ID
        and ot.NAME = 'molecular entity'
        and ot.ONTOLOGY_TERM_ID = pn.PATHWAY_NODE_TYPE_ID
        and p.EXTERNAL_DATABASE_RELEASE_ID = edr.EXTERNAL_DATABASE_RELEASE_ID
        and edr.EXTERNAL_DATABASE_ID = ed.EXTERNAL_DATABASE_ID)
    LEFT OUTER JOIN CHEBI.COMPOUNDS c on row_id = c.ID
    union
    select pathway_id
    , reaction_id
    , ext_db_name
    , ext_db_version
    , compound_node_id
    , compound_source_id
    , c.chebi_accession
    , case when c.chebi_accession is not null then 'https://www.ebi.ac.uk/chebi/searchId.do?chebiId=' || c.chebi_accession else null end as chebi_url
    , type
    from (
        select 
        p.PATHWAY_ID
        , prx.PATHWAY_REACTION_ID as reaction_id
        , ed.NAME as ext_db_name
        , edr.version as ext_db_version
        , pn.pathway_node_id as compound_node_id
        , pn.DISPLAY_LABEL as compound_source_id
        , 'product' as type
        , pn.row_id
        from
        APIDB.PATHWAYREACTION prx
        , SRES.PATHWAY p
        , APIDB.PATHWAYREACTIONREL prr
        , SRES.PATHWAYNODE pn
        , SRES.PATHWAYRELATIONSHIP prel
        , SRES.ONTOLOGYTERM ot
        , SRES.EXTERNALDATABASE ed
        , SRES.EXTERNALDATABASERELEASE edr
        where p.PATHWAY_ID = prr.PATHWAY_ID
        and prx.PATHWAY_REACTION_ID = prr.PATHWAY_REACTION_ID
        and prr.PATHWAY_RELATIONSHIP_ID = prel.PATHWAY_RELATIONSHIP_ID
        and prel.ASSOCIATED_NODE_ID = pn.PATHWAY_NODE_ID
        and ot.NAME = 'molecular entity'
        and ot.ONTOLOGY_TERM_ID = pn.PATHWAY_NODE_TYPE_ID
        and p.EXTERNAL_DATABASE_RELEASE_ID = edr.EXTERNAL_DATABASE_RELEASE_ID
        and edr.EXTERNAL_DATABASE_ID = ed.EXTERNAL_DATABASE_ID)
    LEFT OUTER JOIN CHEBI.COMPOUNDS c on row_id = c.ID
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="PathwayReactions">
    <comment>Aggregates reactions irrespective of pathway.  Required to determine if BioCyc reactions are reversible.  Used extensively in the model in conjunction with pathwaycompounds for pathway related queries</comment>
    <externalDependency name="sres.Pathway"/>
    <externalDependency name="sres.PathwayNode"/>
    <externalDependency name="sres.PathwayRelationship"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="apidb.PathwayReactionRel"/>
    <externalDependency name="apidb.PathwayReaction"/>
    <internalDependency name="PathwayCompounds"/>

    <sql>
    <![CDATA[
        CREATE TABLE PathwayReactions&1 NOLOGGING AS
        select
        reaction_id
        , reaction_source_id
        , reaction_url
        , ext_db_name
        , ext_db_version
        , enzyme
        , expasy_url
        , expasy_html
        , substrates_html || ' ' || sign || ' ' || products_html as equation_html
        , substrates_text || ' ' || sign || ' ' || products_text as equation_text
        , case when sign = '<=>' then 1 else 0 end as is_reversible
        , substrates_text
        , products_text
        from (
            select
            reaction_id
            , reaction_source_id
            , reaction_url
            , ext_db_name
            , ext_db_version
            , (case when expasy_url is not null then '<a href="' || expasy_url || '">' || enzyme || '</a>' else enzyme end) as expasy_html
            , enzyme
            , expasy_url
            , (case when (listagg (case when type_list like '%substrate%' then compound end, ',') within group (order by compound)) = (listagg (case when type_list like '%product%' then compound end, ',') within group (order by compound)) or is_reversible = 1 then '<=>' else '=>' end) as sign
            , listagg (case when type like '%substrate%' then compound_url end, ' + ') within group (order by compound_url) as substrates_html
            , listagg (case when type like '%substrate%' then compound end, ' + ') within group (order by compound) as substrates_text
            , listagg (case when type like '%product%' then compound_url end, ' + ') within group (order by compound_url) as products_html
            , listagg (case when type like '%product%' then compound end, ' + ') within group (order by compound) as products_text
            from (
              select distinct
              pr.PATHWAY_REACTION_ID as reaction_id
              , pr.SOURCE_ID as reaction_source_id
              , (case (replace (replace (ed.name, 'Pathways_', ''), '_RSRC', ''))
                when 'KEGG' then 'http://www.genome.jp/dbget-bin/www_bget?rn:' || pr.source_id
                when 'MetaCyc' then 'http://metacyc.org/META/new-image?type=REACTION' || chr(38) || 'object=' || pr.source_id
                when 'TrypanoCyc' then 'http://vm-trypanocyc.toulouse.inra.fr/TRYPANO/new-image?type=REACTION' || chr(38) || 'object=' || pr.source_id
                end) as reaction_url
              , ed.NAME as ext_db_name
              , edr.VERSION as ext_db_version
              , pn.DISPLAY_LABEL as enzyme
              , (case when pn.display_label like '%.%.%.%' then 'http://enzyme.expasy.org/cgi-bin/enzyme/enzyme-search-ec?field1='
                  ||ec.ec_number_1
                  ||decode(ec.ec_number_2, null, null,chr(38) || 'field2='||ec.ec_number_2)
                  ||decode(ec.ec_number_3, null, null,chr(38) || 'field3='||ec.ec_number_3)
                  ||decode(ec.ec_number_4, null, null,chr(38) || 'field4='||ec.ec_number_4) else null end ) as expasy_url
              , listagg (pc.type, ',') within group (order by pc.pathway_id) as type_list
              , max (prel.is_reversible) KEEP (DENSE_RANK LAST ORDER BY prel.is_reversible) over (partition by pr.pathway_reaction_id) as is_reversible
              , nvl(pc.chebi_accession, pc.compound_source_id) as compound
              , (case when nvl(pc.CHEBI_ACCESSION, pc.compound_source_id) like 'CHEBI%' then '<a href="/a/app/record/compound/' || nvl(pc.chebi_accession, pc.compound_source_id) || '">' || nvl(pc.chebi_accession, pc.compound_source_id) || '</a>' else nvl(pc.chebi_accession, pc.compound_source_id) end) as compound_url
              , min(pc.type) KEEP (DENSE_RANK FIRST ORDER BY p.pathway_id) as type
              from
              sres.pathway p
              , apidb.pathwayreaction pr
              , APIDB.PATHWAYREACTIONREL prr
              , SRES.PATHWAYNODE pn
              , SRES.PATHWAYRELATIONSHIP prel
              , SRES.EXTERNALDATABASE ed
              , SRES.EXTERNALDATABASERELEASE edr
              , SRES.ONTOLOGYTERM ot
              , SRES.ENZYMECLASS ec
              , PathwayCompounds pc
              where p.PATHWAY_ID = prr.PATHWAY_ID
              and pr.PATHWAY_REACTION_ID = prr.PATHWAY_REACTION_ID
              and prr.PATHWAY_RELATIONSHIP_ID = prel.PATHWAY_RELATIONSHIP_ID
              and prel.NODE_ID = pn.PATHWAY_NODE_ID
              and ot.name = 'enzyme'
              and ot.ONTOLOGY_TERM_ID = pn.PATHWAY_NODE_TYPE_ID
              and  (pn.display_label not like '%.%.%.%' or ec.EC_NUMBER = pn.display_label)
              and pc.EXT_DB_NAME = ed.NAME
              and pc.EXT_DB_VERSION = edr.VERSION
              and ed.EXTERNAL_DATABASE_ID = edr.EXTERNAL_DATABASE_ID
              and pc.PATHWAY_ID = p.PATHWAY_ID
              and pc.REACTION_id = pr.PATHWAY_REACTION_ID
              and pc.EXT_DB_NAME = ed.NAME
              and pc.EXT_DB_VERSION = edr.VERSION
              group by pr.pathway_reaction_id, pr.SOURCE_ID, ed.NAME, edr.VERSION, pn.DISPLAY_LABEL, prel.IS_REVERSIBLE, nvl(pc.chebi_accession, pc.compound_source_id), ec.ec_number_1, ec.ec_number_2, ec.ec_number_3, ec.ec_number_4, pn.display_label
              )
            group by reaction_id, reaction_source_id, reaction_url, ext_db_name, ext_db_version, enzyme, is_reversible, expasy_url
            )
        ]]>
        </sql>
    </tuningTable>


  <tuningTable name="CompoundTypeAheads">
    <comment> for use in GenesByReactionCompounds question </comment>
    <internalDependency name="CompoundAttributes"/>
    <internalDependency name="PathwayCompounds"/>
    <sql>
      <![CDATA[
        CREATE TABLE CompoundTypeAheads&1 NOLOGGING AS
        SELECT ca.source_id AS compound_id,
              TO_CHAR(ca.source_id)  || ' (' || ca.compound_name || ')' AS display
        FROM  CompoundAttributes ca, PathwayCompounds pc
        WHERE  pc.chebi_accession = ca.source_id
        UNION
        SELECT ca.source_id AS compound_id,
              pc.compound_source_id || ' (' || ca.compound_name || ')' AS display
        FROM  CompoundAttributes ca, PathwayCompounds pc
        WHERE  pc.chebi_accession = ca.source_id
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="MSPeptideSummary">
    <comment> Each row stores mass-spec. based expression evidence for one sample of
         one experiment for one gene. Used for mass spec queries in the model,
         GBrowse, and PBrowse, and also in the creation of the MSTranscriptSummary
         tuning table.
      </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="SampleDisplayInfo"/>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="dots.AaFeature"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <intermediateTable name="MSExptTrustedSpectrum"/>
    <sql>
      <![CDATA[
create table MSExptTrustedSpectrum nologging as        
select distinct mss.external_database_release_id, mss.protocol_app_node_id, pan.name
from apidb.massspecsummary mss, dots.massspecfeature msf, study.protocolappnode pan
where mss.mass_spec_summary_id = msf.source_id
and mss.PROTOCOL_APP_NODE_ID = pan.protocol_app_node_id

      ]]>
    </sql>
    <sql>
      <![CDATA[
create table MSPeptideSummary&1 nologging as
select  pep.*, sdi.sample_display_name, sdi.HTML_COLOR, sdi.SORT_ORDER
from (select dbms_lob.SUBSTR(seq.SEQUENCE,
pep.aa_end_max - pep.aa_start_min + 1,
                            pep.aa_start_min) as peptide_sequence,
       pep.*
from dots.aasequence seq, (
select ga.source_id, 
       ga.gene_source_id,
       mss.protocol_app_node_id, 
       dsp.display_name as experiment,
       d.name as external_database_name,
       sum(msf.spectrum_count) as spectrum_count,
       mss.aa_sequence_id,
       l.start_min as aa_start_min,
       l.end_max as aa_end_max,
       good.name as sample
from apidb.massspecsummary mss, dots.massspecfeature msf, dots.aalocation l, 
     transcriptattributes ga, Msexpttrustedspectrum good, sres.externaldatabase d,
     sres.externaldatabaserelease r,  datasetnametaxon dsnt, datasetpresenter dsp
where mss.mass_spec_summary_id = msf.source_id
and msf.aa_feature_id = l.aa_feature_id
and mss.aa_sequence_id = ga.aa_sequence_id (+)
and mss.external_database_release_id = r.external_database_release_id
and r.external_database_id = d.external_database_id
and d.name = dsnt.name (+)
and dsnt.dataset_presenter_id = dsp.dataset_presenter_id (+)
and mss.external_database_release_id = good.external_database_release_id (+)
and mss.protocol_app_node_id = good.protocol_app_node_id (+)
group by d.name, ga.source_id, ga.gene_source_id, mss.protocol_app_node_id, dsp.display_name, 
         mss.aa_sequence_id, mss.spectrum_count, l.start_min, l.end_max, good.external_database_release_id, good.name
) pep
where pep.aa_sequence_id = seq.aa_sequence_id) pep,
sampledisplayinfo sdi
where sdi.dataset_name = pep.external_database_name
and sdi.sample = replace (pep.sample ,' (MS Summary)', '') 
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="AnnotatedGenomeSummary">
    <comment> Stores summary information from annotated genomes to facilitate overview section of gene page
      </comment>
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
create table AnnotatedGenomeSummary&1 nologging as
select dsp.name as external_db_name, ga.organism,ga.taxon_id,o.is_reference_strain,
(select value from datasetproperty 
where dataset_presenter_id = dsp.dataset_presenter_id 
and property = 'isCurated') as is_curated_genome,
(select value from datasetproperty 
where dataset_presenter_id = dsp.dataset_presenter_id 
and property = 'updatedAnnotationText') as updated_link_text,
(select value from datasetproperty 
where dataset_presenter_id = dsp.dataset_presenter_id 
and property = 'specialLinkDisplayText') as special_link_text,
(select rel.id_url from datasetproperty p,  sres.externaldatabase db, sres.externaldatabaserelease rel
where p.dataset_presenter_id = dsp.dataset_presenter_id
and db.name = p.value
and db.external_database_id = rel.external_database_id
and p.property = 'specialLinkExternalDbName') as link_url,
dsp.release_policy
from datasetpresenter dsp, apidb.organism o,
(select distinct external_db_name,taxon_id,organism from geneattributes) ga
where dsp.name like '%_primary_genome_RSRC'
and dsp.name = ga.external_db_name
and o.taxon_id = ga.taxon_id
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="MSTranscriptSummary">
    <comment> Mass-spec experiment results for a transcript. Used in the model for queries
         related to transcripts.
      </comment>
    <internalDependency name="MSPeptideSummary"/>
    <sql>
      <![CDATA[
create table MSTranscriptSummary&1 nologging as
select msps.source_id, msps.gene_source_id, msps.external_database_name, msps.experiment, msps.sample, msps.sample_display_name, protocol_app_node_id, sum(msps.spectrum_count) as spectrum_count, count(*) as sequence_count
from mspeptidesummary msps
where source_id is not null
group by msps.source_id, msps.gene_source_id, msps.external_database_name, msps.experiment, msps.sample, msps.sample_display_name, protocol_app_node_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create index msgs_ix&1 on MSTranscriptSummary&1 (source_id, gene_source_id)
      tablespace indx
      ]]>
    </sql>
  </tuningTable>



  <tuningTable name="MSModifiedPeptideSummary">
    <comment> Mass-spec experiment results for a peptide. Used by the model, GBrowse,
         and PBrowse.
      </comment>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="SampleDisplayInfo"/>
    <internalDependency name="DatasetPresenter"/> 
    <externalDependency name="dots.AaFeature"/>
    <externalDependency name="dots.AaLocation"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <sql>
      <![CDATA[
create table MSModifiedPeptideSummary&1 nologging as
select dbms_lob.substr(seq.sequence, pep.aa_end_max - pep.aa_start_min + 1,
              pep.aa_start_min)                                   as
       peptide_sequence,
       dbms_lob.substr(seq.sequence, 1, pep.residue_location + 1) as residue,
       pep.*
from   dots.aasequence seq,
       (select ga.source_id                     as source_id,
               ga.gene_source_id                as gene_source_id,
               so.name                     as modification_type,
               nvl(dsp.display_name, sample)    as experiment,
               ed.name                          as external_database_name,
               mss.external_database_release_id as external_database_release_id,
               mst.sample_display_name          as Sample_display,
               mst.sample                       as sample,
               mss.aa_sequence_id               as aa_sequence_id,
               msf.aa_feature_id                as peptide_aa_feature_id,
               msf.spectrum_count               as spectrum_count,
               mst.html_color                   as html_color,
               aal.start_min                    as residue_location,
               aalp.start_min                   as aa_start_min,
               aalp.end_max                     as aa_end_max,
               pot.description                  as description
        from   dots.posttranslationalmodfeature pot,
               dots.massspecfeature msf,
               apidb.massspecsummary mss,
               dots.aalocation aal,
               dots.aalocation aalp,
               sampledisplayinfo mst,
               sres.ontologyterm so,
               transcriptattributes ga,
               sres.externaldatabase ed,
               sres.externaldatabaserelease edr,
               datasetnametaxon dsnt,
               datasetpresenter dsp, 
               study.protocolappnode pan
        where  pot.parent_id = msf.aa_feature_id
           and pot.aa_feature_id = aal.aa_feature_id
           and msf.aa_feature_id = aalp.aa_feature_id
           and msf.source_id = mss.mass_spec_summary_id
           and mss.aa_sequence_id = ga.aa_sequence_id
           and mss.external_database_release_id =
               edr.external_database_release_id
           and ed.name = dsnt.name (+)
           and dsnt.dataset_presenter_id = dsp.dataset_presenter_id (+)
           and mss.protocol_app_node_id = pan.protocol_app_node_id
           and ed.name = mst.dataset_name
           and mst.sample = replace (pan.name ,' (MS Summary)', '')
           and edr.external_database_id = ed.external_database_id
           and pot.sequence_ontology_id = so.ontology_term_id) pep
where  pep.aa_sequence_id = seq.aa_sequence_id 
      ]]>
    </sql>
  </tuningTable>



  <tuningTable name="Ssgcid" alwaysUpdate="true">
    <comment> Data from the Seattle Structural Genomics Center for Infectious Disease,
         populated from their web service. Used in the gene record.
      </comment>
    <program commandLine="buildSsgcidTT"/>
  </tuningTable>


  <tuningTable name="SampleDisplayInfo" alwaysUpdate="true">
    <comment> Used by the model and GBrowse, as well as an input in the creation of
         the tuning tables like MSModifiedPeptideSummary and MSPeptideSummary.
      </comment>
    <program commandLine="buildSampleDisplayInfoTT"/>
  </tuningTable>


  <tuningTable name="SampleAttributes" alwaysUpdate="true">
    <comment>lots of columns for sample meta data. used for sample record
      </comment>
    <program commandLine="buildSampleAttributesTT"/>
  </tuningTable>


  <tuningTable name="ProfileSetDisplayInfo" alwaysUpdate="true">
    <comment> Used by the model when writing profile data
      </comment>
    <program commandLine="buildProfileSetDisplayInfoTT"/>
  </tuningTable>




  <tuningTable name="GbrowseTracksOrganism" alwaysUpdate="true">
    <comment> Associates an organism with the GBrowse and PBrowse tracks available
         for it. Used by the gene record.
      </comment>
    <internalDependency name="GeneAttributes"/>
    <externalDependency name="apidb.Organism"/>
    <program commandLine="buildGbrowseImageUrlTT"/>
  </tuningTable>


  <tuningTable name="DatasetPresenter" alwaysUpdate="true">
    <comment> Data for a dataset. Used widely in the model, and by GBrowse.</comment>
    <internalDependency name="GenomicSeqAttributes"/>
    <ancillaryTable name="DatasetContact"/>
    <ancillaryTable name="DatasetProperty"/>
    <ancillaryTable name="DatasetHyperLink"/>
    <ancillaryTable name="DatasetPublication"/>
    <ancillaryTable name="DatasetModelRef"/>
    <ancillaryTable name="DatasetNameTaxon"/>
    <ancillaryTable name="DatasetHistory"/>
    <program commandLine="buildDatasetPresentersTT"/>
  </tuningTable>


  <tuningTable name="EupathBuildDates" alwaysUpdate="true">

    <program commandLine="buildEupathBuildDatesTT"/>
  </tuningTable>


  <tuningTable name="DatasetDetail" alwaysUpdate="true">
    <comment> Stores text associated with each dataset. Used by dataset queries.
      </comment>
    <internalDependency name="DatasetPresenter"/>
    <sql>
      <![CDATA[
      create table DatasetDetail&1 nologging
      as
            select dataset_presenter_id, 
      name||' '||category||' '||usage||' '|| 
      caveat||' '||acknowledgement||' '||type||' '||subtype
      ||' '| |summary||' '||description||' '||contact||' '||
      institution||' '||pubmed_id||' '||citation as search_string
      from (
      select
      sub.dataset_presenter_id as dataset_presenter_id, 
      sub.name as name, 
      sub.category as category,
      sub.usage as usage, 
      sub.caveat as caveat,
      sub.acknowledgement as acknowledgement, 
      sub.type as type, 
      sub.subtype as subtype,
      sub.contact,
      sub.institution,
      sub.pubmed_id,
      sub.citation,
      dp.summary,
      dp.description
      from DatasetPresenter dp,
      (
      select distinct
      dp.dataset_presenter_id as dataset_presenter_id, 
      dp.display_name as name, 
      dp.display_category as category,
      dp.usage as usage, 
      dp.caveat as caveat,
      dp.acknowledgement as acknowledgement, 
      dp.type as type, 
      dp.subtype as subtype, 
      dc.name as contact,
      dc.affiliation as institution,
      LISTAGG(dpub.pmid, ' ') WITHIN GROUP (ORDER BY dpub.pmid) as pubmed_id,
      LISTAGG(dpub.citation, '  ') WITHIN GROUP (ORDER BY dpub.citation) as citation
      from DatasetPresenter dp, DatasetContact dc, 
           DatasetPublication dpub  
      where dp.dataset_presenter_id = dc.dataset_presenter_id
      and   dp.dataset_presenter_id = dpub.dataset_presenter_id
      and   dc.is_primary_contact = 1
      group by dp.dataset_presenter_id, dp.display_name,dp.display_category,
               dp.usage,dp.caveat,dp.acknowledgement,dp.type,dp.subtype,dc.name,
               dc.affiliation
      ) sub
      
      where dp.dataset_presenter_id = sub.dataset_presenter_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
          CREATE INDEX DATASET_DETAIL_IDX&1 ON DATASETDETAIL&1 (search_string)
          INDEXTYPE IS CTXSYS.CONTEXT
      ]]>
    </sql>

  </tuningTable>

<!--


  <tuningTable name="TrackOldAnnotation" alwaysUpdate="true">
    <comment> Stores changes in gene annotation. Used by the model for gene ID and
         table queries.
      </comment>
    <program commandLine="buildTrackOldAnnotationTT"/>
  </tuningTable>
-->


  <tuningTable name="TranscriptTextSearch">
    <comment> For TranscriptsByTextSearch
      </comment>
    <externalDependency name="apidb.TranscriptDetail"/>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
        create table TranscriptTextSearch&1 nologging as
        select ga.source_id, ga.gene_source_id, ga.project_id, gd.field_name, gd.content, ga.taxon_id
        from TranscriptAttributes ga,
             (select source_id, project_id, field_name, content
              from apidb.TranscriptDetail
              where (source_id, project_id, field_name, modification_date)
                    in (select source_id, project_id, field_name, max(modification_date)
                        from apidb.TranscriptDetail
                        where field_name in ('Alias', 'CellularLocalization', 'CommunityAnnotation', 
                                             'EcNumber', 'GeneId', 'Notes', 'PreviousReleaseGenes', 
                                             'Product', 'GoTerms', 'MetabolicPathways', 'Phenotype', 
                                             'InterPro', 'RodMalPhenotype', 'PubMed')
                        group by source_id, project_id, field_name)) gd
        where ga.source_id = gd.source_id
          and ga.project_id = gd.project_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index transcripttext_ix&1 on TranscriptTextSearch&1(content)
        indextype is ctxsys.context
        parameters('DATASTORE CTXSYS.DEFAULT_DATASTORE SYNC (ON COMMIT)')
      ]]>
    </sql>

  </tuningTable>


  <tuningTable name="ProteomicsCitation">
    <comment> Citation info for proteomics datasets, used by GBrowse </comment>
    <internalDependency name="DatasetPresenter"/>
    <internalDependency name="MSPeptideSummary"/>
    <sql>
      <![CDATA[
      create table ProteomicsCitation&1 nologging as
      with pubs
           as (select name, id, contact_email,
                      listagg(publication, ',') WITHIN GROUP (order by publication) as pmids
               from (select ds.name as name, ds.dataset_presenter_id as id,
                                    c.email as contact_email, p.pmid as publication
                     from DatasetPresenter ds, DatasetContact c,
                          DatasetPublication p
                     where ds.dataset_presenter_id = c.dataset_presenter_id
                       and ds.dataset_presenter_id = p.dataset_presenter_id
                       and c.is_primary_contact = 1
                       and ds.type = 'protein_expression'
                       and ds.subtype is null)
               group by name, id, contact_email),
           samples
           as (select name, id,
                      listagg(sample_i, chr(10)) WITHIN GROUP (order by sample) as sample_table
               from (select distinct ds.name as name,
                                     ds.dataset_presenter_id as id, sample,
                                     '<p style="color:' || html_color || '">' || sample || '</p>' as sample_i
                     from MSPeptideSummary mps, DatasetPresenter ds
                     -- consider using ApiDBTuing.ExternalDbDatasetPresenter instead of the LIKE below, if its performance is a problem
                     where (ds.name = mps.external_database_name or mps.external_database_name like ds.dataset_name_pattern))
               group by name, id)
      select name,
             dbms_lob.substr(description, 4000, 1) || ' Primary Contact Email: '|| nvl(email, 'unavailable')
             || ' PMID: ' || publications || '<p style="color:black">Samples:</p>'
             || sample_table || chr(10) ||
             ' Please note that subtrack labels will disappear if the selected subtracks number is over 15!' as citation
      from (select ds.name as name, ds.summary as description, pubs.contact_email as email,
                   pubs.pmids as publications, samples.sample_table as sample_table
            from DatasetPresenter ds, pubs, samples
            where ds.dataset_presenter_id = pubs.id
              and ds.dataset_presenter_id = samples.id)
      ]]>
    </sql>
  </tuningTable>



  <tuningTable name="EqtlSpan">


    <externalDependency name="dots.ChromosomeElementFeature"/>
    <externalDependency name="apidb.NaFeatureHaploblock"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="dots.NaLocation"/>
    <internalDependency name="TranscriptAttributes"/>
    <sql>
      <![CDATA[
        create table eqtlSpan&1 nologging as
        select gene_source_id, project_id, haplotype_block_name as hapblock_id, sequence_id,
               start_min, end_max, start_max, end_min,
               max(score) as lod_score, organism
        from (select ga.gene_source_id, ga.project_id, gls.haplotype_block_name,
                     ens.source_id as sequence_id, nl.start_min, nl.end_max, nl.start_max, nl.end_min,
                     to_binary_double(gls.lod_score_mant|| 'e' || gls.lod_score_exp) as score,
                     replace (ga.organism, ' ', '+') as organism
              from dots.ChromosomeElementFeature cef, apidb.NAFeatureHaploblock gls,
                   dots.ExternalNaSequence ens, dots.NaLocation nl, TranscriptAttributes ga
              where gls.na_feature_id = ga.gene_na_feature_id
                and cef.name = gls.haplotype_block_name
                and nl.na_feature_id = cef.na_feature_id
                and cef.na_sequence_id = ens.na_sequence_id
                and to_binary_double(gls.lod_score_mant || 'e' || gls.lod_score_exp) >= 1.5)
        group by gene_source_id, project_id, sequence_id, haplotype_block_name,
                 start_min, end_max, start_max, end_min, organism
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index eqtlSpan_ix&1 on eqtlSpan&1 (gene_source_id, project_id)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="Pubmed" alwaysUpdate="true">
    <!-- PubMed info
      -->
    <internalDependency name="ExternalDbDatasetPresenter"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <program commandLine="buildPubmedTT"/>
  </tuningTable>

  <tuningTable name="GenePubmed">
    <!-- PubMed records mapped to genes
      -->
    <internalDependency name="DatasetPresenter"/>
    <internalDependency name="TranscriptAttributes"/>
    <internalDependency name="Pubmed"/>
    <externalDependency name="dots.DbRefNaFeature"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
        create table GenePubmed&1 nologging as
        select distinct ta.gene_source_id,ta.source_id, ta.project_id, pm.pubmed_id, pm.doi, pm.title, pm.authors
        from sres.ExternalDatabaseRelease edr, sres.DbRef db, TranscriptAttributes ta,
             dots.DbRefNaFeature dbna, sres.ExternalDatabase ed,
             DatasetPresenter dsa, Pubmed pm
        where edr.external_database_release_id = db.external_database_release_id
          and ed.external_database_id = edr.external_database_id
	  -- consider using ApiDBTuing.ExternalDbDatasetPresenter instead of the LIKE below, if its performance is a problem
          and (ed.name = dsa.name or ed.name like (dsa.dataset_name_pattern))
          and dbna.db_ref_id = db.db_ref_id
          and (ta.na_feature_id= dbna.na_feature_id or ta.gene_na_feature_id = dbna.na_feature_id)
          and lower(dsa.display_name) like '%pubmed%'
          and db.primary_identifier = to_char(pm.pubmed_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index gpm_ix&1
          on GenePubmed&1 (source_id, project_id, pubmed_id, doi, title, authors)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="Profile">
    <!-- One profile for one gene. Used for graphs
      -->
    <internalDependency name="GeneAttributes"/>
    <internalDependency name="CompoundAttributes"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="results.CompoundMassSpec"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <sql>
      <![CDATA[
      create table Profile&1 nologging as
      SELECT
        ds.name AS dataset_name
      , ds.type AS dataset_type
      , ds.subtype AS dataset_subtype
      , profile.profile_type
      , profile.source_id
      , profile.study_id AS profile_study_id
      , ps.name AS profile_set_name
      , profile.profile_as_string
      , profile.max_value
      , profile.min_value
      , profile.max_timepoint
      , profile.min_timepoint
      FROM
        apidb.DataSource ds
      , sres.ExternalDatabase d
      , sres.ExternalDatabaseRelease r
      , study.study i
      , study.study ps
      ,(SELECT
          res.source_id
        , res.profile_type
        , sl.study_id
        , res.id
        , listagg(ROUND(res.value, 6), chr(9)) within GROUP(ORDER BY pan.node_order_num) AS profile_as_string
        , MAX(res.value) AS max_value
        , min(value) as min_value
        , max(pan.name) keep(dense_rank last order by value) as max_timepoint
        , MAX(pan.name) keep(dense_rank FIRST ORDER BY value) AS min_timepoint
        FROM
          study.StudyLink sl
        , study.ProtocolAppNode pan
        ,(SELECT
            gene_profiles.*
          , ga.source_id
          FROM
            (SELECT
              'values' AS profile_type
            , MAX(value) AS value
            , na_feature_id AS id
            , protocol_app_node_id
            FROM
              results.NaFeatureHostResponse
            GROUP BY
              na_feature_id
            , protocol_app_node_id
            UNION
            SELECT
              'values' AS profile_type
            , value
            , na_feature_id AS id
            , protocol_app_node_id
            FROM
              results.NaFeatureExpression
            UNION
            SELECT
              'channel1_percentiles' AS profile_type
            , percentile_channel1 AS value
            , na_feature_id AS id
            , protocol_app_node_id
            FROM
              results.NaFeatureExpression
            UNION
            SELECT
              'channel2_percentiles' AS profile_type
            , percentile_channel2 AS value
            , na_feature_id AS id
            , protocol_app_node_id
            FROM
              results.NaFeatureExpression
            UNION
            SELECT
              'standard_error' AS profile_type
            , standard_error AS value
            , na_feature_id AS id
            , protocol_app_node_id
            FROM
              results.NaFeatureExpression
            ) gene_profiles
          , GeneAttributes ga
          WHERE
            gene_profiles.id = ga.na_feature_id
          UNION
          SELECT
            compound_profiles.profile_type
          , compound_profiles.value
          , compound_profiles.id
          , compound_profiles.protocol_app_node_id
          , CASE WHEN compound_profiles.isotopomer is null
                        THEN ca.source_id
                        ELSE ca.source_id || '|' || compound_profiles.isotopomer 
            END as source_id
          FROM
            (SELECT
              'values' AS profile_type
            , MAX(value) AS value
            , compound_id AS id
            , protocol_app_node_id
            , isotopomer
            FROM
              results.compoundmassspec
            GROUP BY
              compound_id
            , protocol_app_node_id
           , isotopomer
            ) compound_profiles
          , CompoundAttributes ca
          WHERE
            ca.id = compound_profiles.id
          ) res
        WHERE
          sl.protocol_app_node_id = pan.protocol_app_node_id
          AND pan.protocol_app_node_id = res.protocol_app_node_id(+)
        GROUP BY
          res.source_id
        , res.profile_type
        , sl.study_id
        , res.id
        ) profile
      WHERE
        ds.name = d.name
        AND ps.investigation_id = i.study_id
        AND ds.version = r.version
        AND d.external_database_id = r.external_database_id
        AND r.external_database_release_id = i.external_database_release_id
        AND i.investigation_id IS NULL
        AND profile.study_id = ps.study_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index exprof_idix&1
          on Profile&1 (source_id, profile_type, profile_set_name)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ProfileType">
    <internalDependency name="Profile"/>
    <sql>
      <![CDATA[
        CREATE TABLE ProfileType&1 nologging AS
	SELECT DISTINCT dataset_name, profile_study_id, profile_set_name,  profile_type
	FROM profile
	WHERE profile_as_string IS NOT NULL
	ORDER BY  dataset_name, profile_set_name,  profile_type
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProfileSamples">
    <internalDependency name="ProfileType"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="results.CompoundMassSpec"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <sql>
      <![CDATA[
      CREATE TABLE ProfileSamples&1 nologging AS
      SELECT * FROM (
	SELECT DISTINCT s.name AS study_name, s.study_id, 
	  REGEXP_REPLACE (  REGEXP_REPLACE (pan.name , ' \[.+\] \(.+\)', '') ,  ' \(.+\)', '')AS protocol_app_node_name,
	  pan.protocol_app_node_id, pan.node_order_num, pt.profile_type
	FROM profileType pt, study.study s, study.studyLink sl, 
	  study.protocolAppNode pan, results.nafeatureexpression r
	WHERE pt.profile_set_name =  s.name
	AND sl.study_id = s.study_id
	AND sl.protocol_app_node_id = pan.protocol_app_node_id
	AND  pan.protocol_app_node_id =r.protocol_app_node_id 
	UNION
	SELECT DISTINCT s.name AS study_name, s.study_id, 
	  REGEXP_REPLACE (  REGEXP_REPLACE (pan.name , ' \[.+\] \(.+\)', '') ,  ' \(.+\)', '')AS protocol_app_node_name,
	  pan.protocol_app_node_id, pan.node_order_num, pt.profile_type
	FROM profileType pt, study.study s, study.studyLink sl, 
	  study.protocolAppNode pan, results.compoundMassSpec r
	WHERE pt.profile_set_name =  s.name
	AND sl.study_id = s.study_id
	AND sl.protocol_app_node_id = pan.protocol_app_node_id
	AND  pan.protocol_app_node_id =r.protocol_app_node_id 
	) 
     ORDER BY study_name, node_order_num
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ExternalDbDatasetPresenter">
    <comment>
      A materialization of the oft-computed join of sres.externalDatabaseRelease,
      sres.externalDatabase, and apidbtuning.DatasetPresenter.
    </comment>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
        CREATE TABLE ExternalDbDatasetPresenter&1 NOLOGGING AS
        SELECT ed.external_database_id, ed.name AS external_database_name,
               edr.external_database_release_id, SUBSTR(edr.version, 1, 40) AS external_database_version,
               dsp.dataset_presenter_id, dsp.name AS dataset_presenter_name,
               dsp.display_name AS dataset_presenter_display_name
        FROM sres.externalDatabaseRelease edr,  sres.externalDatabase ed, apidbtuning.DatasetPresenter dsp
        WHERE ed.external_database_id = edr.external_database_id
          AND (ed.name = dsp.name
               OR ed.name LIKE dsp.dataset_name_pattern)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index edd_rlsidix&1
          on ExternalDbDatasetPresenter&1
            (external_database_release_id, external_database_id, external_database_name,
             dataset_presenter_id, dataset_presenter_name, dataset_presenter_display_name)
        tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index edd_dsidix&1
          on ExternalDbDatasetPresenter&1
            (dataset_presenter_id, external_database_id, external_database_release_id, 
             external_database_name, dataset_presenter_name, dataset_presenter_display_name)
        tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index edd_dsnameix&1
          on ExternalDbDatasetPresenter&1
            (dataset_presenter_name, dataset_presenter_id, external_database_id, 
             external_database_release_id, external_database_name, external_database_version, 
             dataset_presenter_display_name)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>

</tuningConfig>
